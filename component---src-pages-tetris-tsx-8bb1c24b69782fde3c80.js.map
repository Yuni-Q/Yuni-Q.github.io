{"version":3,"sources":["webpack:///./src/pages/tetris.tsx"],"names":["Table","styled","table","blocks","name","center","numCode","color","currentShapeIndex","shape","startRow","colors","isActiveBlock","value","isInvalidBlock","undefined","Tetris","useState","Array","fill","map","d","tetrisData","setTetrisData","nextTable","setNextTable","score","setScore","currentBlock","useRef","nextBlock","stopDown","intervalId","currentTopLeft","tick","nextTopLeft","current","canGoDown","currentBlockShape","i","length","j","newTetrisData","t","forEach","row","returnTetrisData","fullRows","col","count","_","push","fullRowsCount","filter","includes","unshift","checkRows","JSON","stringify","useEffect","rowIndex","cellIndex","keyDownEvent","event","code","isMovable","keyupEvent","isChangeable","nextShapeIndex","nextBlockShape","nextBlockShapeCell","window","addEventListener","setInterval","clearInterval","removeEventListener","Math","floor","random","slice","alert","cell","tr","key","td","style","backgroundColor"],"mappings":"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","file":"component---src-pages-tetris-tsx-8bb1c24b69782fde3c80.js","sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\nimport styled from 'styled-components';\nconst Table = styled.table`\n  width: auto !important;\n  border-collapse: collapse !important;\n  td {\n    border: 1px solid black;\n    width: 30px;\n    height: 30px;\n    padding: 0;\n  }\n`;\n\nconst blocks = [\n  {\n    name: 's', // 네모\n    center: false,\n    numCode: 1,\n    color: 'red',\n    currentShapeIndex: 0,\n    shape: [\n      [\n        [0, 0, 0],\n        [0, 1, 1],\n        [0, 1, 1],\n      ],\n    ],\n  },\n  {\n    name: 't', // T자\n    center: true,\n    numCode: 2,\n    color: 'orange',\n    currentShapeIndex: 0,\n    shape: [\n      [\n        [0, 0, 0],\n        [1, 1, 1],\n        [0, 1, 0],\n      ],\n      [\n        [0, 1, 0],\n        [1, 1, 0],\n        [0, 1, 0],\n      ],\n      [\n        [0, 1, 0],\n        [1, 1, 1],\n        [0, 0, 0],\n      ],\n      [\n        [0, 1, 0],\n        [0, 1, 1],\n        [0, 1, 0],\n      ],\n    ],\n  },\n  {\n    name: 'z', // 지그재그\n    center: true,\n    numCode: 3,\n    color: 'yellow',\n    currentShapeIndex: 0,\n    shape: [\n      [\n        [0, 0, 0],\n        [1, 1, 0],\n        [0, 1, 1],\n      ],\n      [\n        [0, 1, 0],\n        [1, 1, 0],\n        [1, 0, 0],\n      ],\n      [\n        [1, 1, 0],\n        [0, 1, 1],\n        [0, 0, 0],\n      ],\n      [\n        [0, 0, 1],\n        [0, 1, 1],\n        [0, 1, 0],\n      ],\n    ],\n  },\n  {\n    name: 'zr', // 반대 지그재그\n    center: true,\n    numCode: 4,\n    color: 'green',\n    startRow: 1,\n    currentShapeIndex: 0,\n    shape: [\n      [\n        [0, 0, 0],\n        [0, 1, 1],\n        [1, 1, 0],\n      ],\n      [\n        [1, 0, 0],\n        [1, 1, 0],\n        [0, 1, 0],\n      ],\n      [\n        [0, 1, 1],\n        [1, 1, 0],\n        [0, 0, 0],\n      ],\n      [\n        [0, 1, 0],\n        [0, 1, 1],\n        [0, 0, 1],\n      ],\n    ],\n  },\n  {\n    name: 'l', // L자\n    center: true,\n    numCode: 5,\n    color: 'blue',\n    currentShapeIndex: 0,\n    shape: [\n      [\n        [0, 0, 0],\n        [1, 1, 1],\n        [1, 0, 0],\n      ],\n      [\n        [1, 1, 0],\n        [0, 1, 0],\n        [0, 1, 0],\n      ],\n      [\n        [0, 0, 1],\n        [1, 1, 1],\n        [0, 0, 0],\n      ],\n      [\n        [0, 1, 0],\n        [0, 1, 0],\n        [0, 1, 1],\n      ],\n    ],\n  },\n  {\n    name: 'lr', // 반대 L자\n    center: true,\n    numCode: 6,\n    color: 'navy',\n    currentShapeIndex: 0,\n    shape: [\n      [\n        [0, 0, 0],\n        [1, 1, 1],\n        [0, 0, 1],\n      ],\n      [\n        [0, 1, 0],\n        [0, 1, 0],\n        [1, 1, 0],\n      ],\n      [\n        [1, 0, 0],\n        [1, 1, 1],\n        [0, 0, 0],\n      ],\n      [\n        [0, 1, 1],\n        [0, 1, 0],\n        [0, 1, 0],\n      ],\n    ],\n  },\n  {\n    name: 'b', // 1자\n    center: true,\n    numCode: 7,\n    color: 'violet',\n    currentShapeIndex: 0,\n    shape: [\n      [\n        [0, 0, 0, 0],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 0, 0, 0],\n      ],\n      [\n        [0, 1, 0, 0],\n        [0, 1, 0, 0],\n        [0, 1, 0, 0],\n        [0, 1, 0, 0],\n      ],\n      [\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 0, 0, 0],\n        [0, 0, 0, 0],\n      ],\n      [\n        [0, 0, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 1, 0],\n      ],\n    ],\n  },\n];\n\nconst colors = ['red', 'orange', 'yellow', 'green', 'blue', 'navy', 'violet'];\n\nconst isActiveBlock = (value) => value > 0 && value < 10;\nconst isInvalidBlock = (value) => value === undefined || value >= 10;\n\nconst Tetris: React.VFC = () => {\n  const [tetrisData, setTetrisData] = useState(\n    Array(20)\n      .fill([])\n      .map((d) => Array(10).fill(0)),\n  );\n  const [nextTable, setNextTable] = useState(\n    Array(4)\n      .fill([])\n      .map((d) => Array(4).fill(0)),\n  );\n  const [score, setScore] = useState(0);\n  const currentBlock = useRef(null);\n  const nextBlock = useRef(null);\n  const stopDown = useRef(true);\n  const intervalId = useRef(null);\n  const currentTopLeft = useRef([0, 3]);\n  function generate() {\n    // 테트리스 블록 생성\n    if (!nextBlock.current) {\n      nextBlock.current = blocks[Math.floor(Math.random() * blocks.length)];\n    }\n    if (!currentBlock.current) {\n      currentBlock.current = blocks[Math.floor(Math.random() * blocks.length)];\n    } else {\n      currentBlock.current = nextBlock.current;\n      nextBlock.current = blocks[Math.floor(Math.random() * blocks.length)];\n    }\n    currentTopLeft.current = [-1, 3];\n    currentBlock.current.shape[0].slice(1).forEach((col, i) => {\n      // 게임 오버 판단\n      col.forEach((row, j) => {\n        if (row && tetrisData[i][j + 3]) {\n          clearInterval(intervalId.current);\n          alert('게임오버');\n        }\n      });\n    });\n    setTetrisData((tetrisData) => {\n      const newTetrisData = [...tetrisData.map((t) => [...t])];\n      if (currentBlock?.current?.shape) {\n        currentBlock.current.shape[0].slice(1).forEach((row, rowIndex) => {\n          row.forEach((cell, cellIndex) => {\n            newTetrisData[rowIndex][cellIndex + 3] = cell\n              ? currentBlock.current.numCode\n              : 0;\n          });\n        });\n      }\n      return newTetrisData;\n    });\n  }\n  const checkRows = (tetrisData) => {\n    // 한 줄 다 찼는지 검사\n    const fullRows = [];\n    tetrisData.forEach((col, i) => {\n      let count = 0;\n      col.forEach((row, _) => {\n        if (row > 0) {\n          count++;\n        }\n      });\n      if (count === 10) {\n        fullRows.push(i);\n      }\n    });\n    const fullRowsCount = fullRows.length;\n    tetrisData = tetrisData.filter((row, i) => !fullRows.includes(i));\n    for (let i = 0; i < fullRowsCount; i++) {\n      tetrisData.unshift([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n    }\n    setScore((score) => (score += fullRowsCount ** 2));\n    return tetrisData;\n  };\n\n  const tick = () => {\n    // 한 칸 아래로\n    setTetrisData((tetrisData) => {\n      const nextTopLeft = [\n        currentTopLeft.current[0] + 1,\n        currentTopLeft.current[1],\n      ];\n      let canGoDown = true;\n      const currentBlockShape =\n        currentBlock.current.shape[currentBlock.current.currentShapeIndex];\n      for (\n        let i = currentTopLeft.current[0];\n        i < currentTopLeft.current[0] + currentBlockShape.length;\n        i++\n      ) {\n        // 아래 블럭이 있으면\n        if (i < 0 || i >= 20) continue;\n        for (\n          let j = currentTopLeft.current[1];\n          j < currentTopLeft.current[1] + currentBlockShape.length;\n          j++\n        ) {\n          if (isActiveBlock(tetrisData[i][j])) {\n            // 현재 움직이는 블럭이면\n            if (isInvalidBlock(tetrisData[i + 1] && tetrisData[i + 1][j])) {\n              canGoDown = false;\n            }\n          }\n        }\n      }\n      if (!canGoDown) {\n        stopDown.current = true;\n      } else {\n        currentTopLeft.current = nextTopLeft;\n      }\n      const newTetrisData = [...tetrisData.map((t) => [...t])];\n      for (let i = newTetrisData.length - 1; i >= 0; i--) {\n        const col = tetrisData[i];\n        col.forEach((row, j) => {\n          if (\n            row > 0 &&\n            row < 10 &&\n            newTetrisData[i + 1]?.[j] < 10 &&\n            !!canGoDown\n          ) {\n            newTetrisData[i + 1][j] = row;\n            newTetrisData[i][j] = 0;\n          } else if (row !== 0 && row < 10) {\n            newTetrisData[i][j] = row * 10;\n          }\n        });\n      }\n      const returnTetrisData = checkRows(newTetrisData);\n      if (JSON.stringify(newTetrisData) !== JSON.stringify(tetrisData)) {\n        return returnTetrisData;\n      }\n      return tetrisData;\n    });\n  };\n  useEffect(() => {\n    setNextTable((nextTable) => {\n      return nextTable.map((row, rowIndex) => {\n        return row.map((_, cellIndex) => {\n          if (nextBlock?.current?.shape?.[0]?.[rowIndex]?.[cellIndex]) {\n            return nextBlock.current.shape[0][rowIndex][cellIndex]\n              ? nextBlock.current.numCode\n              : 0;\n          }\n          return 0;\n        });\n      });\n    });\n  }, [nextBlock.current]);\n\n  useEffect(() => {\n    const keyDownEvent = (event: KeyboardEvent) => {\n      setTetrisData((tetrisData) => {\n        switch (event.code) {\n          case 'ArrowLeft': {\n            // 키보드 왼쪽 클릭 = 좌측 한 칸 이동\n            const nextTopLeft = [\n              currentTopLeft.current[0],\n              currentTopLeft.current[1] - 1,\n            ];\n            let isMovable = true;\n            const currentBlockShape =\n              currentBlock.current.shape[\n                currentBlock.current.currentShapeIndex\n              ];\n            for (\n              let i = currentTopLeft.current[0];\n              i < currentTopLeft.current[0] + currentBlockShape.length;\n              i++\n            ) {\n              // 왼쪽 공간 체크\n              if (!isMovable) break;\n              for (\n                let j = currentTopLeft.current[1];\n                j < currentTopLeft.current[1] + currentBlockShape.length;\n                j++\n              ) {\n                if (!tetrisData[i] || !tetrisData[i][j]) continue;\n                if (\n                  isActiveBlock(tetrisData[i][j]) &&\n                  isInvalidBlock(tetrisData[i] && tetrisData[i][j - 1])\n                ) {\n                  isMovable = false;\n                }\n              }\n            }\n            if (isMovable) {\n              currentTopLeft.current = nextTopLeft;\n              tetrisData.forEach((col, i) => {\n                for (let j = 0; j < col.length; j++) {\n                  const row = col[j];\n                  if (tetrisData[i][j - 1] === 0 && row < 10) {\n                    tetrisData[i][j - 1] = row;\n                    tetrisData[i][j] = 0;\n                  }\n                }\n              });\n            }\n            break;\n          }\n          case 'ArrowRight': {\n            // 키보드 오른쪽 클릭 = 우측 한 칸 이동\n            const nextTopLeft = [\n              currentTopLeft.current[0],\n              currentTopLeft.current[1] + 1,\n            ];\n            let isMovable = true;\n            const currentBlockShape =\n              currentBlock.current.shape[\n                currentBlock.current.currentShapeIndex\n              ];\n            for (\n              let i = currentTopLeft.current[0];\n              i < currentTopLeft.current[0] + currentBlockShape.length;\n              i++\n            ) {\n              // 오른쪽 공간 체크\n              if (!isMovable) break;\n              for (\n                let j = currentTopLeft.current[1];\n                j < currentTopLeft.current[1] + currentBlockShape.length;\n                j++\n              ) {\n                if (!tetrisData[i] || !tetrisData[i][j]) continue;\n                if (\n                  isActiveBlock(tetrisData[i][j]) &&\n                  isInvalidBlock(tetrisData[i] && tetrisData[i][j + 1])\n                ) {\n                  isMovable = false;\n                }\n              }\n            }\n            if (isMovable) {\n              currentTopLeft.current = nextTopLeft;\n              tetrisData.forEach((col, i) => {\n                for (let j = col.length - 1; j >= 0; j--) {\n                  const row = col[j];\n                  if (tetrisData[i][j + 1] === 0 && row < 10) {\n                    tetrisData[i][j + 1] = row;\n                    tetrisData[i][j] = 0;\n                  }\n                }\n              });\n            }\n            break;\n          }\n          case 'ArrowDown': {\n            // 키보드 아래쪽 클릭 = 하방측 한 칸 이동\n            tick();\n          }\n        }\n        return tetrisData;\n      });\n    };\n    const keyupEvent = (event: KeyboardEvent) => {\n      switch (event.code) {\n        case 'Space':\n          while (!stopDown.current) {\n            tick();\n          }\n          break;\n        case 'ArrowUp': {\n          setTetrisData((tetrisData) => {\n            // 방향 전환\n            const currentBlockShape =\n              currentBlock.current.shape[\n                currentBlock.current.currentShapeIndex\n              ];\n            let isChangeable = true;\n            const nextShapeIndex =\n              currentBlock.current.currentShapeIndex + 1 ===\n              currentBlock.current.shape.length\n                ? 0\n                : currentBlock.current.currentShapeIndex + 1;\n            const nextBlockShape = currentBlock.current.shape[nextShapeIndex];\n            for (\n              let i = currentTopLeft.current[0];\n              i < currentTopLeft.current[0] + currentBlockShape.length;\n              i++\n            ) {\n              // 돌린 이후 공간 체크\n              if (!isChangeable) break;\n              for (\n                let j = currentTopLeft.current[1];\n                j < currentTopLeft.current[1] + currentBlockShape.length;\n                j++\n              ) {\n                if (!tetrisData[i]) continue;\n                if (\n                  nextBlockShape[i - currentTopLeft.current[0]][\n                    j - currentTopLeft.current[1]\n                  ] > 0 &&\n                  isInvalidBlock(tetrisData[i] && tetrisData[i][j])\n                ) {\n                  isChangeable = false;\n                }\n              }\n            }\n            if (isChangeable) {\n              while (currentTopLeft.current[0] < 0) {\n                tick();\n              }\n              for (\n                let i = currentTopLeft.current[0];\n                i < currentTopLeft.current[0] + currentBlockShape.length;\n                i++\n              ) {\n                // 돌린 이후 공간 체크\n                for (\n                  let j = currentTopLeft.current[1];\n                  j < currentTopLeft.current[1] + currentBlockShape.length;\n                  j++\n                ) {\n                  if (!tetrisData[i]) continue;\n                  const nextBlockShapeCell =\n                    nextBlockShape[i - currentTopLeft.current[0]][\n                      j - currentTopLeft.current[1]\n                    ];\n                  if (nextBlockShapeCell > 0 && tetrisData[i][j] === 0) {\n                    // 다음 모양은 있는데 현재 칸이 없으면\n                    tetrisData[i][j] = currentBlock.current.numCode;\n                  } else if (\n                    nextBlockShapeCell === 0 &&\n                    tetrisData[i][j] &&\n                    tetrisData[i][j] < 10\n                  ) {\n                    // 다음 모양은 없는데  현재 칸이 있으면\n                    tetrisData[i][j] = 0;\n                  }\n                }\n              }\n              currentBlock.current.currentShapeIndex = nextShapeIndex;\n            }\n            return tetrisData;\n          });\n\n          break;\n        }\n      }\n    };\n    window.addEventListener('keydown', keyDownEvent);\n    window.addEventListener('keyup', keyupEvent);\n    intervalId.current = setInterval(() => tick(), 300);\n    return () => {\n      clearInterval(intervalId.current);\n      window.removeEventListener('keydown', keyDownEvent);\n      window.removeEventListener('keyup', keyupEvent);\n    };\n  }, []);\n  useEffect(() => {\n    if (stopDown.current) {\n      stopDown.current = false;\n      generate();\n    }\n  }, [stopDown.current]);\n  return (\n    <>\n      <Table>\n        <tbody>\n          {tetrisData.map((tr, rowIndex) => {\n            return (\n              <tr key={`${tr}-${rowIndex}`}>\n                {tr.map((td, cellIndex) => {\n                  return (\n                    <td\n                      style={{\n                        backgroundColor:\n                          tetrisData[rowIndex][cellIndex] >= 10\n                            ? colors[tetrisData[rowIndex][cellIndex] / 10 - 1]\n                            : colors[tetrisData[rowIndex][cellIndex] - 1],\n                      }}\n                      key={`${td}-${cellIndex}`}\n                    >\n                      {td}\n                    </td>\n                  );\n                })}\n              </tr>\n            );\n          })}\n        </tbody>\n      </Table>\n      <Table>\n        <tbody>\n          {nextTable.map((tr, rowIndex) => {\n            return (\n              <tr key={`${tr}-${rowIndex}`}>\n                {tr.map((td, cellIndex) => {\n                  return (\n                    <td\n                      style={{\n                        backgroundColor:\n                          colors[nextTable[rowIndex][cellIndex] - 1],\n                      }}\n                      key={`${td}-${cellIndex}`}\n                    >\n                      {td}\n                    </td>\n                  );\n                })}\n              </tr>\n            );\n          })}\n        </tbody>\n      </Table>\n      <div>{score}</div>\n    </>\n  );\n};\n\nexport default Tetris;\n"],"sourceRoot":""}