3:I[808,[],""]
6:I[6217,[],""]
7:I[5217,["3185","static/chunks/app/layout-3ad8bb7cb2292578.js"],"ServiceWorkerCleanup"]
8:I[6484,["3185","static/chunks/app/layout-3ad8bb7cb2292578.js"],"ThemeProvider"]
4:["category","javascript","d"]
5:["slug","iterator","c"]
0:["static-build-id",[[["",{"children":[["category","javascript","d"],{"children":[["slug","iterator","c"],{"children":["__PAGE__?{\"category\":\"javascript\",\"slug\":[\"iterator\"]}",{}]}]}]},"$undefined","$undefined",true],["",{"children":[["category","javascript","d"],{"children":[["slug","iterator","c"],{"children":["__PAGE__",{},[["$L1","$L2",null],null],null]},[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children","$5","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/bc8bb31cb71603b2.css","precedence":"next","crossOrigin":"$undefined"}]],["$","html",null,{"lang":"ko","children":[["$","head",null,{"children":[["$","link",null,{"rel":"preconnect","href":"https://fonts.googleapis.com"}],["$","link",null,{"rel":"preconnect","href":"https://fonts.gstatic.com","crossOrigin":"anonymous"}],["$","link",null,{"href":"https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap","rel":"stylesheet"}],["$","link",null,{"href":"https://fonts.googleapis.com/css2?family=Catamaran:wght@800&display=swap","rel":"stylesheet"}],["$","link",null,{"rel":"icon","type":"image/png","href":"/favicon2.png"}],["$","link",null,{"rel":"shortcut icon","href":"/favicon2.png"}],["$","link",null,{"rel":"apple-touch-icon","href":"/favicon2.png"}],["$","script",null,{"id":"ads","async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"}],["$","script",null,{"dangerouslySetInnerHTML":{"__html":"(adsbygoogle=window.adsbygoogle||[]).requestNonPersonalizedAds=1;"}}]]}],["$","body",null,{"children":[["$","noscript",null,{"children":"You need to enable JavaScript to run this app."}],["$","$L7",null,{}],["$","$L8",null,{"children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[]}]}]]}]]}]],null],null],["$L9",null]]]]
a:I[5553,["9243","static/chunks/9243-972bdccd4ceb11ae.js","5800","static/chunks/5800-4312aed1aa8a4305.js","549","static/chunks/549-2babc012700e23ed.js","4853","static/chunks/4853-73ca7990eb89674b.js","8936","static/chunks/app/%5Bcategory%5D/%5B...slug%5D/page-6aac7cf9456deffb.js"],"BlogPostPageClient"]
b:T165c,
- Iterator는 자바스크립트의 collection을 반복하는 새로운 방법입니다. ES6에서 소개된 개념이고 매우 유용하고 많은 곳에서 사용되고 있기 때문에 인기가 많습니다.

## 반복 가능한 것(Iterable)과 Iterator

- `메소드의 이름과 반환 타입이 고정되어 있고 변하지 않는다는 규칙`을 적용한 메소드가 iteratorMethod 입니다.
- 이와 비슷하게 사용자 정의 오브젝트를 반복하는 프로세스의 표준화가 `ECMA`에 의해 진행되었습니다. 하지만, iteratorMethod라는 이름을 사용하는 대신에, ECMA는 Symbol.iterator라는 이름을 사용했습니다. `Symbol`은 유일(unique)한 이름을 제공합니다. 그리고 다른 프로퍼티 이름과 충돌이 발생하지 않습니다. 또한, `Symbol.iterator`는 `iterator라 불리는 오브젝트를 반환합니다`. 이 iterator는 next라 불리는 메소드를 가질 것입니다. iterator는 또한 value와 done이라는 키를 가진 오브젝트입니다.
  - value 키는 현재의 값을 포함할 것입니다. 이 값은 어떠한 타입이든 될 수 있습니다. done은 boolean입니다. done은 모든 값이 전달(fetched)되었는지 아닌지를 나타냅니다.
  - iterables, iterators, next 사이 관계를 `Iteration Protocol(반복 프로토콜)`이라고 부릅니다.
- iterable은 자신의 원소들이 외부에서 접근 가능하도록 만들길 원하는 자료 구조입니다. 키가 Symbol.iterator인 메소드를 구현함으로써 원소들이 외부에서 접근 가능하도록 만듭니다. Symbol.iterator 메소드는 iterator를 위한 공장이라고 보면 됩니다. iterator들을 만들어냅니다.
- iterator는 자료 구조의 원소들을 순회할 수 있는 포인터입니다.

## 오브젝트를 반복 가능(iterable)하게 만들어보기

```javascript
const iterable = {
	[Symbol.iterator]() {
		let step = 0;
		const iterator = {
			next() {
				step++;

				if (step === 1) {
					return { value: 'This', done: false };
				} else if (step === 2) {
					return { value: 'is', done: false };
				} else if (step === 3) {
					return { value: 'iterable', done: false };
				}
				return { value: undefined, done: true };
			},
		};
		return iterator;
	},
};

var iterator = iterator[Symbol.iterator]();
iterator.next(); // { value: 'This', done: false }
iterator.next(); // { value: 'is', done: false };
iterator.next(); // { value: 'iterable', done: false }
iterator.next(); // { value: undefined, done: true };
```

## 자바스크립트 내에서 Iterable들

- 배열과 타입이 정해진 배열
- 문자열 - 각 문자 또는 유니코드 코드-포인트를 반복합니다.
- 맵 - 키-값 쌍을 반복합니다.
- 셋 - 원소를 반복합니다.
- arguments - 함수의 배열과 같은 특별한 변수를 반복합니다.
- DOM 원소들

### 자바스크립트에서 iterables을 인자로 사용하는 생성자들은 다음과 같습니다.

- for-of 반복 - for-of 반복은 반복 가능한 것을 필요로 합니다. 반복이 불가능하다면, for-of는 TypeError를 던질 것입니다.

```javascript
for (const value of iterable) { ... }
```

- 배열의 비구조화 (Destructuring of Arrays) - 비구조화는 반복 가능(iterable)하기에 일어납니다.
- 전개 연산자 (Spread operator)
- Promise.all 과 Promise.race 역시 Promise 전반에서 iterable을 수용합니다.
- Map과 Set
  - Map의 생성자는 Iterable [key, pair]의 쌍을 Map으로 변화시킵니다. 그리고 Set의 생성자는 Iterable의 [key, pair]의 쌍을 Set으로 변화시킵니다.
- Iterator는 또한 Generator의 선배입니다.

## myFavouriteAuthors를 Iterable로 만들기

```javascript
const myFavouriteAuthors = {
	allAuthors: {
		fiction: ['Agatha Christie', 'J. K. Rowling', 'Dr. Seuss'],
		scienceFiction: [
			'Neal Stephenson',
			'Arthur Clarke',
			'Isaac Asimov',
			'Robert Heinlein',
		],
		fantasy: ['J. R. R. Tolkien', 'J. K. Rowling', 'Terry Pratchett'],
	},
	[Symbol.iterator]() {
		// 모든 작가를 배열로 받기
		const genres = Object.values(this.allAuthors);

		// 현재의 장르와 작가 인덱스를 저장하기
		let currentAuthorIndex = 0;
		let currentGenreIndex = 0;

		return {
			// next() 구현
			next() {
				// 현재 장르 인덱스에 따른 작가들
				const authors = genres[currentGenreIndex];

				// doNotHaveMoreAuthors 는 Authors 배열을 전부 돌았을 때, 참이 됩니다.
				// 모든 아이템이 소비되었을 때, 참이 됩니다.
				const doNotHaveMoreAuthors = !(currentAuthorIndex < authors.length);
				if (doNotHaveMoreAuthors) {
					// 더 이상 불러올 작가가 없을 때, 다음 장르 인덱스(currentGenreIndex)가 다음으로 넘어갑니다.
					currentGenreIndex++;
					// 그리고 작가 인덱스(currentAuthorIndex)가 0이 됩니다.
					currentAuthorIndex = 0;
				}

				// 만일 모든 장르가 끝났다면,
				// 우리는 아이터레이터에게 더 이상 우리가 줄 값이 없다는 것을 알려야 합니다.
				const doNotHaveMoreGenres = !(currentGenreIndex < genres.length);
				if (doNotHaveMoreGenres) {
					return {
						value: undefined,
						done: true,
					};
				}

				// 만일 모든 것들이 맞다면, 현재 장르로부터 작가 이름을 반환합니다.
				// 그리고 작가 인덱스를 하나 늘립니다(increment).
				// 다음에는, 다음 작가가 반환됩니다.
				return {
					value: genres[currentGenreIndex][currentAuthorIndex++],
					done: false,
				};
			},
		};
	},
};

for (const author of myFavouriteAuthors) {
	console.log(author);
}

console.log(...myFavouriteAuthors);
```
c:T5aa3,<ul>
<li>Iterator는 자바스크립트의 collection을 반복하는 새로운 방법입니다. ES6에서 소개된 개념이고 매우 유용하고 많은 곳에서 사용되고 있기 때문에 인기가 많습니다.</li>
</ul>
<h2 id="반복-가능한-것iterable과-iterator">반복 가능한 것(Iterable)과 Iterator<a aria-hidden="true" tabindex="-1" href="#반복-가능한-것iterable과-iterator"><span class="anchor"></span></a></h2>
<ul>
<li><code class="inline-code">메소드의 이름과 반환 타입이 고정되어 있고 변하지 않는다는 규칙</code>을 적용한 메소드가 iteratorMethod 입니다.</li>
<li>이와 비슷하게 사용자 정의 오브젝트를 반복하는 프로세스의 표준화가 <code class="inline-code">ECMA</code>에 의해 진행되었습니다. 하지만, iteratorMethod라는 이름을 사용하는 대신에, ECMA는 Symbol.iterator라는 이름을 사용했습니다. <code class="inline-code">Symbol</code>은 유일(unique)한 이름을 제공합니다. 그리고 다른 프로퍼티 이름과 충돌이 발생하지 않습니다. 또한, <code class="inline-code">Symbol.iterator</code>는 <code class="inline-code">iterator라 불리는 오브젝트를 반환합니다</code>. 이 iterator는 next라 불리는 메소드를 가질 것입니다. iterator는 또한 value와 done이라는 키를 가진 오브젝트입니다.
<ul>
<li>value 키는 현재의 값을 포함할 것입니다. 이 값은 어떠한 타입이든 될 수 있습니다. done은 boolean입니다. done은 모든 값이 전달(fetched)되었는지 아닌지를 나타냅니다.</li>
<li>iterables, iterators, next 사이 관계를 <code class="inline-code">Iteration Protocol(반복 프로토콜)</code>이라고 부릅니다.</li>
</ul>
</li>
<li>iterable은 자신의 원소들이 외부에서 접근 가능하도록 만들길 원하는 자료 구조입니다. 키가 Symbol.iterator인 메소드를 구현함으로써 원소들이 외부에서 접근 가능하도록 만듭니다. Symbol.iterator 메소드는 iterator를 위한 공장이라고 보면 됩니다. iterator들을 만들어냅니다.</li>
<li>iterator는 자료 구조의 원소들을 순회할 수 있는 포인터입니다.</li>
</ul>
<h2 id="오브젝트를-반복-가능iterable하게-만들어보기">오브젝트를 반복 가능(iterable)하게 만들어보기<a aria-hidden="true" tabindex="-1" href="#오브젝트를-반복-가능iterable하게-만들어보기"><span class="anchor"></span></a></h2>
<pre class="language-javascript optimized-code-block" style="max-height: 600px; overflow-y: auto;"><code class="language-javascript code-highlight"><span class="code-line"><span class="token keyword">const</span> iterable <span class="token operator">=</span> <span class="token punctuation">{</span>
</span><span class="code-line">	<span class="token punctuation">[</span><span class="token known-class-name class-name">Symbol</span><span class="token punctuation">.</span><span class="token property-access">iterator</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">		<span class="token keyword">let</span> step <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</span><span class="code-line">		<span class="token keyword">const</span> iterator <span class="token operator">=</span> <span class="token punctuation">{</span>
</span><span class="code-line">			<span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">				step<span class="token operator">++</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">				<span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>step <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">					<span class="token keyword control-flow">return</span> <span class="token punctuation">{</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token string">'This'</span><span class="token punctuation">,</span> <span class="token literal-property property">done</span><span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line">				<span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>step <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">					<span class="token keyword control-flow">return</span> <span class="token punctuation">{</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token string">'is'</span><span class="token punctuation">,</span> <span class="token literal-property property">done</span><span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line">				<span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>step <span class="token operator">===</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">					<span class="token keyword control-flow">return</span> <span class="token punctuation">{</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token string">'iterable'</span><span class="token punctuation">,</span> <span class="token literal-property property">done</span><span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line">				<span class="token punctuation">}</span>
</span><span class="code-line">				<span class="token keyword control-flow">return</span> <span class="token punctuation">{</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token keyword nil">undefined</span><span class="token punctuation">,</span> <span class="token literal-property property">done</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line">			<span class="token punctuation">}</span><span class="token punctuation">,</span>
</span><span class="code-line">		<span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line">		<span class="token keyword control-flow">return</span> iterator<span class="token punctuation">;</span>
</span><span class="code-line">	<span class="token punctuation">}</span><span class="token punctuation">,</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">var</span> iterator <span class="token operator">=</span> iterator<span class="token punctuation">[</span><span class="token known-class-name class-name">Symbol</span><span class="token punctuation">.</span><span class="token property-access">iterator</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">iterator<span class="token punctuation">.</span><span class="token method function property-access">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { value: 'This', done: false }</span>
</span><span class="code-line">iterator<span class="token punctuation">.</span><span class="token method function property-access">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { value: 'is', done: false };</span>
</span><span class="code-line">iterator<span class="token punctuation">.</span><span class="token method function property-access">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { value: 'iterable', done: false }</span>
</span><span class="code-line">iterator<span class="token punctuation">.</span><span class="token method function property-access">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { value: undefined, done: true };</span>
</span></code></pre>
<h2 id="자바스크립트-내에서-iterable들">자바스크립트 내에서 Iterable들<a aria-hidden="true" tabindex="-1" href="#자바스크립트-내에서-iterable들"><span class="anchor"></span></a></h2>
<ul>
<li>배열과 타입이 정해진 배열</li>
<li>문자열 - 각 문자 또는 유니코드 코드-포인트를 반복합니다.</li>
<li>맵 - 키-값 쌍을 반복합니다.</li>
<li>셋 - 원소를 반복합니다.</li>
<li>arguments - 함수의 배열과 같은 특별한 변수를 반복합니다.</li>
<li>DOM 원소들</li>
</ul>
<h3 id="자바스크립트에서-iterables을-인자로-사용하는-생성자들은-다음과-같습니다">자바스크립트에서 iterables을 인자로 사용하는 생성자들은 다음과 같습니다.<a aria-hidden="true" tabindex="-1" href="#자바스크립트에서-iterables을-인자로-사용하는-생성자들은-다음과-같습니다"><span class="anchor"></span></a></h3>
<ul>
<li>for-of 반복 - for-of 반복은 반복 가능한 것을 필요로 합니다. 반복이 불가능하다면, for-of는 TypeError를 던질 것입니다.</li>
</ul>
<pre class="language-javascript optimized-code-block" style="max-height: 600px; overflow-y: auto;"><code class="language-javascript code-highlight"><span class="code-line"><span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> value <span class="token keyword">of</span> iterable<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span>
</span></code></pre>
<ul>
<li>배열의 비구조화 (Destructuring of Arrays) - 비구조화는 반복 가능(iterable)하기에 일어납니다.</li>
<li>전개 연산자 (Spread operator)</li>
<li>Promise.all 과 Promise.race 역시 Promise 전반에서 iterable을 수용합니다.</li>
<li>Map과 Set
<ul>
<li>Map의 생성자는 Iterable [key, pair]의 쌍을 Map으로 변화시킵니다. 그리고 Set의 생성자는 Iterable의 [key, pair]의 쌍을 Set으로 변화시킵니다.</li>
</ul>
</li>
<li>Iterator는 또한 Generator의 선배입니다.</li>
</ul>
<h2 id="myfavouriteauthors를-iterable로-만들기">myFavouriteAuthors를 Iterable로 만들기<a aria-hidden="true" tabindex="-1" href="#myfavouriteauthors를-iterable로-만들기"><span class="anchor"></span></a></h2>
<pre class="language-javascript optimized-code-block" style="max-height: 600px; overflow-y: auto;"><code class="language-javascript code-highlight"><span class="code-line"><span class="token keyword">const</span> myFavouriteAuthors <span class="token operator">=</span> <span class="token punctuation">{</span>
</span><span class="code-line">	<span class="token literal-property property">allAuthors</span><span class="token operator">:</span> <span class="token punctuation">{</span>
</span><span class="code-line">		<span class="token literal-property property">fiction</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'Agatha Christie'</span><span class="token punctuation">,</span> <span class="token string">'J. K. Rowling'</span><span class="token punctuation">,</span> <span class="token string">'Dr. Seuss'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
</span><span class="code-line">		<span class="token literal-property property">scienceFiction</span><span class="token operator">:</span> <span class="token punctuation">[</span>
</span><span class="code-line">			<span class="token string">'Neal Stephenson'</span><span class="token punctuation">,</span>
</span><span class="code-line">			<span class="token string">'Arthur Clarke'</span><span class="token punctuation">,</span>
</span><span class="code-line">			<span class="token string">'Isaac Asimov'</span><span class="token punctuation">,</span>
</span><span class="code-line">			<span class="token string">'Robert Heinlein'</span><span class="token punctuation">,</span>
</span><span class="code-line">		<span class="token punctuation">]</span><span class="token punctuation">,</span>
</span><span class="code-line">		<span class="token literal-property property">fantasy</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'J. R. R. Tolkien'</span><span class="token punctuation">,</span> <span class="token string">'J. K. Rowling'</span><span class="token punctuation">,</span> <span class="token string">'Terry Pratchett'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
</span><span class="code-line">	<span class="token punctuation">}</span><span class="token punctuation">,</span>
</span><span class="code-line">	<span class="token punctuation">[</span><span class="token known-class-name class-name">Symbol</span><span class="token punctuation">.</span><span class="token property-access">iterator</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">		<span class="token comment">// 모든 작가를 배열로 받기</span>
</span><span class="code-line">		<span class="token keyword">const</span> genres <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">values</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">allAuthors</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">		<span class="token comment">// 현재의 장르와 작가 인덱스를 저장하기</span>
</span><span class="code-line">		<span class="token keyword">let</span> currentAuthorIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</span><span class="code-line">		<span class="token keyword">let</span> currentGenreIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">		<span class="token keyword control-flow">return</span> <span class="token punctuation">{</span>
</span><span class="code-line">			<span class="token comment">// next() 구현</span>
</span><span class="code-line">			<span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">				<span class="token comment">// 현재 장르 인덱스에 따른 작가들</span>
</span><span class="code-line">				<span class="token keyword">const</span> authors <span class="token operator">=</span> genres<span class="token punctuation">[</span>currentGenreIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">				<span class="token comment">// doNotHaveMoreAuthors 는 Authors 배열을 전부 돌았을 때, 참이 됩니다.</span>
</span><span class="code-line">				<span class="token comment">// 모든 아이템이 소비되었을 때, 참이 됩니다.</span>
</span><span class="code-line">				<span class="token keyword">const</span> doNotHaveMoreAuthors <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span>currentAuthorIndex <span class="token operator">&#x3C;</span> authors<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">				<span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>doNotHaveMoreAuthors<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">					<span class="token comment">// 더 이상 불러올 작가가 없을 때, 다음 장르 인덱스(currentGenreIndex)가 다음으로 넘어갑니다.</span>
</span><span class="code-line">					currentGenreIndex<span class="token operator">++</span><span class="token punctuation">;</span>
</span><span class="code-line">					<span class="token comment">// 그리고 작가 인덱스(currentAuthorIndex)가 0이 됩니다.</span>
</span><span class="code-line">					currentAuthorIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</span><span class="code-line">				<span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">				<span class="token comment">// 만일 모든 장르가 끝났다면,</span>
</span><span class="code-line">				<span class="token comment">// 우리는 아이터레이터에게 더 이상 우리가 줄 값이 없다는 것을 알려야 합니다.</span>
</span><span class="code-line">				<span class="token keyword">const</span> doNotHaveMoreGenres <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span>currentGenreIndex <span class="token operator">&#x3C;</span> genres<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">				<span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>doNotHaveMoreGenres<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">					<span class="token keyword control-flow">return</span> <span class="token punctuation">{</span>
</span><span class="code-line">						<span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token keyword nil">undefined</span><span class="token punctuation">,</span>
</span><span class="code-line">						<span class="token literal-property property">done</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
</span><span class="code-line">					<span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line">				<span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">				<span class="token comment">// 만일 모든 것들이 맞다면, 현재 장르로부터 작가 이름을 반환합니다.</span>
</span><span class="code-line">				<span class="token comment">// 그리고 작가 인덱스를 하나 늘립니다(increment).</span>
</span><span class="code-line">				<span class="token comment">// 다음에는, 다음 작가가 반환됩니다.</span>
</span><span class="code-line">				<span class="token keyword control-flow">return</span> <span class="token punctuation">{</span>
</span><span class="code-line">					<span class="token literal-property property">value</span><span class="token operator">:</span> genres<span class="token punctuation">[</span>currentGenreIndex<span class="token punctuation">]</span><span class="token punctuation">[</span>currentAuthorIndex<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
</span><span class="code-line">					<span class="token literal-property property">done</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
</span><span class="code-line">				<span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line">			<span class="token punctuation">}</span><span class="token punctuation">,</span>
</span><span class="code-line">		<span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line">	<span class="token punctuation">}</span><span class="token punctuation">,</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> author <span class="token keyword">of</span> myFavouriteAuthors<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">	<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>author<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token spread operator">...</span>myFavouriteAuthors<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code></pre>2:["$","$La",null,{"post":{"slug":"/javascript/iterator","frontmatter":{"title":"Iterator","date":"2020-04-12T00:04:35.000Z","category":"javascript","draft":false},"content":"$b","html":"$c","excerpt":"- Iterator는 자바스크립트의 collection을 반복하는 새로운 방법입니다. ES6에서 소개된 개념이고 매우 유용하고 많은 곳에서 사용되고 있기 때문에 인기가 많습니다.  ## 반복 가능한 것(Iterable)과 Iterator  - `메소드의 이름과 반환 타입이 고정되어 있고 변하지 않는다는 규칙`을 적용한 메소드가 iteratorMethod"},"previousPost":{"slug":"/javascript/generator","frontmatter":{"title":"generator","date":"2020-04-12T00:04:09.000Z","category":"javascript","draft":false}},"nextPost":{"slug":"/javascript/async-await","frontmatter":{"title":"Async Await","date":"2020-04-12T01:05:06.000Z","category":"javascript","draft":false}}}]
9:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"Iterator"}],["$","meta","3",{"name":"description","content":"- Iterator는 자바스크립트의 collection을 반복하는 새로운 방법입니다. ES6에서 소개된 개념이고 매우 유용하고 많은 곳에서 사용되고 있기 때문에 인기가 많습니다.  ## 반복 가능한 것(Iterable)과 Iterator  - `메소드의 이름과 반환 타입이 고정되어 있고 변하지 않는다는 규칙`을 적용한 메소드가 iteratorMethod"}]]
1:null
