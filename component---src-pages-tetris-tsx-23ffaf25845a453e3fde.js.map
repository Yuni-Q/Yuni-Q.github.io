{"version":3,"file":"component---src-pages-tetris-tsx-23ffaf25845a453e3fde.js","mappings":"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","sources":["webpack://yuni-q-blog/./src/pages/tetris.tsx"],"sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\nimport styled from 'styled-components';\nconst Table = styled.table`\n  width: auto !important;\n  border-collapse: collapse !important;\n  td {\n    border: 1px solid black;\n    width: 30px;\n    height: 30px;\n    padding: 0;\n  }\n`;\n\nconst blocks = [\n  {\n    name: 's', // 네모\n    center: false,\n    numCode: 1,\n    color: 'red',\n    currentShapeIndex: 0,\n    shape: [\n      [\n        [0, 0, 0],\n        [0, 1, 1],\n        [0, 1, 1],\n      ],\n    ],\n  },\n  {\n    name: 't', // T자\n    center: true,\n    numCode: 2,\n    color: 'orange',\n    currentShapeIndex: 0,\n    shape: [\n      [\n        [0, 0, 0],\n        [1, 1, 1],\n        [0, 1, 0],\n      ],\n      [\n        [0, 1, 0],\n        [1, 1, 0],\n        [0, 1, 0],\n      ],\n      [\n        [0, 1, 0],\n        [1, 1, 1],\n        [0, 0, 0],\n      ],\n      [\n        [0, 1, 0],\n        [0, 1, 1],\n        [0, 1, 0],\n      ],\n    ],\n  },\n  {\n    name: 'z', // 지그재그\n    center: true,\n    numCode: 3,\n    color: 'yellow',\n    currentShapeIndex: 0,\n    shape: [\n      [\n        [0, 0, 0],\n        [1, 1, 0],\n        [0, 1, 1],\n      ],\n      [\n        [0, 1, 0],\n        [1, 1, 0],\n        [1, 0, 0],\n      ],\n      [\n        [1, 1, 0],\n        [0, 1, 1],\n        [0, 0, 0],\n      ],\n      [\n        [0, 0, 1],\n        [0, 1, 1],\n        [0, 1, 0],\n      ],\n    ],\n  },\n  {\n    name: 'zr', // 반대 지그재그\n    center: true,\n    numCode: 4,\n    color: 'green',\n    startRow: 1,\n    currentShapeIndex: 0,\n    shape: [\n      [\n        [0, 0, 0],\n        [0, 1, 1],\n        [1, 1, 0],\n      ],\n      [\n        [1, 0, 0],\n        [1, 1, 0],\n        [0, 1, 0],\n      ],\n      [\n        [0, 1, 1],\n        [1, 1, 0],\n        [0, 0, 0],\n      ],\n      [\n        [0, 1, 0],\n        [0, 1, 1],\n        [0, 0, 1],\n      ],\n    ],\n  },\n  {\n    name: 'l', // L자\n    center: true,\n    numCode: 5,\n    color: 'blue',\n    currentShapeIndex: 0,\n    shape: [\n      [\n        [0, 0, 0],\n        [1, 1, 1],\n        [1, 0, 0],\n      ],\n      [\n        [1, 1, 0],\n        [0, 1, 0],\n        [0, 1, 0],\n      ],\n      [\n        [0, 0, 1],\n        [1, 1, 1],\n        [0, 0, 0],\n      ],\n      [\n        [0, 1, 0],\n        [0, 1, 0],\n        [0, 1, 1],\n      ],\n    ],\n  },\n  {\n    name: 'lr', // 반대 L자\n    center: true,\n    numCode: 6,\n    color: 'navy',\n    currentShapeIndex: 0,\n    shape: [\n      [\n        [0, 0, 0],\n        [1, 1, 1],\n        [0, 0, 1],\n      ],\n      [\n        [0, 1, 0],\n        [0, 1, 0],\n        [1, 1, 0],\n      ],\n      [\n        [1, 0, 0],\n        [1, 1, 1],\n        [0, 0, 0],\n      ],\n      [\n        [0, 1, 1],\n        [0, 1, 0],\n        [0, 1, 0],\n      ],\n    ],\n  },\n  {\n    name: 'b', // 1자\n    center: true,\n    numCode: 7,\n    color: 'violet',\n    currentShapeIndex: 0,\n    shape: [\n      [\n        [0, 0, 0, 0],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 0, 0, 0],\n      ],\n      [\n        [0, 1, 0, 0],\n        [0, 1, 0, 0],\n        [0, 1, 0, 0],\n        [0, 1, 0, 0],\n      ],\n      [\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 0, 0, 0],\n        [0, 0, 0, 0],\n      ],\n      [\n        [0, 0, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 1, 0],\n      ],\n    ],\n  },\n];\n\nconst colors = ['red', 'orange', 'yellow', 'green', 'blue', 'navy', 'violet'];\n\nconst isActiveBlock = (value) => value > 0 && value < 10;\nconst isInvalidBlock = (value) => value === undefined || value >= 10;\n\nconst Tetris: React.VFC = () => {\n  const [tetrisData, setTetrisData] = useState(\n    Array(20)\n      .fill([])\n      .map((d) => Array(10).fill(0)),\n  );\n  const [nextTable, setNextTable] = useState(\n    Array(4)\n      .fill([])\n      .map((d) => Array(4).fill(0)),\n  );\n  const [score, setScore] = useState(0);\n  const currentBlock = useRef(null);\n  const nextBlock = useRef(null);\n  const stopDown = useRef(true);\n  const intervalId = useRef(null);\n  const currentTopLeft = useRef([0, 3]);\n  function generate() {\n    // 테트리스 블록 생성\n    if (!nextBlock.current) {\n      nextBlock.current = blocks[Math.floor(Math.random() * blocks.length)];\n    }\n    if (!currentBlock.current) {\n      currentBlock.current = blocks[Math.floor(Math.random() * blocks.length)];\n    } else {\n      currentBlock.current = nextBlock.current;\n      nextBlock.current = blocks[Math.floor(Math.random() * blocks.length)];\n    }\n    currentTopLeft.current = [-1, 3];\n    currentBlock.current.shape[0].slice(1).forEach((col, i) => {\n      // 게임 오버 판단\n      col.forEach((row, j) => {\n        if (row && tetrisData[i][j + 3]) {\n          clearInterval(intervalId.current);\n          alert('게임오버');\n        }\n      });\n    });\n    setTetrisData((tetrisData) => {\n      const newTetrisData = [...tetrisData.map((t) => [...t])];\n      if (currentBlock?.current?.shape) {\n        currentBlock.current.shape[0].slice(1).forEach((row, rowIndex) => {\n          row.forEach((cell, cellIndex) => {\n            newTetrisData[rowIndex][cellIndex + 3] = cell\n              ? currentBlock.current.numCode\n              : 0;\n          });\n        });\n      }\n      return newTetrisData;\n    });\n  }\n  const checkRows = (tetrisData) => {\n    // 한 줄 다 찼는지 검사\n    const fullRows = [];\n    tetrisData.forEach((col, i) => {\n      let count = 0;\n      col.forEach((row, _) => {\n        if (row > 0) {\n          count++;\n        }\n      });\n      if (count === 10) {\n        fullRows.push(i);\n      }\n    });\n    const fullRowsCount = fullRows.length;\n    tetrisData = tetrisData.filter((row, i) => !fullRows.includes(i));\n    for (let i = 0; i < fullRowsCount; i++) {\n      tetrisData.unshift([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n    }\n    setScore((score) => (score += fullRowsCount ** 2));\n    return tetrisData;\n  };\n\n  const tick = () => {\n    // 한 칸 아래로\n    setTetrisData((tetrisData) => {\n      const nextTopLeft = [\n        currentTopLeft.current[0] + 1,\n        currentTopLeft.current[1],\n      ];\n      let canGoDown = true;\n      const currentBlockShape =\n        currentBlock.current.shape[currentBlock.current.currentShapeIndex];\n      for (\n        let i = currentTopLeft.current[0];\n        i < currentTopLeft.current[0] + currentBlockShape.length;\n        i++\n      ) {\n        // 아래 블럭이 있으면\n        if (i < 0 || i >= 20) continue;\n        for (\n          let j = currentTopLeft.current[1];\n          j < currentTopLeft.current[1] + currentBlockShape.length;\n          j++\n        ) {\n          if (isActiveBlock(tetrisData[i][j])) {\n            // 현재 움직이는 블럭이면\n            if (isInvalidBlock(tetrisData[i + 1] && tetrisData[i + 1][j])) {\n              canGoDown = false;\n            }\n          }\n        }\n      }\n      if (!canGoDown) {\n        stopDown.current = true;\n      } else {\n        currentTopLeft.current = nextTopLeft;\n      }\n      const newTetrisData = [...tetrisData.map((t) => [...t])];\n      for (let i = newTetrisData.length - 1; i >= 0; i--) {\n        const col = tetrisData[i];\n        col.forEach((row, j) => {\n          if (\n            row > 0 &&\n            row < 10 &&\n            newTetrisData[i + 1]?.[j] < 10 &&\n            !!canGoDown\n          ) {\n            newTetrisData[i + 1][j] = row;\n            newTetrisData[i][j] = 0;\n          } else if (row !== 0 && row < 10) {\n            newTetrisData[i][j] = row * 10;\n          }\n        });\n      }\n      const returnTetrisData = checkRows(newTetrisData);\n      if (JSON.stringify(newTetrisData) !== JSON.stringify(tetrisData)) {\n        return returnTetrisData;\n      }\n      return tetrisData;\n    });\n  };\n  useEffect(() => {\n    setNextTable((nextTable) => {\n      return nextTable.map((row, rowIndex) => {\n        return row.map((_, cellIndex) => {\n          if (nextBlock?.current?.shape?.[0]?.[rowIndex]?.[cellIndex]) {\n            return nextBlock.current.shape[0][rowIndex][cellIndex]\n              ? nextBlock.current.numCode\n              : 0;\n          }\n          return 0;\n        });\n      });\n    });\n  }, [nextBlock.current]);\n\n  useEffect(() => {\n    const keyDownEvent = (event: KeyboardEvent) => {\n      setTetrisData((tetrisData) => {\n        switch (event.code) {\n          case 'ArrowLeft': {\n            // 키보드 왼쪽 클릭 = 좌측 한 칸 이동\n            const nextTopLeft = [\n              currentTopLeft.current[0],\n              currentTopLeft.current[1] - 1,\n            ];\n            let isMovable = true;\n            const currentBlockShape =\n              currentBlock.current.shape[\n                currentBlock.current.currentShapeIndex\n              ];\n            for (\n              let i = currentTopLeft.current[0];\n              i < currentTopLeft.current[0] + currentBlockShape.length;\n              i++\n            ) {\n              // 왼쪽 공간 체크\n              if (!isMovable) break;\n              for (\n                let j = currentTopLeft.current[1];\n                j < currentTopLeft.current[1] + currentBlockShape.length;\n                j++\n              ) {\n                if (!tetrisData[i] || !tetrisData[i][j]) continue;\n                if (\n                  isActiveBlock(tetrisData[i][j]) &&\n                  isInvalidBlock(tetrisData[i] && tetrisData[i][j - 1])\n                ) {\n                  isMovable = false;\n                }\n              }\n            }\n            if (isMovable) {\n              currentTopLeft.current = nextTopLeft;\n              tetrisData.forEach((col, i) => {\n                for (let j = 0; j < col.length; j++) {\n                  const row = col[j];\n                  if (tetrisData[i][j - 1] === 0 && row < 10) {\n                    tetrisData[i][j - 1] = row;\n                    tetrisData[i][j] = 0;\n                  }\n                }\n              });\n            }\n            break;\n          }\n          case 'ArrowRight': {\n            // 키보드 오른쪽 클릭 = 우측 한 칸 이동\n            const nextTopLeft = [\n              currentTopLeft.current[0],\n              currentTopLeft.current[1] + 1,\n            ];\n            let isMovable = true;\n            const currentBlockShape =\n              currentBlock.current.shape[\n                currentBlock.current.currentShapeIndex\n              ];\n            for (\n              let i = currentTopLeft.current[0];\n              i < currentTopLeft.current[0] + currentBlockShape.length;\n              i++\n            ) {\n              // 오른쪽 공간 체크\n              if (!isMovable) break;\n              for (\n                let j = currentTopLeft.current[1];\n                j < currentTopLeft.current[1] + currentBlockShape.length;\n                j++\n              ) {\n                if (!tetrisData[i] || !tetrisData[i][j]) continue;\n                if (\n                  isActiveBlock(tetrisData[i][j]) &&\n                  isInvalidBlock(tetrisData[i] && tetrisData[i][j + 1])\n                ) {\n                  isMovable = false;\n                }\n              }\n            }\n            if (isMovable) {\n              currentTopLeft.current = nextTopLeft;\n              tetrisData.forEach((col, i) => {\n                for (let j = col.length - 1; j >= 0; j--) {\n                  const row = col[j];\n                  if (tetrisData[i][j + 1] === 0 && row < 10) {\n                    tetrisData[i][j + 1] = row;\n                    tetrisData[i][j] = 0;\n                  }\n                }\n              });\n            }\n            break;\n          }\n          case 'ArrowDown': {\n            // 키보드 아래쪽 클릭 = 하방측 한 칸 이동\n            tick();\n          }\n        }\n        return tetrisData;\n      });\n    };\n    const keyupEvent = (event: KeyboardEvent) => {\n      switch (event.code) {\n        case 'Space':\n          while (!stopDown.current) {\n            tick();\n          }\n          break;\n        case 'ArrowUp': {\n          setTetrisData((tetrisData) => {\n            // 방향 전환\n            const currentBlockShape =\n              currentBlock.current.shape[\n                currentBlock.current.currentShapeIndex\n              ];\n            let isChangeable = true;\n            const nextShapeIndex =\n              currentBlock.current.currentShapeIndex + 1 ===\n              currentBlock.current.shape.length\n                ? 0\n                : currentBlock.current.currentShapeIndex + 1;\n            const nextBlockShape = currentBlock.current.shape[nextShapeIndex];\n            for (\n              let i = currentTopLeft.current[0];\n              i < currentTopLeft.current[0] + currentBlockShape.length;\n              i++\n            ) {\n              // 돌린 이후 공간 체크\n              if (!isChangeable) break;\n              for (\n                let j = currentTopLeft.current[1];\n                j < currentTopLeft.current[1] + currentBlockShape.length;\n                j++\n              ) {\n                if (!tetrisData[i]) continue;\n                if (\n                  nextBlockShape[i - currentTopLeft.current[0]][\n                    j - currentTopLeft.current[1]\n                  ] > 0 &&\n                  isInvalidBlock(tetrisData[i] && tetrisData[i][j])\n                ) {\n                  isChangeable = false;\n                }\n              }\n            }\n            if (isChangeable) {\n              while (currentTopLeft.current[0] < 0) {\n                tick();\n              }\n              for (\n                let i = currentTopLeft.current[0];\n                i < currentTopLeft.current[0] + currentBlockShape.length;\n                i++\n              ) {\n                // 돌린 이후 공간 체크\n                for (\n                  let j = currentTopLeft.current[1];\n                  j < currentTopLeft.current[1] + currentBlockShape.length;\n                  j++\n                ) {\n                  if (!tetrisData[i]) continue;\n                  const nextBlockShapeCell =\n                    nextBlockShape[i - currentTopLeft.current[0]][\n                      j - currentTopLeft.current[1]\n                    ];\n                  if (nextBlockShapeCell > 0 && tetrisData[i][j] === 0) {\n                    // 다음 모양은 있는데 현재 칸이 없으면\n                    tetrisData[i][j] = currentBlock.current.numCode;\n                  } else if (\n                    nextBlockShapeCell === 0 &&\n                    tetrisData[i][j] &&\n                    tetrisData[i][j] < 10\n                  ) {\n                    // 다음 모양은 없는데  현재 칸이 있으면\n                    tetrisData[i][j] = 0;\n                  }\n                }\n              }\n              currentBlock.current.currentShapeIndex = nextShapeIndex;\n            }\n            return tetrisData;\n          });\n\n          break;\n        }\n      }\n    };\n    window.addEventListener('keydown', keyDownEvent);\n    window.addEventListener('keyup', keyupEvent);\n    intervalId.current = setInterval(() => tick(), 300);\n    return () => {\n      clearInterval(intervalId.current);\n      window.removeEventListener('keydown', keyDownEvent);\n      window.removeEventListener('keyup', keyupEvent);\n    };\n  }, []);\n  useEffect(() => {\n    if (stopDown.current) {\n      stopDown.current = false;\n      generate();\n    }\n  }, [stopDown.current]);\n  return (\n    <>\n      <Table>\n        <tbody>\n          {tetrisData.map((tr, rowIndex) => {\n            return (\n              <tr key={`${tr}-${rowIndex}`}>\n                {tr.map((td, cellIndex) => {\n                  return (\n                    <td\n                      style={{\n                        backgroundColor:\n                          tetrisData[rowIndex][cellIndex] >= 10\n                            ? colors[tetrisData[rowIndex][cellIndex] / 10 - 1]\n                            : colors[tetrisData[rowIndex][cellIndex] - 1],\n                      }}\n                      key={`${td}-${cellIndex}`}\n                    >\n                      {td}\n                    </td>\n                  );\n                })}\n              </tr>\n            );\n          })}\n        </tbody>\n      </Table>\n      <Table>\n        <tbody>\n          {nextTable.map((tr, rowIndex) => {\n            return (\n              <tr key={`${tr}-${rowIndex}`}>\n                {tr.map((td, cellIndex) => {\n                  return (\n                    <td\n                      style={{\n                        backgroundColor:\n                          colors[nextTable[rowIndex][cellIndex] - 1],\n                      }}\n                      key={`${td}-${cellIndex}`}\n                    >\n                      {td}\n                    </td>\n                  );\n                })}\n              </tr>\n            );\n          })}\n        </tbody>\n      </Table>\n      <div>{score}</div>\n    </>\n  );\n};\n\nexport default Tetris;\n"],"names":["Table","styled","table","withConfig","displayName","componentId","blocks","name","center","numCode","color","currentShapeIndex","shape","startRow","colors","isActiveBlock","value","isInvalidBlock","undefined","Tetris","tetrisData","setTetrisData","useState","Array","fill","map","d","nextTable","setNextTable","score","setScore","currentBlock","useRef","nextBlock","stopDown","intervalId","currentTopLeft","tick","nextTopLeft","current","canGoDown","currentBlockShape","i","length","j","newTetrisData","_toConsumableArray","t","forEach","row","_newTetrisData","returnTetrisData","fullRows","col","count","_","push","fullRowsCount","filter","includes","unshift","checkRows","JSON","stringify","useEffect","rowIndex","cellIndex","_nextBlock$current","_nextBlock$current$sh","_nextBlock$current$sh2","_nextBlock$current$sh3","keyDownEvent","event","code","isMovable","keyupEvent","isChangeable","nextShapeIndex","nextBlockShape","nextBlockShapeCell","window","addEventListener","setInterval","clearInterval","removeEventListener","Math","floor","random","slice","alert","_currentBlock$current","cell","React","tr","key","td","style","backgroundColor"],"sourceRoot":""}