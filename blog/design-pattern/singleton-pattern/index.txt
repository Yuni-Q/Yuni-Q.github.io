3:I[808,[],""]
5:I[6217,[],""]
6:I[5217,["3185","static/chunks/app/layout-3ad8bb7cb2292578.js"],"ServiceWorkerCleanup"]
7:I[6484,["3185","static/chunks/app/layout-3ad8bb7cb2292578.js"],"ThemeProvider"]
4:["slug","design-pattern/singleton-pattern","c"]
0:["static-build-id",[[["",{"children":["blog",{"children":[["slug","design-pattern/singleton-pattern","c"],{"children":["__PAGE__?{\"slug\":[\"design-pattern\",\"singleton-pattern\"]}",{}]}]}]},"$undefined","$undefined",true],["",{"children":["blog",{"children":[["slug","design-pattern/singleton-pattern","c"],{"children":["__PAGE__",{},[["$L1","$L2",null],null],null]},[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","blog","children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","blog","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/bc8bb31cb71603b2.css","precedence":"next","crossOrigin":"$undefined"}]],["$","html",null,{"lang":"ko","children":[["$","head",null,{"children":[["$","link",null,{"rel":"preconnect","href":"https://fonts.googleapis.com"}],["$","link",null,{"rel":"preconnect","href":"https://fonts.gstatic.com","crossOrigin":"anonymous"}],["$","link",null,{"href":"https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap","rel":"stylesheet"}],["$","link",null,{"href":"https://fonts.googleapis.com/css2?family=Catamaran:wght@800&display=swap","rel":"stylesheet"}],["$","link",null,{"rel":"icon","type":"image/png","href":"/favicon2.png"}],["$","link",null,{"rel":"shortcut icon","href":"/favicon2.png"}],["$","link",null,{"rel":"apple-touch-icon","href":"/favicon2.png"}],["$","script",null,{"id":"ads","async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"}],["$","script",null,{"dangerouslySetInnerHTML":{"__html":"(adsbygoogle=window.adsbygoogle||[]).requestNonPersonalizedAds=1;"}}]]}],["$","body",null,{"children":[["$","noscript",null,{"children":"You need to enable JavaScript to run this app."}],["$","$L6",null,{}],["$","$L7",null,{"children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[]}]}]]}]]}]],null],null],["$L8",null]]]]
9:I[5553,["9243","static/chunks/9243-972bdccd4ceb11ae.js","5800","static/chunks/5800-4312aed1aa8a4305.js","549","static/chunks/549-2babc012700e23ed.js","4853","static/chunks/4853-73ca7990eb89674b.js","6797","static/chunks/app/blog/%5B...slug%5D/page-9b274a2e0073d544.js"],"BlogPostPageClient"]
a:T2924,
## 생성 패턴

- 디자인 패턴 분류인 생성, 구조, 행위 중 객체 생성에 관련 된 `생성 패턴`으로 간주됩니다.
- 생성 패턴은 객체의 생성과 조합을 캡슐화해 특정 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 유연성을 제공합니다.

## 단 `하나`의 인스턴스를 생성해 사용하는 디자인 패턴(`유일한` 객체를 생성하는 방법)

- 애플리케이션이 시작될 때 어떤 클래스가 `최초 한번만` 메모리를 할당하고(static) 그 메모리에 인스턴스를 만들어 사용하는 디자인패턴입니다.
  - 전역 변수를 사용하지 않고 `객체를 하나만 생성` 하도록 하며, 생성된 객체를 `어디에서든지 참조`할 수 있습니다.
  - 생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 `하나`고 최초 생성 이후에 호출된 생성자는 `최초에 생성한 객체를 반환`합니다.
- 유일한 인스턴스가 서브클래싱으로 확장되어야 하며, 사용자는 코드의 수정없이 확장된 서브클래스의 인스턴스를 사용할 수 있어야 할 때 사용합니다.
- 클래스에서 자신의 단 하나뿐인 인스턴스를 관리하도록 만들면 만듭니다. 그리고 다른 어떤 클래스에서도 자신의 인스턴스를 추가로 만들지 못하도록 해야 합니다. 인스턴스가 필요하면 반드시 클래스 자신을 거치도록 해야 합니다.

## 장점

- 고정된 메모리 영역을 얻으면서 한번의 new로 인스턴스를 사용하기 때문에 `메모리 낭비를 방지` 할 수 있습니다.
  - 두 번째 이용시부터는 객체 로딩 시간이 현저하게 줄어 성능이 좋아지는 장점이 있습니다.
- 싱글톤으로 만들어진 클래스의 인스턴스는 전역 인스턴스이기 때문에 다른 클래스의 인스턴스들이 `데이터를 공유`하기 쉽습니다.
- 인스턴스가 절대적으로 한개만 존재하는 것을 보증하기에 개발 시 실수를 줄일 수 있습니다.
- 싱글톤 객체를 사용하지 않는 경우 인스턴스를 생성하지 않을 수 있습니다.
- 싱글톤을 상속시킬 수 있습니다.

### 전역 변수의 단점

- 전역 변수에 객체를 대입하면 애플리케이션이 시작될 때 객체가 생성될 것입니다. 그런데 그 객체가 자원을 많이 차지하고 애플리케이션이 끝날 때까지 그 객체를 한 번도 쓰지 않는다면 괜히 자원만 잡아먹는, 아무 데도 쓸 데 없는 객체가 되고 맙니다. 싱글턴 패턴을 쓰면 필요할 때만 객체를 만들 수가 있습니다.
  - 사실 플랫폼에 따라 달라질 수 있습니다. 어떤 JVM에서는 나중에 필요할 때 생성하기도 합니다.

## 단점

- 싱글톤의 역할이 커질수록 결합도가 높아져 객체 지향 설계 원칙에 어긋날 수 있다.
  - 싱글톤 객체가 변경되면 이를 참조하고 있는 모든 값들이 변경됩니다.
  - 수정이 어려워지고 테스트하기 어려워집니다. 싱글톤 인스턴스가 너무 많은 일을 하거나 많은 데이터를 공유시킬 경우 다른 클래스의 인스턴스들 간에 결합도가 높아져 `개방-폐쇄 원칙` 을 위배하게 됩니다.
- 멀티쓰레드환경에서 동기화 처리를 하지 않으면 인스턴스가 두개가 생성되는 문제가 발생할 수 있습니다.
  - 경합 조건 문제가 발생 할 수 있습니다. `경합 조건`이란 메모리와 같은 동일한 자원을 2개 이상의 스레드가 이용하려고 경합하는 현상입니다.
  - 다중 스레드 애플리케이션에서 발생하는 문제를 해결하는 방법은 정적 변수에 인스턴스를 만들어 바로 초기화하는 방법 (Eager Initialization)과 인스턴스를 만드는 메서드에 동기화하는 방법 (Thread-Safe Initialization)이 있습니다.
- 전역변수보다 사용하기가 불편합니다.
- 객체의 파괴 시점을 컨트롤하기 어려울 수 있습니다.

## 활용처

- 인스턴스가 오직 1개만 생성되야 하는 경우 사용합니다.
- DBCP(DataBase Connection Pool)처럼 공통된 객체를 여러개 생성해서 사용해야하는 상황에서 많이 사용합니다.
  - 쓰레드풀, 캐시, 대화상자, 사용자 설정, 레지스트리 설정, 로그 기록 객체 등
- 안드로이드 앱 같은 경우 각 액티비티나 클래스별로 주요 클래스들을 일일이 전달하기가 번거롭기 때문에 싱글톤 클래스를 만들어 어디서나 접근하도록 설계하는 것이 편합니다.
- 인스턴스가 절대적으로 한개만 존재하는 것을 보증하고 싶을 경우 사용합니다.
- 레지스트리 같은 설정 파일의 경우 객체가 여러개 생성되면 설정 값이 변경될 위험이 생길 수 있기 때문에 사용하면 좋습니다.

## 주의할 점

- 책임의 불균형이 심화되고 있는 상태에서 객체의 생성 책임을 지우는 것은 설계를 하부의 특정한 메커니즘에 종속적으로 만들 확률이 높습니다. 불필요한 SINGLETON 패턴을 객체 생성에 관해 너무 이른 시기에 고민하고 결정할 때 도입되는 경향이 있습니다. 핵심은`객체를 생성하는 방법에 대한 결정은 모든 책임이 자리를 잡은 후 가장 마지막 시점에 내리는 것이 적절하다는 것`입니다.

## 정적 메서드로만 이루어진 정적 클래스를 사용하면 싱글턴과 동일한 효과를 얻을 수 있습니다.

- 정적 클래스를 이용하면 객체를 전혀 생성하지 않고 메서드를 사용합니다.
- 정적 메서드를 사용하므로 일반적으로 실행할 때 바인딩되는(컴파일 타임에 바인딩되는) 인스턴스 메서드를 사용하는 것보다 성능 면에서 우수합니다.

### 정적 클래스를 사용할 수 없는 경우

- 인터페이스를 구현해야 하는 경우, 정적 메서드는 인터페이스에서 사용할 수 없습니다.
- 인터페이스를 사용하는 주된 이유는 대체 구현이 필요한 경우입니다.
  - Mock 객체를 사용해 단위 테스트를 수행하는 경우입니다.

## 예제

- 싱글턴 패턴의 공통적인 특징은 `private constructor`를 가진다는 것과, `static method`를 사용한다는 점입니다.
  - private 생성자
  - static 변수로 객체 생성
  - 객체의 getter 구현

```ts
class Printer {
  // 외부에 제공할 자기 자신의 인스턴스
  private static printer: Printer = null;
  private constructor() {
    console.log('Printer constructor');
  }
  // 자기 자신의 인스턴스를 외부에 제공
  public static getPrinter(): Printer {
    if (this.printer == null) {
      // Printer 인스턴스 생성
      this.printer = new Printer();
    }
    return this.printer;
  }
  public print(str: string) {
    console.log(str);
  }
}

class User {
  private name: string;
  public constructor(name: string) {
    this.name = name;
  }
  public print() {
    const printer = Printer.getPrinter();
    printer.print(this.name + ' print using ');
  }
}
const USER_NUM = 5;
const user = [];
for (let i = 0; i < USER_NUM; i++) {
  // User 인스턴스 생성
  user[i] = new User((i + 1).toString());
  user[i].print();
}
```

### Eager Initialization(이른 초기화, Thread-safe)

- 이른 초기화 방식은 클래스 로더에 의해 클래스가 최초로 로딩 될 때 객체가 생성되기때문에 Thread-safe 합니다.

```ts
class Printer {
  // static 변수에 외부에 제공할 자기 자신의 인스턴스를 만들어 초기화
  private static printer: Printer = new Printer();
  private constructor() {
    console.log('constructor');
  }
  // 자기 자신의 인스턴스를 외부에 제공
  public static getPrinter(): Printer {
    return this.printer;
  }
  public print(str: string) {
    console.log(str);
  }
}
```

## 언어별 구현

- 파이썬의 모듈은 그 자체로 싱글턴입니다.
- 자바는 생성자를 private으로 선언하여 상속이 불가능함을 지정하기도 합니다.

## 다른 패턴과의 관계

- Factory pattern : Factory class를 Singleton으로 구현해도 되고, 서브클래스를 리턴하는 static 메소드로 구현해도 됩니다.
- Flyweight pattern : FlyweightFactory를 Singleton으로 구현하는 경우가 있습니다.
- 추상 팩토리 패턴, 빌더 패턴, 프로토타입 패턴은 각 구현에 있어서 싱글턴 패턴을 활용할 수 있습니다.
- 멀티턴 패턴이라는 static 변수가 배열로서 구성된 싱클턴의 확장 패턴도 존재합니다. flyweight pattern과의 차이점은 생성자가 private라는 차이점이 있습니다.

## 베이지, 다이나믹, 피닉스, 템플릿 싱글톤 등이 있다고 합니다.

- https://vallista.tistory.com/entry/1-Singleton-Pattern-in-C

### 피닉스 싱글턴(phoenix singleton)이란 무엇인가?

- 피닉스 싱글톤은 싱글톤 참조시 해당 객체의 소멸여부를 판단하고 소멸되었다면 다시 되살리게 됩니다.
- 마이어스 싱글턴(singleton)의 한계를 극복하는 싱글턴입니다.
- C++에서 사용됩니다.

#### 어떻게 피닉스 싱글턴(phoenix singleton)을 구현하는가?

- 마이어스 싱글턴을 기반하기 때문에, static 지역 변수를 기반으로 구현된 싱글턴입니다. 이 static 지역 변수의 특징은 여러개 있지만, 그 중 메모리 해제 시점 관점에서 본다면, 다음과 같다.
  - 메모리의 생성은 프로그램이 해당 지역변수를 구동 코드를 읽을 때 합니다.
    프로그램 종료시점에 메모리 파괴가 일어 난다 해도, 그 공간은 빈 공간으로 남아 있습니다. (즉, 다른것으로 채워지지 않는다) 이러한 특징 때문에, 프로그램 종료 시점에 그 메모리 공간에 다시 쓰기 위해 위치지정(또는 재배치)를 사용하며, 파괴 시점을 제어합니다.

### 수명제어 싱글톤

---

## 참고

- [\[Design Pattern\] 싱글턴 패턴이란](https://gmlwjd9405.github.io/2018/07/06/singleton-pattern.html)
- [기본기를 쌓는 정아마추어 코딩블로그](https://jeong-pro.tistory.com/86)
- [싱글턴 패턴](https://ko.wikipedia.org/wiki/%EC%8B%B1%EA%B8%80%ED%84%B4_%ED%8C%A8%ED%84%B4)
- [\[Design Pattern\] 싱글톤 패턴(Singleton Pattern)에 대하여](https://coding-factory.tistory.com/709)
b:T5f54,<h2 id="생성-패턴">생성 패턴<a aria-hidden="true" tabindex="-1" href="#생성-패턴"><span class="anchor"></span></a></h2>
<ul>
<li>디자인 패턴 분류인 생성, 구조, 행위 중 객체 생성에 관련 된 <code class="inline-code">생성 패턴</code>으로 간주됩니다.</li>
<li>생성 패턴은 객체의 생성과 조합을 캡슐화해 특정 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 유연성을 제공합니다.</li>
</ul>
<h2 id="단-하나의-인스턴스를-생성해-사용하는-디자인-패턴유일한-객체를-생성하는-방법">단 <code class="inline-code">하나</code>의 인스턴스를 생성해 사용하는 디자인 패턴(<code class="inline-code">유일한</code> 객체를 생성하는 방법)<a aria-hidden="true" tabindex="-1" href="#단-하나의-인스턴스를-생성해-사용하는-디자인-패턴유일한-객체를-생성하는-방법"><span class="anchor"></span></a></h2>
<ul>
<li>애플리케이션이 시작될 때 어떤 클래스가 <code class="inline-code">최초 한번만</code> 메모리를 할당하고(static) 그 메모리에 인스턴스를 만들어 사용하는 디자인패턴입니다.
<ul>
<li>전역 변수를 사용하지 않고 <code class="inline-code">객체를 하나만 생성</code> 하도록 하며, 생성된 객체를 <code class="inline-code">어디에서든지 참조</code>할 수 있습니다.</li>
<li>생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 <code class="inline-code">하나</code>고 최초 생성 이후에 호출된 생성자는 <code class="inline-code">최초에 생성한 객체를 반환</code>합니다.</li>
</ul>
</li>
<li>유일한 인스턴스가 서브클래싱으로 확장되어야 하며, 사용자는 코드의 수정없이 확장된 서브클래스의 인스턴스를 사용할 수 있어야 할 때 사용합니다.</li>
<li>클래스에서 자신의 단 하나뿐인 인스턴스를 관리하도록 만들면 만듭니다. 그리고 다른 어떤 클래스에서도 자신의 인스턴스를 추가로 만들지 못하도록 해야 합니다. 인스턴스가 필요하면 반드시 클래스 자신을 거치도록 해야 합니다.</li>
</ul>
<h2 id="장점">장점<a aria-hidden="true" tabindex="-1" href="#장점"><span class="anchor"></span></a></h2>
<ul>
<li>고정된 메모리 영역을 얻으면서 한번의 new로 인스턴스를 사용하기 때문에 <code class="inline-code">메모리 낭비를 방지</code> 할 수 있습니다.
<ul>
<li>두 번째 이용시부터는 객체 로딩 시간이 현저하게 줄어 성능이 좋아지는 장점이 있습니다.</li>
</ul>
</li>
<li>싱글톤으로 만들어진 클래스의 인스턴스는 전역 인스턴스이기 때문에 다른 클래스의 인스턴스들이 <code class="inline-code">데이터를 공유</code>하기 쉽습니다.</li>
<li>인스턴스가 절대적으로 한개만 존재하는 것을 보증하기에 개발 시 실수를 줄일 수 있습니다.</li>
<li>싱글톤 객체를 사용하지 않는 경우 인스턴스를 생성하지 않을 수 있습니다.</li>
<li>싱글톤을 상속시킬 수 있습니다.</li>
</ul>
<h3 id="전역-변수의-단점">전역 변수의 단점<a aria-hidden="true" tabindex="-1" href="#전역-변수의-단점"><span class="anchor"></span></a></h3>
<ul>
<li>전역 변수에 객체를 대입하면 애플리케이션이 시작될 때 객체가 생성될 것입니다. 그런데 그 객체가 자원을 많이 차지하고 애플리케이션이 끝날 때까지 그 객체를 한 번도 쓰지 않는다면 괜히 자원만 잡아먹는, 아무 데도 쓸 데 없는 객체가 되고 맙니다. 싱글턴 패턴을 쓰면 필요할 때만 객체를 만들 수가 있습니다.
<ul>
<li>사실 플랫폼에 따라 달라질 수 있습니다. 어떤 JVM에서는 나중에 필요할 때 생성하기도 합니다.</li>
</ul>
</li>
</ul>
<h2 id="단점">단점<a aria-hidden="true" tabindex="-1" href="#단점"><span class="anchor"></span></a></h2>
<ul>
<li>싱글톤의 역할이 커질수록 결합도가 높아져 객체 지향 설계 원칙에 어긋날 수 있다.
<ul>
<li>싱글톤 객체가 변경되면 이를 참조하고 있는 모든 값들이 변경됩니다.</li>
<li>수정이 어려워지고 테스트하기 어려워집니다. 싱글톤 인스턴스가 너무 많은 일을 하거나 많은 데이터를 공유시킬 경우 다른 클래스의 인스턴스들 간에 결합도가 높아져 <code class="inline-code">개방-폐쇄 원칙</code> 을 위배하게 됩니다.</li>
</ul>
</li>
<li>멀티쓰레드환경에서 동기화 처리를 하지 않으면 인스턴스가 두개가 생성되는 문제가 발생할 수 있습니다.
<ul>
<li>경합 조건 문제가 발생 할 수 있습니다. <code class="inline-code">경합 조건</code>이란 메모리와 같은 동일한 자원을 2개 이상의 스레드가 이용하려고 경합하는 현상입니다.</li>
<li>다중 스레드 애플리케이션에서 발생하는 문제를 해결하는 방법은 정적 변수에 인스턴스를 만들어 바로 초기화하는 방법 (Eager Initialization)과 인스턴스를 만드는 메서드에 동기화하는 방법 (Thread-Safe Initialization)이 있습니다.</li>
</ul>
</li>
<li>전역변수보다 사용하기가 불편합니다.</li>
<li>객체의 파괴 시점을 컨트롤하기 어려울 수 있습니다.</li>
</ul>
<h2 id="활용처">활용처<a aria-hidden="true" tabindex="-1" href="#활용처"><span class="anchor"></span></a></h2>
<ul>
<li>인스턴스가 오직 1개만 생성되야 하는 경우 사용합니다.</li>
<li>DBCP(DataBase Connection Pool)처럼 공통된 객체를 여러개 생성해서 사용해야하는 상황에서 많이 사용합니다.
<ul>
<li>쓰레드풀, 캐시, 대화상자, 사용자 설정, 레지스트리 설정, 로그 기록 객체 등</li>
</ul>
</li>
<li>안드로이드 앱 같은 경우 각 액티비티나 클래스별로 주요 클래스들을 일일이 전달하기가 번거롭기 때문에 싱글톤 클래스를 만들어 어디서나 접근하도록 설계하는 것이 편합니다.</li>
<li>인스턴스가 절대적으로 한개만 존재하는 것을 보증하고 싶을 경우 사용합니다.</li>
<li>레지스트리 같은 설정 파일의 경우 객체가 여러개 생성되면 설정 값이 변경될 위험이 생길 수 있기 때문에 사용하면 좋습니다.</li>
</ul>
<h2 id="주의할-점">주의할 점<a aria-hidden="true" tabindex="-1" href="#주의할-점"><span class="anchor"></span></a></h2>
<ul>
<li>책임의 불균형이 심화되고 있는 상태에서 객체의 생성 책임을 지우는 것은 설계를 하부의 특정한 메커니즘에 종속적으로 만들 확률이 높습니다. 불필요한 SINGLETON 패턴을 객체 생성에 관해 너무 이른 시기에 고민하고 결정할 때 도입되는 경향이 있습니다. 핵심은<code class="inline-code">객체를 생성하는 방법에 대한 결정은 모든 책임이 자리를 잡은 후 가장 마지막 시점에 내리는 것이 적절하다는 것</code>입니다.</li>
</ul>
<h2 id="정적-메서드로만-이루어진-정적-클래스를-사용하면-싱글턴과-동일한-효과를-얻을-수-있습니다">정적 메서드로만 이루어진 정적 클래스를 사용하면 싱글턴과 동일한 효과를 얻을 수 있습니다.<a aria-hidden="true" tabindex="-1" href="#정적-메서드로만-이루어진-정적-클래스를-사용하면-싱글턴과-동일한-효과를-얻을-수-있습니다"><span class="anchor"></span></a></h2>
<ul>
<li>정적 클래스를 이용하면 객체를 전혀 생성하지 않고 메서드를 사용합니다.</li>
<li>정적 메서드를 사용하므로 일반적으로 실행할 때 바인딩되는(컴파일 타임에 바인딩되는) 인스턴스 메서드를 사용하는 것보다 성능 면에서 우수합니다.</li>
</ul>
<h3 id="정적-클래스를-사용할-수-없는-경우">정적 클래스를 사용할 수 없는 경우<a aria-hidden="true" tabindex="-1" href="#정적-클래스를-사용할-수-없는-경우"><span class="anchor"></span></a></h3>
<ul>
<li>인터페이스를 구현해야 하는 경우, 정적 메서드는 인터페이스에서 사용할 수 없습니다.</li>
<li>인터페이스를 사용하는 주된 이유는 대체 구현이 필요한 경우입니다.
<ul>
<li>Mock 객체를 사용해 단위 테스트를 수행하는 경우입니다.</li>
</ul>
</li>
</ul>
<h2 id="예제">예제<a aria-hidden="true" tabindex="-1" href="#예제"><span class="anchor"></span></a></h2>
<ul>
<li>싱글턴 패턴의 공통적인 특징은 <code class="inline-code">private constructor</code>를 가진다는 것과, <code class="inline-code">static method</code>를 사용한다는 점입니다.
<ul>
<li>private 생성자</li>
<li>static 변수로 객체 생성</li>
<li>객체의 getter 구현</li>
</ul>
</li>
</ul>
<pre class="language-ts optimized-code-block" style="max-height: 600px; overflow-y: auto;"><code class="language-ts code-highlight"><span class="code-line"><span class="token keyword">class</span> <span class="token class-name">Printer</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token comment">// 외부에 제공할 자기 자신의 인스턴스</span>
</span><span class="code-line">  <span class="token keyword">private</span> <span class="token keyword">static</span> printer<span class="token operator">:</span> Printer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">private</span> <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Printer constructor'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">  <span class="token comment">// 자기 자신의 인스턴스를 외부에 제공</span>
</span><span class="code-line">  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token function">getPrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Printer <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>printer <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">      <span class="token comment">// Printer 인스턴스 생성</span>
</span><span class="code-line">      <span class="token keyword">this</span><span class="token punctuation">.</span>printer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line">    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>printer<span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">  <span class="token keyword">public</span> <span class="token function">print</span><span class="token punctuation">(</span>str<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">private</span> name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">public</span> <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">  <span class="token keyword">public</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">const</span> printer <span class="token operator">=</span> Printer<span class="token punctuation">.</span><span class="token function">getPrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    printer<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">' print using '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line"><span class="token keyword">const</span> <span class="token constant">USER_NUM</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&#x3C;</span> <span class="token constant">USER_NUM</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token comment">// User 인스턴스 생성</span>
</span><span class="code-line">  user<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  user<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<h3 id="eager-initialization이른-초기화-thread-safe">Eager Initialization(이른 초기화, Thread-safe)<a aria-hidden="true" tabindex="-1" href="#eager-initialization이른-초기화-thread-safe"><span class="anchor"></span></a></h3>
<ul>
<li>이른 초기화 방식은 클래스 로더에 의해 클래스가 최초로 로딩 될 때 객체가 생성되기때문에 Thread-safe 합니다.</li>
</ul>
<pre class="language-ts optimized-code-block" style="max-height: 600px; overflow-y: auto;"><code class="language-ts code-highlight"><span class="code-line"><span class="token keyword">class</span> <span class="token class-name">Printer</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token comment">// static 변수에 외부에 제공할 자기 자신의 인스턴스를 만들어 초기화</span>
</span><span class="code-line">  <span class="token keyword">private</span> <span class="token keyword">static</span> printer<span class="token operator">:</span> Printer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">private</span> <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'constructor'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">  <span class="token comment">// 자기 자신의 인스턴스를 외부에 제공</span>
</span><span class="code-line">  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token function">getPrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Printer <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>printer<span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">  <span class="token keyword">public</span> <span class="token function">print</span><span class="token punctuation">(</span>str<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<h2 id="언어별-구현">언어별 구현<a aria-hidden="true" tabindex="-1" href="#언어별-구현"><span class="anchor"></span></a></h2>
<ul>
<li>파이썬의 모듈은 그 자체로 싱글턴입니다.</li>
<li>자바는 생성자를 private으로 선언하여 상속이 불가능함을 지정하기도 합니다.</li>
</ul>
<h2 id="다른-패턴과의-관계">다른 패턴과의 관계<a aria-hidden="true" tabindex="-1" href="#다른-패턴과의-관계"><span class="anchor"></span></a></h2>
<ul>
<li>Factory pattern : Factory class를 Singleton으로 구현해도 되고, 서브클래스를 리턴하는 static 메소드로 구현해도 됩니다.</li>
<li>Flyweight pattern : FlyweightFactory를 Singleton으로 구현하는 경우가 있습니다.</li>
<li>추상 팩토리 패턴, 빌더 패턴, 프로토타입 패턴은 각 구현에 있어서 싱글턴 패턴을 활용할 수 있습니다.</li>
<li>멀티턴 패턴이라는 static 변수가 배열로서 구성된 싱클턴의 확장 패턴도 존재합니다. flyweight pattern과의 차이점은 생성자가 private라는 차이점이 있습니다.</li>
</ul>
<h2 id="베이지-다이나믹-피닉스-템플릿-싱글톤-등이-있다고-합니다">베이지, 다이나믹, 피닉스, 템플릿 싱글톤 등이 있다고 합니다.<a aria-hidden="true" tabindex="-1" href="#베이지-다이나믹-피닉스-템플릿-싱글톤-등이-있다고-합니다"><span class="anchor"></span></a></h2>
<ul>
<li><a href="https://vallista.tistory.com/entry/1-Singleton-Pattern-in-C">https://vallista.tistory.com/entry/1-Singleton-Pattern-in-C</a></li>
</ul>
<h3 id="피닉스-싱글턴phoenix-singleton이란-무엇인가">피닉스 싱글턴(phoenix singleton)이란 무엇인가?<a aria-hidden="true" tabindex="-1" href="#피닉스-싱글턴phoenix-singleton이란-무엇인가"><span class="anchor"></span></a></h3>
<ul>
<li>피닉스 싱글톤은 싱글톤 참조시 해당 객체의 소멸여부를 판단하고 소멸되었다면 다시 되살리게 됩니다.</li>
<li>마이어스 싱글턴(singleton)의 한계를 극복하는 싱글턴입니다.</li>
<li>C++에서 사용됩니다.</li>
</ul>
<h4 id="어떻게-피닉스-싱글턴phoenix-singleton을-구현하는가">어떻게 피닉스 싱글턴(phoenix singleton)을 구현하는가?<a aria-hidden="true" tabindex="-1" href="#어떻게-피닉스-싱글턴phoenix-singleton을-구현하는가"><span class="anchor"></span></a></h4>
<ul>
<li>마이어스 싱글턴을 기반하기 때문에, static 지역 변수를 기반으로 구현된 싱글턴입니다. 이 static 지역 변수의 특징은 여러개 있지만, 그 중 메모리 해제 시점 관점에서 본다면, 다음과 같다.
<ul>
<li>메모리의 생성은 프로그램이 해당 지역변수를 구동 코드를 읽을 때 합니다.
프로그램 종료시점에 메모리 파괴가 일어 난다 해도, 그 공간은 빈 공간으로 남아 있습니다. (즉, 다른것으로 채워지지 않는다) 이러한 특징 때문에, 프로그램 종료 시점에 그 메모리 공간에 다시 쓰기 위해 위치지정(또는 재배치)를 사용하며, 파괴 시점을 제어합니다.</li>
</ul>
</li>
</ul>
<h3 id="수명제어-싱글톤">수명제어 싱글톤<a aria-hidden="true" tabindex="-1" href="#수명제어-싱글톤"><span class="anchor"></span></a></h3>
<hr>
<h2 id="참고">참고<a aria-hidden="true" tabindex="-1" href="#참고"><span class="anchor"></span></a></h2>
<ul>
<li><a href="https://gmlwjd9405.github.io/2018/07/06/singleton-pattern.html">[Design Pattern] 싱글턴 패턴이란</a></li>
<li><a href="https://jeong-pro.tistory.com/86">기본기를 쌓는 정아마추어 코딩블로그</a></li>
<li><a href="https://ko.wikipedia.org/wiki/%EC%8B%B1%EA%B8%80%ED%84%B4_%ED%8C%A8%ED%84%B4">싱글턴 패턴</a></li>
<li><a href="https://coding-factory.tistory.com/709">[Design Pattern] 싱글톤 패턴(Singleton Pattern)에 대하여</a></li>
</ul>2:["$","$L9",null,{"post":{"slug":"/design-pattern/singleton-pattern","frontmatter":{"title":"singleton pattern","date":"2021-04-14T21:05:29.000Z","category":"design pattern","tags":["design pattern"],"draft":false},"content":"$a","html":"$b","excerpt":"## 생성 패턴  - 디자인 패턴 분류인 생성, 구조, 행위 중 객체 생성에 관련 된 `생성 패턴`으로 간주됩니다. - 생성 패턴은 객체의 생성과 조합을 캡슐화해 특정 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 유연성을 제공합니다.  ## 단 `하나`의 인스턴스를 생성해 사용하는 디자인 패턴(`유일한` 객체를 생성하는 방법)"},"previousPost":{"slug":"/design-pattern/state-pattern","frontmatter":{"title":"state pattern","date":"2021-03-21T13:03:24.000Z","category":"design pattern","tags":["design pattern"],"draft":false}},"nextPost":{"slug":"/design-pattern/dependency-injection-pattern","frontmatter":{"title":"dependency injection pattern","date":"2021-04-15T10:05:33.000Z","category":"design pattern","tags":["design pattern"],"draft":false}}}]
8:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"singleton pattern"}],["$","meta","3",{"name":"description","content":"## 생성 패턴  - 디자인 패턴 분류인 생성, 구조, 행위 중 객체 생성에 관련 된 `생성 패턴`으로 간주됩니다. - 생성 패턴은 객체의 생성과 조합을 캡슐화해 특정 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 유연성을 제공합니다.  ## 단 `하나`의 인스턴스를 생성해 사용하는 디자인 패턴(`유일한` 객체를 생성하는 방법)"}]]
1:null
