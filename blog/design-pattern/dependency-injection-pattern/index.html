<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" as="image" href="https://www.buymeacoffee.com/assets/img/BMC-btn-logo.svg"/><link rel="preload" as="image" href="/images/profile.png"/><link rel="stylesheet" href="/_next/static/css/bc8bb31cb71603b2.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-57fdca2934e5ae0a.js"/><script src="/_next/static/chunks/6217bb07-738e49d824771fea.js" async=""></script><script src="/_next/static/chunks/5647-b33901b11da845dc.js" async=""></script><script src="/_next/static/chunks/main-app-ec1611f00934714e.js" async=""></script><script src="/_next/static/chunks/app/layout-3ad8bb7cb2292578.js" async=""></script><script src="/_next/static/chunks/9243-972bdccd4ceb11ae.js" async=""></script><script src="/_next/static/chunks/5800-4312aed1aa8a4305.js" async=""></script><script src="/_next/static/chunks/549-2babc012700e23ed.js" async=""></script><script src="/_next/static/chunks/4853-73ca7990eb89674b.js" async=""></script><script src="/_next/static/chunks/app/blog/%5B...slug%5D/page-9b274a2e0073d544.js" async=""></script><script id="ads" async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><title>dependency injection pattern</title><meta name="description" content="## Object Dependencies(객체 의존성)  - 현재 객체가 다른 객체와 상호작용(참조)하고 있다면 현재 객체는 다른 객체에 의존성을 가집니다. - 하나의 모듈이 바뀌면 의존한 다른 모듈까지 변경 되어야 합니다. 또한 두 객체 사이의 의존성이 존재하면 Unit Test 작성이 어려워집니다. - `의존성`은 서비스로 사용할 수 있는 객체입니다."/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"/><link rel="icon" type="image/png" href="/favicon2.png"/><link rel="shortcut icon" href="/favicon2.png"/><link rel="apple-touch-icon" href="/favicon2.png"/><link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&amp;display=swap" rel="stylesheet"/><link href="https://fonts.googleapis.com/css2?family=Catamaran:wght@800&amp;display=swap" rel="stylesheet"/><script>(adsbygoogle=window.adsbygoogle||[]).requestNonPersonalizedAds=1;</script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body><noscript>You need to enable JavaScript to run this app.</noscript><div class="top-header"><a class="top-link" href="/">Yuni-Q</a><div class="flex items-center"><button class="outline-0 bg-white mx-[5px] p-0 appearance-none items-center rounded-[5px] border-0 cursor-pointer inline-flex h-10 justify-center opacity-75 overflow-hidden relative scale-75 transition-opacity duration-300 ease-in-out w-10 flex-shrink-0 hover:bg-black max-[800px]:hover:bg-white"><a href="https://github.com/Yuni-Q/blog" class="github" aria-label="GitHub"><svg class="github transition-all duration-300 ease-in-out pt-1 text-[#78757a] w-8 hover:text-white max-[800px]:hover:text-[#78757a]" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg></a></button><button class="outline-0 bg-white mx-[5px] p-0 appearance-none items-center rounded-[5px] border-0 cursor-pointer inline-flex h-10 justify-center opacity-75 overflow-hidden relative scale-75 transition-opacity duration-300 ease-in-out w-10 flex-shrink-0 hover:bg-black max-[800px]:hover:bg-white group"><div class="theme1 rounded-full h-6 relative w-6 transition-all duration-[450ms] ease-in-out bg-[#78757a]" style="border:none;overflow:visible;transform:scale(0.55)"><div class="absolute rounded-full h-6 w-6 transition-transform duration-[450ms] ease-in-out" style="border:none;opacity:0;right:-9px;top:-9px;transform:translate(14px, -14px);background:#78757a"></div><div class="absolute rounded-full h-2 w-2 left-1/2 top-1/2 transition-all duration-[350ms] ease-in-out" style="box-shadow:0 -23px 0 #78757a, 0 23px 0 #78757a, 23px 0 0 #78757a, -23px 0 0 #78757a, 15px 15px 0 #78757a, -15px 15px 0 #78757a, 15px -15px 0 #78757a, -15px -15px 0 #78757a;transform:scale(1);margin:-4px 0px 0px -4px"></div></div><div class="theme2 rounded-full border-0 h-6 absolute right-0 top-0 w-6 transition-all duration-[450ms] ease-in-out" style="background:none;opacity:0;transform:translate(14px, -14px)"></div></button><button class="outline-0 bg-white mx-[5px] p-0 appearance-none items-center rounded-[5px] border-0 cursor-pointer inline-flex h-10 justify-center opacity-75 overflow-hidden relative scale-75 transition-opacity duration-300 ease-in-out w-10 flex-shrink-0 hover:bg-black max-[800px]:hover:bg-white group"><svg class="snow transition-all duration-300 ease-in-out w-7 group-hover:fill-white max-[800px]:group-hover:fill-[#78757a]" style="fill:#78757a" version="1.1" id="레이어_1" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 0 23.9 22.9"><path d="M23.9,10c0-0.3-0.2-0.5-0.4-0.6l-1.1-0.3C22.1,9.1,22,9,21.9,8.8c-0.1-0.2,0-0.4,0.1-0.6l0.8-0.9       c0.2-0.2,0.2-0.5,0-0.7c-1.2-1.4-3.1-2-5-1.4c-0.4,0.1-0.9,0.4-1.4,0.7c0.1-0.6,0.2-1.1,0.2-1.6c0-1.9-1.2-3.6-2.9-4.3       c-0.2-0.1-0.5,0-0.7,0.2l-0.6,1c-0.1,0.2-0.3,0.3-0.5,0.3c-0.2,0-0.4-0.1-0.5-0.3l-0.6-1C10.7,0,10.4-0.1,10.2,0       C8.5,0.7,7.3,2.4,7.3,4.3c0,0.5,0.1,1,0.2,1.6C7,5.6,6.5,5.4,6.1,5.2c-1.8-0.6-3.8,0-5,1.4c-0.2,0.2-0.2,0.5,0,0.7l0.8,0.9       C2,8.4,2.1,8.6,2,8.8c0,0.2-0.2,0.3-0.4,0.4L0.4,9.5C0.2,9.5,0,9.8,0,10c0.1,1.8,1.4,3.5,3.2,4c0.4,0.1,1,0.2,1.5,0.3       c-0.4,0.4-0.8,0.8-1.1,1.1c-1.1,1.6-1.2,3.6-0.2,5.2c0.1,0.2,0.4,0.3,0.7,0.2l1.1-0.4c0.2-0.1,0.4-0.1,0.6,0C6,20.6,6,20.8,6,21.1       l-0.1,1.2c0,0.3,0.2,0.5,0.4,0.6c1.8,0.4,3.7-0.2,4.8-1.8c0.3-0.4,0.5-0.8,0.8-1.4c0.2,0.5,0.5,1,0.8,1.4c1.1,1.6,3.1,2.2,4.8,1.8       c0.3-0.1,0.4-0.3,0.4-0.6l-0.1-1.2c0-0.3,0.1-0.4,0.2-0.5c0.1-0.1,0.3-0.1,0.6,0l1.1,0.4c0.2,0.1,0.5,0,0.7-0.2       c1-1.6,0.9-3.6-0.2-5.2c-0.3-0.4-0.6-0.8-1.1-1.1c0.6-0.1,1.1-0.2,1.5-0.3C22.6,13.5,23.8,11.8,23.9,10z M14.1,12.8       c0.3-0.2,0.7-0.3,1.1-0.1c0.4,0.3,0.6,0.8,0.3,1.3c-0.3,0.4-0.8,0.6-1.3,0.3c-0.3-0.2-0.5-0.6-0.4-1l-1.4-0.8v1.6       c0.4,0.1,0.6,0.5,0.6,0.9c0,0.5-0.4,0.9-0.9,0.9c-0.5,0-0.9-0.4-0.9-0.9c0-0.4,0.3-0.7,0.6-0.9v-1.6l-1.4,0.8c0.1,0.4-0.1,0.8-0.4,1       c-0.4,0.3-1,0.1-1.3-0.3c-0.3-0.4-0.1-1,0.3-1.3c0.3-0.2,0.8-0.1,1.1,0.1l1.4-0.8L10,11.1c-0.3,0.2-0.7,0.3-1.1,0.1       C8.5,11,8.3,10.4,8.6,10c0.3-0.4,0.8-0.6,1.3-0.3c0.3,0.2,0.5,0.6,0.4,1l1.4,0.8V9.8c-0.4-0.1-0.6-0.5-0.6-0.9C11.1,8.4,11.5,8,12,8       c0.5,0,0.9,0.4,0.9,0.9c0,0.4-0.3,0.7-0.6,0.9v1.6l1.4-0.8c-0.1-0.4,0.1-0.8,0.4-1c0.4-0.3,1-0.1,1.3,0.3c0.3,0.4,0.1,1-0.3,1.3       c-0.3,0.2-0.8,0.1-1.1-0.1l-1.4,0.8L14.1,12.8z"></path></svg></button><a class="w-[30px] h-[30px] leading-[30px] mx-[5px] text-black flex-shrink-0 flex items-center justify-center" href="/search/">검색</a></div></div><div class="layout-content" style="margin-right:0;max-width:none"><div class="mb-6 max-w-4xl mx-auto px-4 xl:pr-[220px]"><ins class="adsbygoogle block min-w-[320px] min-h-0 mx-auto bg-gray-300" data-ad-client="ca-pub-2667251850399676" data-ad-slot="9586629994" data-ad-format="auto" data-full-width-responsive="true"></ins></div><div class="relative"><div class="max-w-4xl mx-auto px-4 xl:pr-[220px]"><h1 class="text-4xl md:text-5xl font-extrabold mb-6 leading-tight text-gray-900 dark:text-gray-100">dependency injection pattern</h1><div class="flex flex-col gap-4 mb-8"><div class="flex items-center gap-2 text-gray-600 dark:text-gray-400"><span class="text-sm font-medium">yuni-q</span><span class="text-gray-400 dark:text-gray-500">·</span><span class="text-sm">2021년 4월 15일</span></div><div class="flex flex-wrap gap-2"><span class="px-3 py-1.5 text-sm rounded-md bg-green-50 dark:bg-green-900/20 text-gray-700 dark:text-gray-300 hover:bg-green-100 dark:hover:bg-green-900/30 transition-colors cursor-pointer">design pattern</span></div></div><div class="jsx-4115489982 post-content prose prose-lg max-w-none  prose-headings:font-semibold prose-p:leading-relaxed prose-a:text-blue-600 dark:prose-a:text-blue-400 prose-a:no-underline hover:prose-a:underline prose-strong:font-semibold prose-code:font-mono prose-code:text-sm prose-code:px-1 prose-code:py-0.5 prose-code:rounded prose-pre:bg-gray-900 dark:prose-pre:bg-gray-800 prose-blockquote:border-l-4 prose-blockquote:pl-4 prose-blockquote:italic prose-blockquote:my-6 prose-img:rounded-lg prose-img:shadow-md prose-table:w-full prose-ul:list-disc prose-ol:list-decimal prose-li:my-1"><h2 id="object-dependencies객체-의존성">Object Dependencies(객체 의존성)<a aria-hidden="true" tabindex="-1" href="#object-dependencies객체-의존성"><span class="anchor"></span></a></h2>
<ul>
<li>현재 객체가 다른 객체와 상호작용(참조)하고 있다면 현재 객체는 다른 객체에 의존성을 가집니다.</li>
<li>하나의 모듈이 바뀌면 의존한 다른 모듈까지 변경 되어야 합니다. 또한 두 객체 사이의 의존성이 존재하면 Unit Test 작성이 어려워집니다.</li>
<li><code class="inline-code">의존성</code>은 서비스로 사용할 수 있는 객체입니다.</li>
</ul>
<h2 id="dependency-injection의존성-주입">Dependency Injection(의존성 주입)<a aria-hidden="true" tabindex="-1" href="#dependency-injection의존성-주입"><span class="anchor"></span></a></h2>
<ul>
<li>의존성 주입은 <code class="inline-code">역 제어(Inversion of Control, IOC) 테크닉의 한 형태</code>로 어떤 서비스를 호출하려는 컴포넌트는 그 서비스가 어떻게 구성되었는지 알지 못해야 합니다.</li>
<li>클라이언트가 어떤 서비스를 사용할 것인지 지정하는 대신, 클라이언트에게 무슨 서비스를 사용할 것인지를 말(주입)해주는 것이다.
<ul>
<li><code class="inline-code">주입</code>은 의존성(서비스)을 사용하려는 객체(클라이언트)로 전달하는 것을 의미합니다. 서비스는 클라이언트 상태의 일부입니다. 클라이언트가 서비스를 구축하거나 찾는 것을 허용하는 대신 클라이언트에게 서비스를 전달하는 것이 패턴의 기본 요건입니다.</li>
</ul>
</li>
<li>클래스 간의 의존관계가 있을 때 <code class="inline-code">컴파일 타임의 의존관계를 제거</code>하고 <code class="inline-code">런타임 의존관계</code>로 만들어 주고 <code class="inline-code">결합도(coupling)을 낮춰주는 것</code>이 Dependency Injection입니다.</li>
<li>컴포넌트는 서비스 제공에 대한 책임을 <code class="inline-code">외부 코드(Injector)에게 위임</code>하고 Injector는 이미 존재하거나 Injector에 의해 생성된 서비스를 컴포넌트에게 주입하고 컴포넌트는 서비스를 사용합니다. 이는 <code class="inline-code">컴포넌트가 Injector와 서비스에 대해 알 필요가 없음</code>을 의미합니다. 컴포넌트는 서비스의 인터페이스에 대해서만 알면 되고 이는 <code class="inline-code">구성의 책임으로부터 사용의 책임을 구분</code>합니다.</li>
<li>Dependency Injection은 프로그램의 디자인이 <code class="inline-code">느슨하게 커플링</code>되도록 하고, <code class="inline-code">의존관계 역전 원칙(Dependency Inversion Principle)</code>과 <code class="inline-code">단일 책임 원칙(single responsibility principles)</code>을 따르도록 클라이언트의 생성에 대한 의존성을 클라이언트의 행위로부터 분리하는 것입니다. 이는 클라이언트가 의존성을 찾기 위해 그들이 사용하는 시스템에 대해 알도록 하는 서비스 로케이터 패턴(service locator pattern)과 정반대되는 것입니다.</li>
<li>의존성 주입은 컴포지션을 통해 IoC를 구현하므로 종종 전략 패턴과 동일하지만, 전략 패턴의 의도는 객체의 수명동안 의존성을 교환할 수 있도록 하는 것이고, 의존성 주입에서는 단일 의존성 인스턴스만 사용할 수 있도록 하는 것입니다.
<ul>
<li>싱글턴과 전략패턴과 연관이 있어 보입니다.</li>
</ul>
</li>
</ul>
<h3 id="숨겨진-의존성은-나쁘다">숨겨진 의존성은 나쁘다<a aria-hidden="true" tabindex="-1" href="#숨겨진-의존성은-나쁘다"><span class="anchor"></span></a></h3>
<ul>
<li>의존성 주입 외에도 의존성을 해결할 수 있는 다양한 방법이 존재합니다. 가장 널리 사용되는 대표적인 방법은 <code class="inline-code">SERVICE LOCATOR</code> 패턴입니다.
<ul>
<li>서비스 로케이터의 기본 아이디어는 각각 서비스별(ServiceClass) 서로 결합도를 낮추고, 어플리케이션이 필요로 하는 모든 서비스들을 포함하고 있는 객체를 갖는 것이니다. 즉, 서비스(의존성)를 찾아주는(=locate) 녀석을 전역에 만들어놓고 사용하여, 의존성을 관리합니다. DI 와 다르게, 의존성을 찾아 씁니다.</li>
</ul>
</li>
<li><code class="inline-code">SERVICE LOCATOR</code>는 의존성을 해결할 객체들을 보관하는 일종의 저장소입니다. 외부에서 객체에게 의존성을 전달하는 의존성 주입과 달리 <code class="inline-code">SERVICE LOCATOR</code>의 경우 객체가 직접 <code class="inline-code">SERVICE LOCATOR</code>에게 의존성을 해결해줄 것을 요청합니다. SERVICE LOCATOR 패턴은 서비스를 사용하는 코드로부터 서비스가 누구인지(서비스를 구현한 구체 클래스의 타입이 무엇인지), 어디에 있는지(클래스 인스턴스를 어떻게 얻을지)를 몰라도 되게 해줍니다. <code class="inline-code">SERVICE LOCATOR</code> 패턴의 가장 큰 단점은 의존성을 감춥니다.</li>
<li>의존성을 구현 내부로 감출 경우 의존성과 관련된 문제가 <code class="inline-code">컴파일타임이 아닌 런타임에 가서야 발견된다는 사실을 알 수 있습니다</code>.</li>
<li>숨겨진 의존성은 의존성의 대상을 설정하는 시점과 의존성이 해결되는 시점을 멀리 떨어뜨려 놓습니다. 이것은 코드를 이해하고 디버깅 하기 어렵게 만듭니다.</li>
<li>핵심은 <code class="inline-code">명시적인 의존성이 숨겨진 의존성보다 좋다</code>는 것입니다. 가급적 <code class="inline-code">의존성을 객체의 퍼블릭 인터페이스에 노출</code>합니다. 의존성을 구현 내부에 숨기면 숨길수록 코드를 이해하기도, 수정하기도 어려워집니다.</li>
<li>어쩔수 없이 SERVICE LOCATOR 패턴을 사용해야 하는 경우도 있습니다. 의존성 주입을 지원하는 프레임워크를 사용하지 못하는 경우나 깊은 호출 계층에 걸쳐 동일한 객체를 계속해서 전달해야 하는 고통을 견디기 어려운 경우에는 어쩔수 없이 SERVICE LOCATOR 패턴을 사용하는 것을 고려합니다.</li>
<li>가능하다면 의존성을 명시적으로 표현할 수 있는 기법을 사용합니다.
<ul>
<li><code class="inline-code">의존성 주입은 의존성을 명시적으로 명시할 수 있는 방법 중 하나</code>일 뿐입니다.</li>
<li>요점은 <code class="inline-code">명시적인 의존성</code>에 초점을 맞추는 것입니다.</li>
<li>이 방법이 유연성을 향상시키는 가장 효과적인 방법입니다.</li>
</ul>
</li>
</ul>
<h3 id="srpsingle-responsibility-principle-단일-책임-원칙">SRP(Single Responsibility Principle, 단일 책임 원칙)<a aria-hidden="true" tabindex="-1" href="#srpsingle-responsibility-principle-단일-책임-원칙"><span class="anchor"></span></a></h3>
<ul>
<li>소프트웨어의 설계 부품은 단 하나의 책임만을 가져야 합니다.</li>
<li>즉 소프트웨어를 수정할 이유가 오직 하나여야 합니다.</li>
</ul>
<h3 id="dipdependency-inversion-principle-의존관계-역전-원칙">DIP(Dependency Inversion Principle, 의존관계 역전 원칙)<a aria-hidden="true" tabindex="-1" href="#dipdependency-inversion-principle-의존관계-역전-원칙"><span class="anchor"></span></a></h3>
<ul>
<li>첫 번째, 상위 모듈은 하위 모듈에 의존해서는 안 됩니다. 둘 다 <code class="inline-code">추상화</code>에 의존해야 합니다.</li>
<li>두 번째, 추상화는 <code class="inline-code">세부사항에 의존하지 않습니다</code>. 세부사항이 추상화에 의존하여 달라져야 합니다.</li>
<li>의존 관계를 맺을 때, 변화하기 쉬운 것보단 변화하기 어려운 것에 의존해야 합니다.
<ul>
<li>이때 변화하기 쉬운 것이란 구체적인 것을 말하고, 변화하기 어려운 것이란 추상적인 것을 말합니다.</li>
<li>객체지향 관점에서 변화하기 쉬운 것이란 구체화된 클래스를 말하고, 변화하기 어려운 것이란 인터페이스를 의미합니다.</li>
</ul>
</li>
<li>DIP를 만족한다는 것은 의존관계를 맺을 때, 상위 모듈(클라이언트 클래스)는 하위 모듈(서비스 클래스)이 되는 구체적인 클래스보다 인터페이스나 추상 클래스와 관계를 맺는다는 것을 의미합니다.</li>
<li>DIP를 만족하면 Dependency Injection 패턴을 적용해서 변화에 유연한 설계를 할 수 있습니다.</li>
<li>이 원칙은 <code class="inline-code">상위와 하위 객체 모두가 동일한 추상화에 의존해야 한다</code>는 객체 지향적 설계의 대원칙을 제공합니다.</li>
<li>DI는 <code class="inline-code">DIP를 구현하는 기법중 하나라</code>고 생각 할 수 있습니다.
<ul>
<li>DI는 의존성을 어떻게 가질 것인가? DIP는 실체에 의존할 것인가, 추상화에 의존할 것인가의 문제라고 생각됩니다.</li>
</ul>
</li>
</ul>
<h4 id="의존성-역전-원칙과-패키지">의존성 역전 원칙과 패키지<a aria-hidden="true" tabindex="-1" href="#의존성-역전-원칙과-패키지"><span class="anchor"></span></a></h4>
<ul>
<li>역전은 의존성의 방향뿐만 아니라 인터페이스의 소유권에도 적용됩니다. 객체지향 프로그래밍 언어에서 어떤 구성 요소의 소유권을 결정하는 것은 모듈입니다.</li>
<li><code class="inline-code">SEPARATED INTERFACE 패턴</code>
<ul>
<li>추상화를 별도의 독립적인 패키지가 아니라 클라이언트가 속한 패키지에 포함시켜야 합니다.</li>
<li>함께 재사용될 필요가 없는 클래스들은 별도의 독립적인 패키지에 모아야 합니다.</li>
</ul>
</li>
<li>의존성 역전 원칙에 따라 상위 수준의 협력 흐름을 재사용하기 위해서는 추상화가 제공하는 인터페이스의 소유권 역시 역전시켜야 합니다.</li>
<li>훌륭한 객체지향 설계를 위해서는 의존성을 역전시켜야 합니다. 그리고 의존성을 역전시켜야만 유연하고 재사용 가능한 설계를 얻을 수 있습니다.</li>
</ul>
<h3 id="ioc제어의-역전">IoC(제어의 역전)<a aria-hidden="true" tabindex="-1" href="#ioc제어의-역전"><span class="anchor"></span></a></h3>
<ul>
<li>역제어(IoC)는 DI보다 더 일반적입니다.</li>
<li>객체 자체가 아니라 <code class="inline-code">Framework에 의해 객체의 의존성이 주입되는 설계 패턴</code>입니다. Framework에 의해 동적으로 주입되므로 여러 객체 간의 결합이 줄어듭니다.</li>
<li>IoC는 호출을 요구하는 대신 다른 코드가 호출할 수 있게 함을 의미합니다.</li>
<li>제어 반전, 제어의 반전, 역제어는 프로그래머가 작성한 프로그램이 재사용 라이브러리의 흐름 제어를 받게 되는 소프트웨어 디자인 패턴을 말합니다. 줄여서 IoC(Inversion of Control)이라고 부릅니다. 전통적인 프로그래밍에서 흐름은 프로그래머가 작성한 프로그램이 외부 라이브러리의 코드를 호출해 이용합니다. 하지만 제어 반전이 적용된 구조에서는 외부 라이브러리의 코드가 프로그래머가 작성한 코드를 호출합니다. 설계 목적상 제어 반전의 목적은 다음과 같습니다.
<ul>
<li>작업을 구현하는 방식과 작업 수행 자체를 분리합니다.</li>
<li>모듈을 제작할 때, 모듈과 외부 프로그램의 결합에 대해 고민할 필요 없이 모듈의 목적에 집중할 수 있습니다.</li>
<li>다른 시스템이 어떻게 동작할지에 대해 고민할 필요 없이, 미리 정해진 협약대로만 동작하게 하면 됩니다.</li>
<li>모듈을 바꾸어도 다른 시스템에 부작용을 일으키지 않습니다.</li>
</ul>
</li>
<li>이 관계에서 제어가 역전되었다고 표현하는데 같은 맥락에서 <code class="inline-code">팩토리 메소드</code>와 <code class="inline-code">템플리 메소드 패턴</code> 역시 IoC를 설명하는 예 중 하나입니다.</li>
<li>IoC는 제어의 역전에 관한 소프트웨어 용어로 <code class="inline-code">누가 작업을 수행하느냐</code>가 포인트입니다.</li>
</ul>
<h2 id="의존성-주입은-다음과-같은-문제를-해결합니다">의존성 주입은 다음과 같은 문제를 해결합니다.<a aria-hidden="true" tabindex="-1" href="#의존성-주입은-다음과-같은-문제를-해결합니다"><span class="anchor"></span></a></h2>
<ul>
<li>어떻게 애플리케이션이나 클래스가 객체의 생성 방식과 독립적일 수 있는가?</li>
<li>어떻게 객체의 생성 방식을 분리된 구성 파일에서 지정할 수 있는가?</li>
<li>어떻게 애플리케이션이 다른 구성을 지원할 수 있는가?</li>
</ul>
<h2 id="의존성-주입은-네-가지-역할을-포함한다">의존성 주입은 네 가지 역할을 포함한다.<a aria-hidden="true" tabindex="-1" href="#의존성-주입은-네-가지-역할을-포함한다"><span class="anchor"></span></a></h2>
<ul>
<li>사용될 서비스 객체</li>
<li>사용하는 서비스에 의존하는 클라이언트 객체</li>
<li>클라이언트의 서비스 사용 방법을 정의하는 인터페이스</li>
<li>서비스를 생성하고 클라이언트로 주입하는 책임을 갖는 주입자</li>
</ul>
<h2 id="의존성-주입-방법">의존성 주입 방법<a aria-hidden="true" tabindex="-1" href="#의존성-주입-방법"><span class="anchor"></span></a></h2>
<ul>
<li>생성자 주입 : 필요한 의존성을 모두 포함하는 클래스의 생성자를 만들고 그 생성자를 통해 의존성을 주입합니다.</li>
<li>세터(Setter)를 통한 주입 : 의존성을 입력받는 세터(Setter) 메소드를 만들고 이를 통해 의존성을 주입합니다.</li>
<li>인터페이스(Interface)를 통한 주입 : 의존성을 주입하는 함수를 포함한 인터페이스를 작성하고 이 인터페이스를 구현하도록 함으로써 실행시에 이를 통하여 의존성을 주입합니다.</li>
</ul>
<h3 id="생성자-주입constructor-injection">생성자 주입(constructor injection)<a aria-hidden="true" tabindex="-1" href="#생성자-주입constructor-injection"><span class="anchor"></span></a></h3>
<ul>
<li>객체를 생성하는 시점에 생성자를 통한 의존성을 해결하는 방법입니다.</li>
</ul>
<h3 id="setter-주입setter-injection">setter 주입(setter injection)<a aria-hidden="true" tabindex="-1" href="#setter-주입setter-injection"><span class="anchor"></span></a></h3>
<ul>
<li>객체 생성 후 setter 메서드를 통한 의존성을 해결하는 방법입니다.</li>
<li>setter 주입의 장점은 의존성의 대상을 <code class="inline-code">런타임에 변경</code>할 수 있다는 것입니다.
<ul>
<li>생성자 주입을 통해 설정된 인스턴스는 객체의 생명주기 전체에 걸쳐 관계를 유지하는 반면, setter 주입은 언제라도 의존 대상을 교체할 수 있습니다.</li>
</ul>
</li>
<li>setter 주입의 단점은 객체가 올바로 생성되기 위해 어떤 의존성이 <code class="inline-code">필수적인지를 명시적으로 표현할 수 없다</code>는 것입니다.
<ul>
<li>setter 메서드는 객체가 생성된 후에 호출돼야 하기 때문에 setter 메서드 호출을 누락한다면 객체는 비정상적인 상태로 생성될 것입니다.</li>
</ul>
</li>
</ul>
<h3 id="인터페이스-주입interface-injection">인터페이스 주입(interface injection)<a aria-hidden="true" tabindex="-1" href="#인터페이스-주입interface-injection"><span class="anchor"></span></a></h3>
<ul>
<li>인터페이스 주입의 기본 개념은 주입할 의존성을 명시하기 위해 인터페이스를 사용하는 것입니다.
<ul>
<li>인터페이스 주입은 근본적으로 setter 주입이나 프로퍼티 주입과 동일합니다. 단지 <code class="inline-code">어떤 대상을 어떻게 주입할 것인지를 인터페이스를 통해 명시적으로 선언</code>한다는 차이만 있을 뿐입니다. 인터페이스 주입은 의존성 주입이 도입되던 초창기에 자바 진영에서 만들어진 몇몇 프레임워크에서 의존성 대상을 좀 더 명시적으로 정의하고 편하게 관리하기 위해 도입한 방법입니다. 따라서 약간의 구현적인 관점을 덜어내고 의존성 주입이 가지는 목적과 용도라는 본질적인 측면에서 바라보면 인퍼테이스 <code class="inline-code">주입은 setter 주입과 프로퍼티 주입의 변형</code>으로 볼 수 있습니다.</li>
</ul>
</li>
</ul>
<h3 id="메서드-주입method-injection">메서드 주입(method injection)<a aria-hidden="true" tabindex="-1" href="#메서드-주입method-injection"><span class="anchor"></span></a></h3>
<ul>
<li>메서드 실행 시 인자를 이용한 의존성을 해결하는 방법입니다.</li>
<li>메서드 주입은 <code class="inline-code">메서드 호출 주입(method call injection)</code>이라고도 부르며 메서드가 의존성을 필요로 하는 유일한 경우일 때 사용할 수 있습니다.</li>
<li>생성자 주입을 통해 의존성을 전달받으면 객체가 올바른 상태로 생성되는 데 필요한 의존성을 명확하게 표현할 수 있다는 장점이 있지만 주입된 의존성이 한 두개의 메서드에서만 사용된다면 각 메서드의 인자로 전달하는 것이 더 나은 방법일 수 있습니다.</li>
<li>메서드 주입을 의존성 주입의 한 종류로 볼 것인가에 대해서는 논란의 여지가 있습니다.</li>
</ul>
<h2 id="장점">장점<a aria-hidden="true" tabindex="-1" href="#장점"><span class="anchor"></span></a></h2>
<ul>
<li>의존성 주입의 의도는 객체의 <code class="inline-code">생성과 사용의 관심을 분리</code>하는 것이다.</li>
<li>코드의 재사용성 증가 및 코드 단순화
<ul>
<li>만약 특정 객체를 여러 클라이언트에서 의존한다면 각 클라이언트가 특정 객체를 모두 구현할 필요없이 서비스가 이를 한 번만 구현하여 여러 클라이언트에게 의존성을 주입해주어 효율적입니다.</li>
</ul>
</li>
<li>리펙토링의 과정 수월
<ul>
<li>특정 객체에 의존성이 존재하는 클라이언트와 특정 객체를 필요로하는 클라이언트에게 간접적으로 의존성을 주입하는 서비스의 모듈이 체계적으로 분리되어 리펙토링 과정에서 조금 더 수월합니다.</li>
</ul>
</li>
<li>보일러 코드 감소
<ul>
<li>특정 객체를 필요로하는 클라이언트가 직접적으로 그 객체를 구현하지 않고 주입 받는 형식으로 이루어지기 때문에 필요할 때만 데이터를 전달받아 보일러 코드와 같이 메모리 누수 현상을 막을 수 있습니다.</li>
</ul>
</li>
<li>프로그램 테스트 용이
<ul>
<li>프로그램 내의 각 모듈들이 체계적으로 분리되어 Unit Test를 보다 더 쉽게 진행할 수 있습니다.</li>
</ul>
</li>
</ul>
<h2 id="비지터-패턴과는-조금의-차이가-있다고-합니다">비지터 패턴과는 조금의 차이가 있다고 합니다.<a aria-hidden="true" tabindex="-1" href="#비지터-패턴과는-조금의-차이가-있다고-합니다"><span class="anchor"></span></a></h2>
<h2 id="참고">참고<a aria-hidden="true" tabindex="-1" href="#참고"><span class="anchor"></span></a></h2>
<ul>
<li><a href="https://gmlwjd9405.github.io/2018/11/09/dependency-injection.html">[Design Pattern] DI란 (Dependency Injection)</a></li>
<li><a href="https://iamsjy17.github.io/design%20pattern/2020/05/30/designpattern_dependency_injection.html">[Design Pattern] Dependency Injection</a></li>
<li><a href="https://ko.wikipedia.org/wiki/%EC%9D%98%EC%A1%B4%EC%84%B1_%EC%A3%BC%EC%9E%85">의존성 주입</a></li>
<li><a href="https://juyeop.tistory.com/26">Dependency Injection 디자인 패턴</a></li>
<li><a href="https://black-jin0427.tistory.com/194">[디자인패턴] IoC, DI, DIP 용어 정리</a></li>
</ul></div></div></div><div class="flex flex-col gap-5 my-10 max-w-4xl mx-auto px-4 xl:pr-[220px]"><div class="sponsor-button"><a class="flex items-center justify-center gap-3 px-6 py-3.5 bg-gradient-to-r from-amber-400 via-amber-500 to-amber-600 hover:from-amber-500 hover:via-amber-600 hover:to-amber-700 active:from-amber-600 active:via-amber-700 active:to-amber-800 text-white rounded-2xl transition-all duration-300 cursor-pointer border-0 shadow-lg hover:shadow-xl hover:scale-[1.02] active:scale-[0.98] font-semibold text-base no-underline" target="_blank" rel="noopener noreferrer" href="https://www.buymeacoffee.com/yuniq"><img src="https://www.buymeacoffee.com/assets/img/BMC-btn-logo.svg" alt="Buy me a coffee" class="w-7 h-7 flex-shrink-0"/><span>Buy me a coffee</span></a></div></div><div class="max-w-4xl mx-auto px-4 xl:pr-[220px]"><ins class="kakao_ad_area block" data-ad-unit="DAN-kkYIHzVbuDz3kYsq" data-ad-width="320" data-ad-height="50" style="width:320px;height:50px"></ins></div><div class="max-w-4xl mx-auto px-4 xl:pr-[220px]"><hr class="custom-hr"/></div><div class="my-8 max-w-4xl mx-auto px-4 xl:pr-[220px]"><div class="bio-container"><div class="author-description flex"><img class="bio-author-image" src="/images/profile.png" alt="yuni-q" width="72"/><div><span class="author-name-prefix text-[90%] mr-1">Written by</span><a class="author-name-content" href="/about/"><span>@<!-- -->yuni-q</span></a><div class="author-introduction mt-1 text-[80%] leading-[1.4]">yuni-q&#x27;s graffiti.</div><p class="author-socials mt-[-4px]"><a href="https://github.com/Yuni-Q" class="mr-2 text-[80%]">GitHub</a></p></div></div></div></div><div class="max-w-4xl mx-auto px-4 xl:pr-[220px]"><nav class="navigator my-8"><ul class="flex flex-col gap-4"><li><a rel="prev" class="block p-4 rounded-xl border border-gray-200 dark:border-gray-700 hover:border-blue-400 dark:hover:border-blue-500 hover:bg-blue-50 dark:hover:bg-blue-900/20 transition-all duration-200 group" href="/design-pattern/singleton-pattern/"><div class="text-xs text-gray-500 dark:text-gray-400 mb-1 group-hover:text-blue-600 dark:group-hover:text-blue-400 transition-colors">이전 글</div><div class="text-sm font-medium text-gray-900 dark:text-gray-100 group-hover:text-blue-600 dark:group-hover:text-blue-400 transition-colors">← <!-- -->singleton pattern</div></a></li><li><a rel="next" class="block p-4 rounded-xl border border-gray-200 dark:border-gray-700 hover:border-blue-400 dark:hover:border-blue-500 hover:bg-blue-50 dark:hover:bg-blue-900/20 transition-all duration-200 group text-right" href="/javascript/javascript-call-by-reference가-존재하는가/"><div class="text-xs text-gray-500 dark:text-gray-400 mb-1 group-hover:text-blue-600 dark:group-hover:text-blue-400 transition-colors">다음 글</div><div class="text-sm font-medium text-gray-900 dark:text-gray-100 group-hover:text-blue-600 dark:group-hover:text-blue-400 transition-colors">javascript call by reference가 존재하는가<!-- --> →</div></a></li></ul></nav></div><div class="max-w-4xl mx-auto px-4 xl:pr-[220px]"><div class="utterences"></div></div><footer class="pt-[52px] text-center text-xs">©<a href="https://github.com/Yuni-Q" class="no-underline">yuni-q</a>, Built with<!-- --> <a href="https://nextjs.org" class="no-underline">Next.js</a></footer></div><script src="/_next/static/chunks/webpack-57fdca2934e5ae0a.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/bc8bb31cb71603b2.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[1633,[],\"\"]\n5:I[808,[],\"\"]\n7:I[6217,[],\"\"]\n8:I[5217,[\"3185\",\"static/chunks/app/layout-3ad8bb7cb2292578.js\"],\"ServiceWorkerCleanup\"]\n9:I[6484,[\"3185\",\"static/chunks/app/layout-3ad8bb7cb2292578.js\"],\"ThemeProvider\"]\nb:I[7768,[],\"\"]\n6:[\"slug\",\"design-pattern/dependency-injection-pattern\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[\"$\",\"$L2\",null,{\"buildId\":\"static-build-id\",\"assetPrefix\":\"\",\"urlParts\":[\"\",\"blog\",\"design-pattern\",\"dependency-injection-pattern\",\"\"],\"initialTree\":[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"design-pattern/dependency-injection-pattern\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"design-pattern\\\",\\\"dependency-injection-pattern\\\"]}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"design-pattern/dependency-injection-pattern\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\",null],null],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/bc8bb31cb71603b2.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"ko\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"preconnect\",\"href\":\"https://fonts.googleapis.com\"}],[\"$\",\"link\",null,{\"rel\":\"preconnect\",\"href\":\"https://fonts.gstatic.com\",\"crossOrigin\":\"anonymous\"}],[\"$\",\"link\",null,{\"href\":\"https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700\u0026display=swap\",\"rel\":\"stylesheet\"}],[\"$\",\"link\",null,{\"href\":\"https://fonts.googleapis.com/css2?family=Catamaran:wght@800\u0026display=swap\",\"rel\":\"stylesheet\"}],[\"$\",\"link\",null,{\"rel\":\"icon\",\"type\":\"image/png\",\"href\":\"/favicon2.png\"}],[\"$\",\"link\",null,{\"rel\":\"shortcut icon\",\"href\":\"/favicon2.png\"}],[\"$\",\"link\",null,{\"rel\":\"apple-touch-icon\",\"href\":\"/favicon2.png\"}],[\"$\",\"script\",null,{\"id\":\"ads\",\"async\":true,\"src\":\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"(adsbygoogle=window.adsbygoogle||[]).requestNonPersonalizedAds=1;\"}}]]}],[\"$\",\"body\",null,{\"children\":[[\"$\",\"noscript\",null,{\"children\":\"You need to enable JavaScript to run this app.\"}],[\"$\",\"$L8\",null,{}],[\"$\",\"$L9\",null,{\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[]}]}]]}]]}]],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]\n"])</script><script>self.__next_f.push([1,"d:I[5553,[\"9243\",\"static/chunks/9243-972bdccd4ceb11ae.js\",\"5800\",\"static/chunks/5800-4312aed1aa8a4305.js\",\"549\",\"static/chunks/549-2babc012700e23ed.js\",\"4853\",\"static/chunks/4853-73ca7990eb89674b.js\",\"6797\",\"static/chunks/app/blog/%5B...slug%5D/page-9b274a2e0073d544.js\"],\"BlogPostPageClient\"]\ne:T3d50,"])</script><script>self.__next_f.push([1,"\n## Object Dependencies(객체 의존성)\n\n- 현재 객체가 다른 객체와 상호작용(참조)하고 있다면 현재 객체는 다른 객체에 의존성을 가집니다.\n- 하나의 모듈이 바뀌면 의존한 다른 모듈까지 변경 되어야 합니다. 또한 두 객체 사이의 의존성이 존재하면 Unit Test 작성이 어려워집니다.\n- `의존성`은 서비스로 사용할 수 있는 객체입니다.\n\n## Dependency Injection(의존성 주입)\n\n- 의존성 주입은 `역 제어(Inversion of Control, IOC) 테크닉의 한 형태`로 어떤 서비스를 호출하려는 컴포넌트는 그 서비스가 어떻게 구성되었는지 알지 못해야 합니다.\n- 클라이언트가 어떤 서비스를 사용할 것인지 지정하는 대신, 클라이언트에게 무슨 서비스를 사용할 것인지를 말(주입)해주는 것이다.\n  - `주입`은 의존성(서비스)을 사용하려는 객체(클라이언트)로 전달하는 것을 의미합니다. 서비스는 클라이언트 상태의 일부입니다. 클라이언트가 서비스를 구축하거나 찾는 것을 허용하는 대신 클라이언트에게 서비스를 전달하는 것이 패턴의 기본 요건입니다.\n- 클래스 간의 의존관계가 있을 때 `컴파일 타임의 의존관계를 제거`하고 `런타임 의존관계`로 만들어 주고 `결합도(coupling)을 낮춰주는 것`이 Dependency Injection입니다.\n- 컴포넌트는 서비스 제공에 대한 책임을 `외부 코드(Injector)에게 위임`하고 Injector는 이미 존재하거나 Injector에 의해 생성된 서비스를 컴포넌트에게 주입하고 컴포넌트는 서비스를 사용합니다. 이는 `컴포넌트가 Injector와 서비스에 대해 알 필요가 없음`을 의미합니다. 컴포넌트는 서비스의 인터페이스에 대해서만 알면 되고 이는 `구성의 책임으로부터 사용의 책임을 구분`합니다.\n- Dependency Injection은 프로그램의 디자인이 `느슨하게 커플링`되도록 하고, `의존관계 역전 원칙(Dependency Inversion Principle)`과 `단일 책임 원칙(single responsibility principles)`을 따르도록 클라이언트의 생성에 대한 의존성을 클라이언트의 행위로부터 분리하는 것입니다. 이는 클라이언트가 의존성을 찾기 위해 그들이 사용하는 시스템에 대해 알도록 하는 서비스 로케이터 패턴(service locator pattern)과 정반대되는 것입니다.\n- 의존성 주입은 컴포지션을 통해 IoC를 구현하므로 종종 전략 패턴과 동일하지만, 전략 패턴의 의도는 객체의 수명동안 의존성을 교환할 수 있도록 하는 것이고, 의존성 주입에서는 단일 의존성 인스턴스만 사용할 수 있도록 하는 것입니다.\n  - 싱글턴과 전략패턴과 연관이 있어 보입니다.\n\n### 숨겨진 의존성은 나쁘다\n\n- 의존성 주입 외에도 의존성을 해결할 수 있는 다양한 방법이 존재합니다. 가장 널리 사용되는 대표적인 방법은 `SERVICE LOCATOR` 패턴입니다.\n  - 서비스 로케이터의 기본 아이디어는 각각 서비스별(ServiceClass) 서로 결합도를 낮추고, 어플리케이션이 필요로 하는 모든 서비스들을 포함하고 있는 객체를 갖는 것이니다. 즉, 서비스(의존성)를 찾아주는(=locate) 녀석을 전역에 만들어놓고 사용하여, 의존성을 관리합니다. DI 와 다르게, 의존성을 찾아 씁니다.\n- `SERVICE LOCATOR`는 의존성을 해결할 객체들을 보관하는 일종의 저장소입니다. 외부에서 객체에게 의존성을 전달하는 의존성 주입과 달리 `SERVICE LOCATOR`의 경우 객체가 직접 `SERVICE LOCATOR`에게 의존성을 해결해줄 것을 요청합니다. SERVICE LOCATOR 패턴은 서비스를 사용하는 코드로부터 서비스가 누구인지(서비스를 구현한 구체 클래스의 타입이 무엇인지), 어디에 있는지(클래스 인스턴스를 어떻게 얻을지)를 몰라도 되게 해줍니다. `SERVICE LOCATOR` 패턴의 가장 큰 단점은 의존성을 감춥니다.\n- 의존성을 구현 내부로 감출 경우 의존성과 관련된 문제가 `컴파일타임이 아닌 런타임에 가서야 발견된다는 사실을 알 수 있습니다`.\n- 숨겨진 의존성은 의존성의 대상을 설정하는 시점과 의존성이 해결되는 시점을 멀리 떨어뜨려 놓습니다. 이것은 코드를 이해하고 디버깅 하기 어렵게 만듭니다.\n- 핵심은 `명시적인 의존성이 숨겨진 의존성보다 좋다`는 것입니다. 가급적 `의존성을 객체의 퍼블릭 인터페이스에 노출`합니다. 의존성을 구현 내부에 숨기면 숨길수록 코드를 이해하기도, 수정하기도 어려워집니다.\n- 어쩔수 없이 SERVICE LOCATOR 패턴을 사용해야 하는 경우도 있습니다. 의존성 주입을 지원하는 프레임워크를 사용하지 못하는 경우나 깊은 호출 계층에 걸쳐 동일한 객체를 계속해서 전달해야 하는 고통을 견디기 어려운 경우에는 어쩔수 없이 SERVICE LOCATOR 패턴을 사용하는 것을 고려합니다.\n- 가능하다면 의존성을 명시적으로 표현할 수 있는 기법을 사용합니다.\n  - `의존성 주입은 의존성을 명시적으로 명시할 수 있는 방법 중 하나`일 뿐입니다.\n  - 요점은 `명시적인 의존성`에 초점을 맞추는 것입니다.\n  - 이 방법이 유연성을 향상시키는 가장 효과적인 방법입니다.\n\n### SRP(Single Responsibility Principle, 단일 책임 원칙)\n\n- 소프트웨어의 설계 부품은 단 하나의 책임만을 가져야 합니다.\n- 즉 소프트웨어를 수정할 이유가 오직 하나여야 합니다.\n\n### DIP(Dependency Inversion Principle, 의존관계 역전 원칙)\n\n- 첫 번째, 상위 모듈은 하위 모듈에 의존해서는 안 됩니다. 둘 다 `추상화`에 의존해야 합니다.\n- 두 번째, 추상화는 `세부사항에 의존하지 않습니다`. 세부사항이 추상화에 의존하여 달라져야 합니다.\n- 의존 관계를 맺을 때, 변화하기 쉬운 것보단 변화하기 어려운 것에 의존해야 합니다.\n  - 이때 변화하기 쉬운 것이란 구체적인 것을 말하고, 변화하기 어려운 것이란 추상적인 것을 말합니다.\n  - 객체지향 관점에서 변화하기 쉬운 것이란 구체화된 클래스를 말하고, 변화하기 어려운 것이란 인터페이스를 의미합니다.\n- DIP를 만족한다는 것은 의존관계를 맺을 때, 상위 모듈(클라이언트 클래스)는 하위 모듈(서비스 클래스)이 되는 구체적인 클래스보다 인터페이스나 추상 클래스와 관계를 맺는다는 것을 의미합니다.\n- DIP를 만족하면 Dependency Injection 패턴을 적용해서 변화에 유연한 설계를 할 수 있습니다.\n- 이 원칙은 `상위와 하위 객체 모두가 동일한 추상화에 의존해야 한다`는 객체 지향적 설계의 대원칙을 제공합니다.\n- DI는 `DIP를 구현하는 기법중 하나라`고 생각 할 수 있습니다.\n  - DI는 의존성을 어떻게 가질 것인가? DIP는 실체에 의존할 것인가, 추상화에 의존할 것인가의 문제라고 생각됩니다.\n\n#### 의존성 역전 원칙과 패키지\n\n- 역전은 의존성의 방향뿐만 아니라 인터페이스의 소유권에도 적용됩니다. 객체지향 프로그래밍 언어에서 어떤 구성 요소의 소유권을 결정하는 것은 모듈입니다.\n- `SEPARATED INTERFACE 패턴`\n  - 추상화를 별도의 독립적인 패키지가 아니라 클라이언트가 속한 패키지에 포함시켜야 합니다.\n  - 함께 재사용될 필요가 없는 클래스들은 별도의 독립적인 패키지에 모아야 합니다.\n- 의존성 역전 원칙에 따라 상위 수준의 협력 흐름을 재사용하기 위해서는 추상화가 제공하는 인터페이스의 소유권 역시 역전시켜야 합니다.\n- 훌륭한 객체지향 설계를 위해서는 의존성을 역전시켜야 합니다. 그리고 의존성을 역전시켜야만 유연하고 재사용 가능한 설계를 얻을 수 있습니다.\n\n### IoC(제어의 역전)\n\n- 역제어(IoC)는 DI보다 더 일반적입니다.\n- 객체 자체가 아니라 `Framework에 의해 객체의 의존성이 주입되는 설계 패턴`입니다. Framework에 의해 동적으로 주입되므로 여러 객체 간의 결합이 줄어듭니다.\n- IoC는 호출을 요구하는 대신 다른 코드가 호출할 수 있게 함을 의미합니다.\n- 제어 반전, 제어의 반전, 역제어는 프로그래머가 작성한 프로그램이 재사용 라이브러리의 흐름 제어를 받게 되는 소프트웨어 디자인 패턴을 말합니다. 줄여서 IoC(Inversion of Control)이라고 부릅니다. 전통적인 프로그래밍에서 흐름은 프로그래머가 작성한 프로그램이 외부 라이브러리의 코드를 호출해 이용합니다. 하지만 제어 반전이 적용된 구조에서는 외부 라이브러리의 코드가 프로그래머가 작성한 코드를 호출합니다. 설계 목적상 제어 반전의 목적은 다음과 같습니다.\n  - 작업을 구현하는 방식과 작업 수행 자체를 분리합니다.\n  - 모듈을 제작할 때, 모듈과 외부 프로그램의 결합에 대해 고민할 필요 없이 모듈의 목적에 집중할 수 있습니다.\n  - 다른 시스템이 어떻게 동작할지에 대해 고민할 필요 없이, 미리 정해진 협약대로만 동작하게 하면 됩니다.\n  - 모듈을 바꾸어도 다른 시스템에 부작용을 일으키지 않습니다.\n- 이 관계에서 제어가 역전되었다고 표현하는데 같은 맥락에서 `팩토리 메소드`와 `템플리 메소드 패턴` 역시 IoC를 설명하는 예 중 하나입니다.\n- IoC는 제어의 역전에 관한 소프트웨어 용어로 `누가 작업을 수행하느냐`가 포인트입니다.\n\n## 의존성 주입은 다음과 같은 문제를 해결합니다.\n\n- 어떻게 애플리케이션이나 클래스가 객체의 생성 방식과 독립적일 수 있는가?\n- 어떻게 객체의 생성 방식을 분리된 구성 파일에서 지정할 수 있는가?\n- 어떻게 애플리케이션이 다른 구성을 지원할 수 있는가?\n\n## 의존성 주입은 네 가지 역할을 포함한다.\n\n- 사용될 서비스 객체\n- 사용하는 서비스에 의존하는 클라이언트 객체\n- 클라이언트의 서비스 사용 방법을 정의하는 인터페이스\n- 서비스를 생성하고 클라이언트로 주입하는 책임을 갖는 주입자\n\n## 의존성 주입 방법\n\n- 생성자 주입 : 필요한 의존성을 모두 포함하는 클래스의 생성자를 만들고 그 생성자를 통해 의존성을 주입합니다.\n- 세터(Setter)를 통한 주입 : 의존성을 입력받는 세터(Setter) 메소드를 만들고 이를 통해 의존성을 주입합니다.\n- 인터페이스(Interface)를 통한 주입 : 의존성을 주입하는 함수를 포함한 인터페이스를 작성하고 이 인터페이스를 구현하도록 함으로써 실행시에 이를 통하여 의존성을 주입합니다.\n\n### 생성자 주입(constructor injection)\n\n- 객체를 생성하는 시점에 생성자를 통한 의존성을 해결하는 방법입니다.\n\n### setter 주입(setter injection)\n\n- 객체 생성 후 setter 메서드를 통한 의존성을 해결하는 방법입니다.\n- setter 주입의 장점은 의존성의 대상을 `런타임에 변경`할 수 있다는 것입니다.\n  - 생성자 주입을 통해 설정된 인스턴스는 객체의 생명주기 전체에 걸쳐 관계를 유지하는 반면, setter 주입은 언제라도 의존 대상을 교체할 수 있습니다.\n- setter 주입의 단점은 객체가 올바로 생성되기 위해 어떤 의존성이 `필수적인지를 명시적으로 표현할 수 없다`는 것입니다.\n  - setter 메서드는 객체가 생성된 후에 호출돼야 하기 때문에 setter 메서드 호출을 누락한다면 객체는 비정상적인 상태로 생성될 것입니다.\n\n### 인터페이스 주입(interface injection)\n\n- 인터페이스 주입의 기본 개념은 주입할 의존성을 명시하기 위해 인터페이스를 사용하는 것입니다.\n  - 인터페이스 주입은 근본적으로 setter 주입이나 프로퍼티 주입과 동일합니다. 단지 `어떤 대상을 어떻게 주입할 것인지를 인터페이스를 통해 명시적으로 선언`한다는 차이만 있을 뿐입니다. 인터페이스 주입은 의존성 주입이 도입되던 초창기에 자바 진영에서 만들어진 몇몇 프레임워크에서 의존성 대상을 좀 더 명시적으로 정의하고 편하게 관리하기 위해 도입한 방법입니다. 따라서 약간의 구현적인 관점을 덜어내고 의존성 주입이 가지는 목적과 용도라는 본질적인 측면에서 바라보면 인퍼테이스 `주입은 setter 주입과 프로퍼티 주입의 변형`으로 볼 수 있습니다.\n\n### 메서드 주입(method injection)\n\n- 메서드 실행 시 인자를 이용한 의존성을 해결하는 방법입니다.\n- 메서드 주입은 `메서드 호출 주입(method call injection)`이라고도 부르며 메서드가 의존성을 필요로 하는 유일한 경우일 때 사용할 수 있습니다.\n- 생성자 주입을 통해 의존성을 전달받으면 객체가 올바른 상태로 생성되는 데 필요한 의존성을 명확하게 표현할 수 있다는 장점이 있지만 주입된 의존성이 한 두개의 메서드에서만 사용된다면 각 메서드의 인자로 전달하는 것이 더 나은 방법일 수 있습니다.\n- 메서드 주입을 의존성 주입의 한 종류로 볼 것인가에 대해서는 논란의 여지가 있습니다.\n\n## 장점\n\n- 의존성 주입의 의도는 객체의 `생성과 사용의 관심을 분리`하는 것이다.\n- 코드의 재사용성 증가 및 코드 단순화\n  - 만약 특정 객체를 여러 클라이언트에서 의존한다면 각 클라이언트가 특정 객체를 모두 구현할 필요없이 서비스가 이를 한 번만 구현하여 여러 클라이언트에게 의존성을 주입해주어 효율적입니다.\n- 리펙토링의 과정 수월\n  - 특정 객체에 의존성이 존재하는 클라이언트와 특정 객체를 필요로하는 클라이언트에게 간접적으로 의존성을 주입하는 서비스의 모듈이 체계적으로 분리되어 리펙토링 과정에서 조금 더 수월합니다.\n- 보일러 코드 감소\n  - 특정 객체를 필요로하는 클라이언트가 직접적으로 그 객체를 구현하지 않고 주입 받는 형식으로 이루어지기 때문에 필요할 때만 데이터를 전달받아 보일러 코드와 같이 메모리 누수 현상을 막을 수 있습니다.\n- 프로그램 테스트 용이\n  - 프로그램 내의 각 모듈들이 체계적으로 분리되어 Unit Test를 보다 더 쉽게 진행할 수 있습니다.\n\n## 비지터 패턴과는 조금의 차이가 있다고 합니다.\n\n## 참고\n\n- [\\[Design Pattern\\] DI란 (Dependency Injection)](https://gmlwjd9405.github.io/2018/11/09/dependency-injection.html)\n- [\\[Design Pattern\\] Dependency Injection](https://iamsjy17.github.io/design%20pattern/2020/05/30/designpattern_dependency_injection.html)\n- [의존성 주입](https://ko.wikipedia.org/wiki/%EC%9D%98%EC%A1%B4%EC%84%B1_%EC%A3%BC%EC%9E%85)\n- [Dependency Injection 디자인 패턴](https://juyeop.tistory.com/26)\n- [\\[디자인패턴\\] IoC, DI, DIP 용어 정리](https://black-jin0427.tistory.com/194)\n"])</script><script>self.__next_f.push([1,"f:T502b,"])</script><script>self.__next_f.push([1,"\u003ch2 id=\"object-dependencies객체-의존성\"\u003eObject Dependencies(객체 의존성)\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#object-dependencies객체-의존성\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e현재 객체가 다른 객체와 상호작용(참조)하고 있다면 현재 객체는 다른 객체에 의존성을 가집니다.\u003c/li\u003e\n\u003cli\u003e하나의 모듈이 바뀌면 의존한 다른 모듈까지 변경 되어야 합니다. 또한 두 객체 사이의 의존성이 존재하면 Unit Test 작성이 어려워집니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode class=\"inline-code\"\u003e의존성\u003c/code\u003e은 서비스로 사용할 수 있는 객체입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"dependency-injection의존성-주입\"\u003eDependency Injection(의존성 주입)\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#dependency-injection의존성-주입\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e의존성 주입은 \u003ccode class=\"inline-code\"\u003e역 제어(Inversion of Control, IOC) 테크닉의 한 형태\u003c/code\u003e로 어떤 서비스를 호출하려는 컴포넌트는 그 서비스가 어떻게 구성되었는지 알지 못해야 합니다.\u003c/li\u003e\n\u003cli\u003e클라이언트가 어떤 서비스를 사용할 것인지 지정하는 대신, 클라이언트에게 무슨 서비스를 사용할 것인지를 말(주입)해주는 것이다.\n\u003cul\u003e\n\u003cli\u003e\u003ccode class=\"inline-code\"\u003e주입\u003c/code\u003e은 의존성(서비스)을 사용하려는 객체(클라이언트)로 전달하는 것을 의미합니다. 서비스는 클라이언트 상태의 일부입니다. 클라이언트가 서비스를 구축하거나 찾는 것을 허용하는 대신 클라이언트에게 서비스를 전달하는 것이 패턴의 기본 요건입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e클래스 간의 의존관계가 있을 때 \u003ccode class=\"inline-code\"\u003e컴파일 타임의 의존관계를 제거\u003c/code\u003e하고 \u003ccode class=\"inline-code\"\u003e런타임 의존관계\u003c/code\u003e로 만들어 주고 \u003ccode class=\"inline-code\"\u003e결합도(coupling)을 낮춰주는 것\u003c/code\u003e이 Dependency Injection입니다.\u003c/li\u003e\n\u003cli\u003e컴포넌트는 서비스 제공에 대한 책임을 \u003ccode class=\"inline-code\"\u003e외부 코드(Injector)에게 위임\u003c/code\u003e하고 Injector는 이미 존재하거나 Injector에 의해 생성된 서비스를 컴포넌트에게 주입하고 컴포넌트는 서비스를 사용합니다. 이는 \u003ccode class=\"inline-code\"\u003e컴포넌트가 Injector와 서비스에 대해 알 필요가 없음\u003c/code\u003e을 의미합니다. 컴포넌트는 서비스의 인터페이스에 대해서만 알면 되고 이는 \u003ccode class=\"inline-code\"\u003e구성의 책임으로부터 사용의 책임을 구분\u003c/code\u003e합니다.\u003c/li\u003e\n\u003cli\u003eDependency Injection은 프로그램의 디자인이 \u003ccode class=\"inline-code\"\u003e느슨하게 커플링\u003c/code\u003e되도록 하고, \u003ccode class=\"inline-code\"\u003e의존관계 역전 원칙(Dependency Inversion Principle)\u003c/code\u003e과 \u003ccode class=\"inline-code\"\u003e단일 책임 원칙(single responsibility principles)\u003c/code\u003e을 따르도록 클라이언트의 생성에 대한 의존성을 클라이언트의 행위로부터 분리하는 것입니다. 이는 클라이언트가 의존성을 찾기 위해 그들이 사용하는 시스템에 대해 알도록 하는 서비스 로케이터 패턴(service locator pattern)과 정반대되는 것입니다.\u003c/li\u003e\n\u003cli\u003e의존성 주입은 컴포지션을 통해 IoC를 구현하므로 종종 전략 패턴과 동일하지만, 전략 패턴의 의도는 객체의 수명동안 의존성을 교환할 수 있도록 하는 것이고, 의존성 주입에서는 단일 의존성 인스턴스만 사용할 수 있도록 하는 것입니다.\n\u003cul\u003e\n\u003cli\u003e싱글턴과 전략패턴과 연관이 있어 보입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"숨겨진-의존성은-나쁘다\"\u003e숨겨진 의존성은 나쁘다\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#숨겨진-의존성은-나쁘다\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e의존성 주입 외에도 의존성을 해결할 수 있는 다양한 방법이 존재합니다. 가장 널리 사용되는 대표적인 방법은 \u003ccode class=\"inline-code\"\u003eSERVICE LOCATOR\u003c/code\u003e 패턴입니다.\n\u003cul\u003e\n\u003cli\u003e서비스 로케이터의 기본 아이디어는 각각 서비스별(ServiceClass) 서로 결합도를 낮추고, 어플리케이션이 필요로 하는 모든 서비스들을 포함하고 있는 객체를 갖는 것이니다. 즉, 서비스(의존성)를 찾아주는(=locate) 녀석을 전역에 만들어놓고 사용하여, 의존성을 관리합니다. DI 와 다르게, 의존성을 찾아 씁니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode class=\"inline-code\"\u003eSERVICE LOCATOR\u003c/code\u003e는 의존성을 해결할 객체들을 보관하는 일종의 저장소입니다. 외부에서 객체에게 의존성을 전달하는 의존성 주입과 달리 \u003ccode class=\"inline-code\"\u003eSERVICE LOCATOR\u003c/code\u003e의 경우 객체가 직접 \u003ccode class=\"inline-code\"\u003eSERVICE LOCATOR\u003c/code\u003e에게 의존성을 해결해줄 것을 요청합니다. SERVICE LOCATOR 패턴은 서비스를 사용하는 코드로부터 서비스가 누구인지(서비스를 구현한 구체 클래스의 타입이 무엇인지), 어디에 있는지(클래스 인스턴스를 어떻게 얻을지)를 몰라도 되게 해줍니다. \u003ccode class=\"inline-code\"\u003eSERVICE LOCATOR\u003c/code\u003e 패턴의 가장 큰 단점은 의존성을 감춥니다.\u003c/li\u003e\n\u003cli\u003e의존성을 구현 내부로 감출 경우 의존성과 관련된 문제가 \u003ccode class=\"inline-code\"\u003e컴파일타임이 아닌 런타임에 가서야 발견된다는 사실을 알 수 있습니다\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e숨겨진 의존성은 의존성의 대상을 설정하는 시점과 의존성이 해결되는 시점을 멀리 떨어뜨려 놓습니다. 이것은 코드를 이해하고 디버깅 하기 어렵게 만듭니다.\u003c/li\u003e\n\u003cli\u003e핵심은 \u003ccode class=\"inline-code\"\u003e명시적인 의존성이 숨겨진 의존성보다 좋다\u003c/code\u003e는 것입니다. 가급적 \u003ccode class=\"inline-code\"\u003e의존성을 객체의 퍼블릭 인터페이스에 노출\u003c/code\u003e합니다. 의존성을 구현 내부에 숨기면 숨길수록 코드를 이해하기도, 수정하기도 어려워집니다.\u003c/li\u003e\n\u003cli\u003e어쩔수 없이 SERVICE LOCATOR 패턴을 사용해야 하는 경우도 있습니다. 의존성 주입을 지원하는 프레임워크를 사용하지 못하는 경우나 깊은 호출 계층에 걸쳐 동일한 객체를 계속해서 전달해야 하는 고통을 견디기 어려운 경우에는 어쩔수 없이 SERVICE LOCATOR 패턴을 사용하는 것을 고려합니다.\u003c/li\u003e\n\u003cli\u003e가능하다면 의존성을 명시적으로 표현할 수 있는 기법을 사용합니다.\n\u003cul\u003e\n\u003cli\u003e\u003ccode class=\"inline-code\"\u003e의존성 주입은 의존성을 명시적으로 명시할 수 있는 방법 중 하나\u003c/code\u003e일 뿐입니다.\u003c/li\u003e\n\u003cli\u003e요점은 \u003ccode class=\"inline-code\"\u003e명시적인 의존성\u003c/code\u003e에 초점을 맞추는 것입니다.\u003c/li\u003e\n\u003cli\u003e이 방법이 유연성을 향상시키는 가장 효과적인 방법입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"srpsingle-responsibility-principle-단일-책임-원칙\"\u003eSRP(Single Responsibility Principle, 단일 책임 원칙)\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#srpsingle-responsibility-principle-단일-책임-원칙\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e소프트웨어의 설계 부품은 단 하나의 책임만을 가져야 합니다.\u003c/li\u003e\n\u003cli\u003e즉 소프트웨어를 수정할 이유가 오직 하나여야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"dipdependency-inversion-principle-의존관계-역전-원칙\"\u003eDIP(Dependency Inversion Principle, 의존관계 역전 원칙)\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#dipdependency-inversion-principle-의존관계-역전-원칙\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e첫 번째, 상위 모듈은 하위 모듈에 의존해서는 안 됩니다. 둘 다 \u003ccode class=\"inline-code\"\u003e추상화\u003c/code\u003e에 의존해야 합니다.\u003c/li\u003e\n\u003cli\u003e두 번째, 추상화는 \u003ccode class=\"inline-code\"\u003e세부사항에 의존하지 않습니다\u003c/code\u003e. 세부사항이 추상화에 의존하여 달라져야 합니다.\u003c/li\u003e\n\u003cli\u003e의존 관계를 맺을 때, 변화하기 쉬운 것보단 변화하기 어려운 것에 의존해야 합니다.\n\u003cul\u003e\n\u003cli\u003e이때 변화하기 쉬운 것이란 구체적인 것을 말하고, 변화하기 어려운 것이란 추상적인 것을 말합니다.\u003c/li\u003e\n\u003cli\u003e객체지향 관점에서 변화하기 쉬운 것이란 구체화된 클래스를 말하고, 변화하기 어려운 것이란 인터페이스를 의미합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eDIP를 만족한다는 것은 의존관계를 맺을 때, 상위 모듈(클라이언트 클래스)는 하위 모듈(서비스 클래스)이 되는 구체적인 클래스보다 인터페이스나 추상 클래스와 관계를 맺는다는 것을 의미합니다.\u003c/li\u003e\n\u003cli\u003eDIP를 만족하면 Dependency Injection 패턴을 적용해서 변화에 유연한 설계를 할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e이 원칙은 \u003ccode class=\"inline-code\"\u003e상위와 하위 객체 모두가 동일한 추상화에 의존해야 한다\u003c/code\u003e는 객체 지향적 설계의 대원칙을 제공합니다.\u003c/li\u003e\n\u003cli\u003eDI는 \u003ccode class=\"inline-code\"\u003eDIP를 구현하는 기법중 하나라\u003c/code\u003e고 생각 할 수 있습니다.\n\u003cul\u003e\n\u003cli\u003eDI는 의존성을 어떻게 가질 것인가? DIP는 실체에 의존할 것인가, 추상화에 의존할 것인가의 문제라고 생각됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"의존성-역전-원칙과-패키지\"\u003e의존성 역전 원칙과 패키지\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#의존성-역전-원칙과-패키지\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e역전은 의존성의 방향뿐만 아니라 인터페이스의 소유권에도 적용됩니다. 객체지향 프로그래밍 언어에서 어떤 구성 요소의 소유권을 결정하는 것은 모듈입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode class=\"inline-code\"\u003eSEPARATED INTERFACE 패턴\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e추상화를 별도의 독립적인 패키지가 아니라 클라이언트가 속한 패키지에 포함시켜야 합니다.\u003c/li\u003e\n\u003cli\u003e함께 재사용될 필요가 없는 클래스들은 별도의 독립적인 패키지에 모아야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e의존성 역전 원칙에 따라 상위 수준의 협력 흐름을 재사용하기 위해서는 추상화가 제공하는 인터페이스의 소유권 역시 역전시켜야 합니다.\u003c/li\u003e\n\u003cli\u003e훌륭한 객체지향 설계를 위해서는 의존성을 역전시켜야 합니다. 그리고 의존성을 역전시켜야만 유연하고 재사용 가능한 설계를 얻을 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"ioc제어의-역전\"\u003eIoC(제어의 역전)\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#ioc제어의-역전\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e역제어(IoC)는 DI보다 더 일반적입니다.\u003c/li\u003e\n\u003cli\u003e객체 자체가 아니라 \u003ccode class=\"inline-code\"\u003eFramework에 의해 객체의 의존성이 주입되는 설계 패턴\u003c/code\u003e입니다. Framework에 의해 동적으로 주입되므로 여러 객체 간의 결합이 줄어듭니다.\u003c/li\u003e\n\u003cli\u003eIoC는 호출을 요구하는 대신 다른 코드가 호출할 수 있게 함을 의미합니다.\u003c/li\u003e\n\u003cli\u003e제어 반전, 제어의 반전, 역제어는 프로그래머가 작성한 프로그램이 재사용 라이브러리의 흐름 제어를 받게 되는 소프트웨어 디자인 패턴을 말합니다. 줄여서 IoC(Inversion of Control)이라고 부릅니다. 전통적인 프로그래밍에서 흐름은 프로그래머가 작성한 프로그램이 외부 라이브러리의 코드를 호출해 이용합니다. 하지만 제어 반전이 적용된 구조에서는 외부 라이브러리의 코드가 프로그래머가 작성한 코드를 호출합니다. 설계 목적상 제어 반전의 목적은 다음과 같습니다.\n\u003cul\u003e\n\u003cli\u003e작업을 구현하는 방식과 작업 수행 자체를 분리합니다.\u003c/li\u003e\n\u003cli\u003e모듈을 제작할 때, 모듈과 외부 프로그램의 결합에 대해 고민할 필요 없이 모듈의 목적에 집중할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e다른 시스템이 어떻게 동작할지에 대해 고민할 필요 없이, 미리 정해진 협약대로만 동작하게 하면 됩니다.\u003c/li\u003e\n\u003cli\u003e모듈을 바꾸어도 다른 시스템에 부작용을 일으키지 않습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e이 관계에서 제어가 역전되었다고 표현하는데 같은 맥락에서 \u003ccode class=\"inline-code\"\u003e팩토리 메소드\u003c/code\u003e와 \u003ccode class=\"inline-code\"\u003e템플리 메소드 패턴\u003c/code\u003e 역시 IoC를 설명하는 예 중 하나입니다.\u003c/li\u003e\n\u003cli\u003eIoC는 제어의 역전에 관한 소프트웨어 용어로 \u003ccode class=\"inline-code\"\u003e누가 작업을 수행하느냐\u003c/code\u003e가 포인트입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"의존성-주입은-다음과-같은-문제를-해결합니다\"\u003e의존성 주입은 다음과 같은 문제를 해결합니다.\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#의존성-주입은-다음과-같은-문제를-해결합니다\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e어떻게 애플리케이션이나 클래스가 객체의 생성 방식과 독립적일 수 있는가?\u003c/li\u003e\n\u003cli\u003e어떻게 객체의 생성 방식을 분리된 구성 파일에서 지정할 수 있는가?\u003c/li\u003e\n\u003cli\u003e어떻게 애플리케이션이 다른 구성을 지원할 수 있는가?\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"의존성-주입은-네-가지-역할을-포함한다\"\u003e의존성 주입은 네 가지 역할을 포함한다.\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#의존성-주입은-네-가지-역할을-포함한다\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e사용될 서비스 객체\u003c/li\u003e\n\u003cli\u003e사용하는 서비스에 의존하는 클라이언트 객체\u003c/li\u003e\n\u003cli\u003e클라이언트의 서비스 사용 방법을 정의하는 인터페이스\u003c/li\u003e\n\u003cli\u003e서비스를 생성하고 클라이언트로 주입하는 책임을 갖는 주입자\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"의존성-주입-방법\"\u003e의존성 주입 방법\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#의존성-주입-방법\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e생성자 주입 : 필요한 의존성을 모두 포함하는 클래스의 생성자를 만들고 그 생성자를 통해 의존성을 주입합니다.\u003c/li\u003e\n\u003cli\u003e세터(Setter)를 통한 주입 : 의존성을 입력받는 세터(Setter) 메소드를 만들고 이를 통해 의존성을 주입합니다.\u003c/li\u003e\n\u003cli\u003e인터페이스(Interface)를 통한 주입 : 의존성을 주입하는 함수를 포함한 인터페이스를 작성하고 이 인터페이스를 구현하도록 함으로써 실행시에 이를 통하여 의존성을 주입합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"생성자-주입constructor-injection\"\u003e생성자 주입(constructor injection)\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#생성자-주입constructor-injection\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e객체를 생성하는 시점에 생성자를 통한 의존성을 해결하는 방법입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"setter-주입setter-injection\"\u003esetter 주입(setter injection)\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#setter-주입setter-injection\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e객체 생성 후 setter 메서드를 통한 의존성을 해결하는 방법입니다.\u003c/li\u003e\n\u003cli\u003esetter 주입의 장점은 의존성의 대상을 \u003ccode class=\"inline-code\"\u003e런타임에 변경\u003c/code\u003e할 수 있다는 것입니다.\n\u003cul\u003e\n\u003cli\u003e생성자 주입을 통해 설정된 인스턴스는 객체의 생명주기 전체에 걸쳐 관계를 유지하는 반면, setter 주입은 언제라도 의존 대상을 교체할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003esetter 주입의 단점은 객체가 올바로 생성되기 위해 어떤 의존성이 \u003ccode class=\"inline-code\"\u003e필수적인지를 명시적으로 표현할 수 없다\u003c/code\u003e는 것입니다.\n\u003cul\u003e\n\u003cli\u003esetter 메서드는 객체가 생성된 후에 호출돼야 하기 때문에 setter 메서드 호출을 누락한다면 객체는 비정상적인 상태로 생성될 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"인터페이스-주입interface-injection\"\u003e인터페이스 주입(interface injection)\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#인터페이스-주입interface-injection\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e인터페이스 주입의 기본 개념은 주입할 의존성을 명시하기 위해 인터페이스를 사용하는 것입니다.\n\u003cul\u003e\n\u003cli\u003e인터페이스 주입은 근본적으로 setter 주입이나 프로퍼티 주입과 동일합니다. 단지 \u003ccode class=\"inline-code\"\u003e어떤 대상을 어떻게 주입할 것인지를 인터페이스를 통해 명시적으로 선언\u003c/code\u003e한다는 차이만 있을 뿐입니다. 인터페이스 주입은 의존성 주입이 도입되던 초창기에 자바 진영에서 만들어진 몇몇 프레임워크에서 의존성 대상을 좀 더 명시적으로 정의하고 편하게 관리하기 위해 도입한 방법입니다. 따라서 약간의 구현적인 관점을 덜어내고 의존성 주입이 가지는 목적과 용도라는 본질적인 측면에서 바라보면 인퍼테이스 \u003ccode class=\"inline-code\"\u003e주입은 setter 주입과 프로퍼티 주입의 변형\u003c/code\u003e으로 볼 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"메서드-주입method-injection\"\u003e메서드 주입(method injection)\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#메서드-주입method-injection\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e메서드 실행 시 인자를 이용한 의존성을 해결하는 방법입니다.\u003c/li\u003e\n\u003cli\u003e메서드 주입은 \u003ccode class=\"inline-code\"\u003e메서드 호출 주입(method call injection)\u003c/code\u003e이라고도 부르며 메서드가 의존성을 필요로 하는 유일한 경우일 때 사용할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e생성자 주입을 통해 의존성을 전달받으면 객체가 올바른 상태로 생성되는 데 필요한 의존성을 명확하게 표현할 수 있다는 장점이 있지만 주입된 의존성이 한 두개의 메서드에서만 사용된다면 각 메서드의 인자로 전달하는 것이 더 나은 방법일 수 있습니다.\u003c/li\u003e\n\u003cli\u003e메서드 주입을 의존성 주입의 한 종류로 볼 것인가에 대해서는 논란의 여지가 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"장점\"\u003e장점\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#장점\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e의존성 주입의 의도는 객체의 \u003ccode class=\"inline-code\"\u003e생성과 사용의 관심을 분리\u003c/code\u003e하는 것이다.\u003c/li\u003e\n\u003cli\u003e코드의 재사용성 증가 및 코드 단순화\n\u003cul\u003e\n\u003cli\u003e만약 특정 객체를 여러 클라이언트에서 의존한다면 각 클라이언트가 특정 객체를 모두 구현할 필요없이 서비스가 이를 한 번만 구현하여 여러 클라이언트에게 의존성을 주입해주어 효율적입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e리펙토링의 과정 수월\n\u003cul\u003e\n\u003cli\u003e특정 객체에 의존성이 존재하는 클라이언트와 특정 객체를 필요로하는 클라이언트에게 간접적으로 의존성을 주입하는 서비스의 모듈이 체계적으로 분리되어 리펙토링 과정에서 조금 더 수월합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e보일러 코드 감소\n\u003cul\u003e\n\u003cli\u003e특정 객체를 필요로하는 클라이언트가 직접적으로 그 객체를 구현하지 않고 주입 받는 형식으로 이루어지기 때문에 필요할 때만 데이터를 전달받아 보일러 코드와 같이 메모리 누수 현상을 막을 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e프로그램 테스트 용이\n\u003cul\u003e\n\u003cli\u003e프로그램 내의 각 모듈들이 체계적으로 분리되어 Unit Test를 보다 더 쉽게 진행할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"비지터-패턴과는-조금의-차이가-있다고-합니다\"\u003e비지터 패턴과는 조금의 차이가 있다고 합니다.\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#비지터-패턴과는-조금의-차이가-있다고-합니다\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003ch2 id=\"참고\"\u003e참고\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#참고\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://gmlwjd9405.github.io/2018/11/09/dependency-injection.html\"\u003e[Design Pattern] DI란 (Dependency Injection)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://iamsjy17.github.io/design%20pattern/2020/05/30/designpattern_dependency_injection.html\"\u003e[Design Pattern] Dependency Injection\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://ko.wikipedia.org/wiki/%EC%9D%98%EC%A1%B4%EC%84%B1_%EC%A3%BC%EC%9E%85\"\u003e의존성 주입\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://juyeop.tistory.com/26\"\u003eDependency Injection 디자인 패턴\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://black-jin0427.tistory.com/194\"\u003e[디자인패턴] IoC, DI, DIP 용어 정리\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e"])</script><script>self.__next_f.push([1,"4:[\"$\",\"$Ld\",null,{\"post\":{\"slug\":\"/design-pattern/dependency-injection-pattern\",\"frontmatter\":{\"title\":\"dependency injection pattern\",\"date\":\"2021-04-15T10:05:33.000Z\",\"category\":\"design pattern\",\"tags\":[\"design pattern\"],\"draft\":false},\"content\":\"$e\",\"html\":\"$f\",\"excerpt\":\"## Object Dependencies(객체 의존성)  - 현재 객체가 다른 객체와 상호작용(참조)하고 있다면 현재 객체는 다른 객체에 의존성을 가집니다. - 하나의 모듈이 바뀌면 의존한 다른 모듈까지 변경 되어야 합니다. 또한 두 객체 사이의 의존성이 존재하면 Unit Test 작성이 어려워집니다. - `의존성`은 서비스로 사용할 수 있는 객체입니다.\"},\"previousPost\":{\"slug\":\"/design-pattern/singleton-pattern\",\"frontmatter\":{\"title\":\"singleton pattern\",\"date\":\"2021-04-14T21:05:29.000Z\",\"category\":\"design pattern\",\"tags\":[\"design pattern\"],\"draft\":false}},\"nextPost\":{\"slug\":\"/javascript/javascript-call-by-reference가-존재하는가\",\"frontmatter\":{\"title\":\"javascript call by reference가 존재하는가\",\"date\":\"2021-07-26T00:08:23.000Z\",\"category\":\"javascript\",\"tags\":[],\"draft\":false}}}]\na:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"dependency injection pattern\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"## Object Dependencies(객체 의존성)  - 현재 객체가 다른 객체와 상호작용(참조)하고 있다면 현재 객체는 다른 객체에 의존성을 가집니다. - 하나의 모듈이 바뀌면 의존한 다른 모듈까지 변경 되어야 합니다. 또한 두 객체 사이의 의존성이 존재하면 Unit Test 작성이 어려워집니다. - `의존성`은 서비스로 사용할 수 있는 객체입니다.\"}]]\n3:null\n"])</script></body></html>