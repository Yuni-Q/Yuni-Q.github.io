<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" as="image" href="https://www.buymeacoffee.com/assets/img/BMC-btn-logo.svg"/><link rel="preload" as="image" href="/images/profile.png"/><link rel="stylesheet" href="/_next/static/css/bc8bb31cb71603b2.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-57fdca2934e5ae0a.js"/><script src="/_next/static/chunks/6217bb07-738e49d824771fea.js" async=""></script><script src="/_next/static/chunks/5647-b33901b11da845dc.js" async=""></script><script src="/_next/static/chunks/main-app-ec1611f00934714e.js" async=""></script><script src="/_next/static/chunks/app/layout-3ad8bb7cb2292578.js" async=""></script><script src="/_next/static/chunks/9243-972bdccd4ceb11ae.js" async=""></script><script src="/_next/static/chunks/5800-4312aed1aa8a4305.js" async=""></script><script src="/_next/static/chunks/549-2babc012700e23ed.js" async=""></script><script src="/_next/static/chunks/4853-73ca7990eb89674b.js" async=""></script><script src="/_next/static/chunks/app/blog/%5B...slug%5D/page-9b274a2e0073d544.js" async=""></script><script id="ads" async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><title>WEB FRONTEND</title><meta name="description" content="- HTML부터 React까지의 제가 알고 있는 웹 프론트엔드 흐름에 대해 정리를 해보고자 합니다. - 웹은 HTML, CSS, Javascript로 구성되어 있습니다. DART나 KOTLIN.JS, 웹어셈블리 등이 웹을 지원하기는 한다고 합니다.  ## HTML  - 가장 먼저 HTML은 HyperText Markup Language로 웹페이지를 기술하"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"/><link rel="icon" type="image/png" href="/favicon2.png"/><link rel="shortcut icon" href="/favicon2.png"/><link rel="apple-touch-icon" href="/favicon2.png"/><link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&amp;display=swap" rel="stylesheet"/><link href="https://fonts.googleapis.com/css2?family=Catamaran:wght@800&amp;display=swap" rel="stylesheet"/><script>(adsbygoogle=window.adsbygoogle||[]).requestNonPersonalizedAds=1;</script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body><noscript>You need to enable JavaScript to run this app.</noscript><div class="top-header"><a class="top-link" href="/">Yuni-Q</a><div class="flex items-center"><button class="outline-0 bg-white mx-[5px] p-0 appearance-none items-center rounded-[5px] border-0 cursor-pointer inline-flex h-10 justify-center opacity-75 overflow-hidden relative scale-75 transition-opacity duration-300 ease-in-out w-10 flex-shrink-0 hover:bg-black max-[800px]:hover:bg-white"><a href="https://github.com/Yuni-Q/blog" class="github" aria-label="GitHub"><svg class="github transition-all duration-300 ease-in-out pt-1 text-[#78757a] w-8 hover:text-white max-[800px]:hover:text-[#78757a]" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg></a></button><button class="outline-0 bg-white mx-[5px] p-0 appearance-none items-center rounded-[5px] border-0 cursor-pointer inline-flex h-10 justify-center opacity-75 overflow-hidden relative scale-75 transition-opacity duration-300 ease-in-out w-10 flex-shrink-0 hover:bg-black max-[800px]:hover:bg-white group"><div class="theme1 rounded-full h-6 relative w-6 transition-all duration-[450ms] ease-in-out bg-[#78757a]" style="border:none;overflow:visible;transform:scale(0.55)"><div class="absolute rounded-full h-6 w-6 transition-transform duration-[450ms] ease-in-out" style="border:none;opacity:0;right:-9px;top:-9px;transform:translate(14px, -14px);background:#78757a"></div><div class="absolute rounded-full h-2 w-2 left-1/2 top-1/2 transition-all duration-[350ms] ease-in-out" style="box-shadow:0 -23px 0 #78757a, 0 23px 0 #78757a, 23px 0 0 #78757a, -23px 0 0 #78757a, 15px 15px 0 #78757a, -15px 15px 0 #78757a, 15px -15px 0 #78757a, -15px -15px 0 #78757a;transform:scale(1);margin:-4px 0px 0px -4px"></div></div><div class="theme2 rounded-full border-0 h-6 absolute right-0 top-0 w-6 transition-all duration-[450ms] ease-in-out" style="background:none;opacity:0;transform:translate(14px, -14px)"></div></button><button class="outline-0 bg-white mx-[5px] p-0 appearance-none items-center rounded-[5px] border-0 cursor-pointer inline-flex h-10 justify-center opacity-75 overflow-hidden relative scale-75 transition-opacity duration-300 ease-in-out w-10 flex-shrink-0 hover:bg-black max-[800px]:hover:bg-white group"><svg class="snow transition-all duration-300 ease-in-out w-7 group-hover:fill-white max-[800px]:group-hover:fill-[#78757a]" style="fill:#78757a" version="1.1" id="레이어_1" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 0 23.9 22.9"><path d="M23.9,10c0-0.3-0.2-0.5-0.4-0.6l-1.1-0.3C22.1,9.1,22,9,21.9,8.8c-0.1-0.2,0-0.4,0.1-0.6l0.8-0.9       c0.2-0.2,0.2-0.5,0-0.7c-1.2-1.4-3.1-2-5-1.4c-0.4,0.1-0.9,0.4-1.4,0.7c0.1-0.6,0.2-1.1,0.2-1.6c0-1.9-1.2-3.6-2.9-4.3       c-0.2-0.1-0.5,0-0.7,0.2l-0.6,1c-0.1,0.2-0.3,0.3-0.5,0.3c-0.2,0-0.4-0.1-0.5-0.3l-0.6-1C10.7,0,10.4-0.1,10.2,0       C8.5,0.7,7.3,2.4,7.3,4.3c0,0.5,0.1,1,0.2,1.6C7,5.6,6.5,5.4,6.1,5.2c-1.8-0.6-3.8,0-5,1.4c-0.2,0.2-0.2,0.5,0,0.7l0.8,0.9       C2,8.4,2.1,8.6,2,8.8c0,0.2-0.2,0.3-0.4,0.4L0.4,9.5C0.2,9.5,0,9.8,0,10c0.1,1.8,1.4,3.5,3.2,4c0.4,0.1,1,0.2,1.5,0.3       c-0.4,0.4-0.8,0.8-1.1,1.1c-1.1,1.6-1.2,3.6-0.2,5.2c0.1,0.2,0.4,0.3,0.7,0.2l1.1-0.4c0.2-0.1,0.4-0.1,0.6,0C6,20.6,6,20.8,6,21.1       l-0.1,1.2c0,0.3,0.2,0.5,0.4,0.6c1.8,0.4,3.7-0.2,4.8-1.8c0.3-0.4,0.5-0.8,0.8-1.4c0.2,0.5,0.5,1,0.8,1.4c1.1,1.6,3.1,2.2,4.8,1.8       c0.3-0.1,0.4-0.3,0.4-0.6l-0.1-1.2c0-0.3,0.1-0.4,0.2-0.5c0.1-0.1,0.3-0.1,0.6,0l1.1,0.4c0.2,0.1,0.5,0,0.7-0.2       c1-1.6,0.9-3.6-0.2-5.2c-0.3-0.4-0.6-0.8-1.1-1.1c0.6-0.1,1.1-0.2,1.5-0.3C22.6,13.5,23.8,11.8,23.9,10z M14.1,12.8       c0.3-0.2,0.7-0.3,1.1-0.1c0.4,0.3,0.6,0.8,0.3,1.3c-0.3,0.4-0.8,0.6-1.3,0.3c-0.3-0.2-0.5-0.6-0.4-1l-1.4-0.8v1.6       c0.4,0.1,0.6,0.5,0.6,0.9c0,0.5-0.4,0.9-0.9,0.9c-0.5,0-0.9-0.4-0.9-0.9c0-0.4,0.3-0.7,0.6-0.9v-1.6l-1.4,0.8c0.1,0.4-0.1,0.8-0.4,1       c-0.4,0.3-1,0.1-1.3-0.3c-0.3-0.4-0.1-1,0.3-1.3c0.3-0.2,0.8-0.1,1.1,0.1l1.4-0.8L10,11.1c-0.3,0.2-0.7,0.3-1.1,0.1       C8.5,11,8.3,10.4,8.6,10c0.3-0.4,0.8-0.6,1.3-0.3c0.3,0.2,0.5,0.6,0.4,1l1.4,0.8V9.8c-0.4-0.1-0.6-0.5-0.6-0.9C11.1,8.4,11.5,8,12,8       c0.5,0,0.9,0.4,0.9,0.9c0,0.4-0.3,0.7-0.6,0.9v1.6l1.4-0.8c-0.1-0.4,0.1-0.8,0.4-1c0.4-0.3,1-0.1,1.3,0.3c0.3,0.4,0.1,1-0.3,1.3       c-0.3,0.2-0.8,0.1-1.1-0.1l-1.4,0.8L14.1,12.8z"></path></svg></button><a class="w-[30px] h-[30px] leading-[30px] mx-[5px] text-black flex-shrink-0 flex items-center justify-center" href="/search/">검색</a></div></div><div class="layout-content" style="margin-right:0;max-width:none"><div class="mb-6 max-w-4xl mx-auto px-4 xl:pr-[220px]"><ins class="adsbygoogle block min-w-[320px] min-h-0 mx-auto bg-gray-300" data-ad-client="ca-pub-2667251850399676" data-ad-slot="9586629994" data-ad-format="auto" data-full-width-responsive="true"></ins></div><div class="relative"><div class="max-w-4xl mx-auto px-4 xl:pr-[220px]"><h1 class="text-4xl md:text-5xl font-extrabold mb-6 leading-tight text-gray-900 dark:text-gray-100">WEB FRONTEND</h1><div class="flex flex-col gap-4 mb-8"><div class="flex items-center gap-2 text-gray-600 dark:text-gray-400"><span class="text-sm font-medium">yuni-q</span><span class="text-gray-400 dark:text-gray-500">·</span><span class="text-sm">2020년 1월 24일</span></div></div><div class="jsx-4115489982 post-content prose prose-lg max-w-none  prose-headings:font-semibold prose-p:leading-relaxed prose-a:text-blue-600 dark:prose-a:text-blue-400 prose-a:no-underline hover:prose-a:underline prose-strong:font-semibold prose-code:font-mono prose-code:text-sm prose-code:px-1 prose-code:py-0.5 prose-code:rounded prose-pre:bg-gray-900 dark:prose-pre:bg-gray-800 prose-blockquote:border-l-4 prose-blockquote:pl-4 prose-blockquote:italic prose-blockquote:my-6 prose-img:rounded-lg prose-img:shadow-md prose-table:w-full prose-ul:list-disc prose-ol:list-decimal prose-li:my-1"><ul>
<li>HTML부터 React까지의 제가 알고 있는 웹 프론트엔드 흐름에 대해 정리를 해보고자 합니다.</li>
<li>웹은 HTML, CSS, Javascript로 구성되어 있습니다. DART나 KOTLIN.JS, 웹어셈블리 등이 웹을 지원하기는 한다고 합니다.</li>
</ul>
<h2 id="html">HTML<a aria-hidden="true" tabindex="-1" href="#html"><span class="anchor"></span></a></h2>
<ul>
<li>가장 먼저 HTML은 HyperText Markup Language로 웹페이지를 기술하기 위한 마크업 언어입니다.</li>
<li>웹페이지의 내용과 구조를 담당하는 언어로써 태그를 통해 정보를 구조화하는 것입니다.</li>
<li>현재 사용 되고 있는 버전은 HTML5입니다.</li>
</ul>
<h2 id="css">CSS<a aria-hidden="true" tabindex="-1" href="#css"><span class="anchor"></span></a></h2>
<ul>
<li>CSS는 Cascading Style Sheets로 HTML이나 XML과 같은 구조화 된 문서를 화면에 어떻게 렌더링할 것인지를 정의하기 위한 언어입니다.</li>
<li>HTML5 이전 버전의 HTML에는 style을 컨트롤할 수 있는 태그 font, center 등이 존재하여 CSS가 없이도 어느 정도의 스타일 표현이 가능했지만, 정보와 구조를 담당하는 HTML의 본연의 역할과 동떨어진 기능까지 추가됨으로서 복잡하고 혼란스러운 언어가 되어 현재는 구분되어 사용하고 있습니다.</li>
<li>HTML과 CSS는 각자의 문법을 갖는 별개의 언어이며 HTML은 CSS를 포함할 수 있습니다. 그러나 HTML없이 단독으로 존재하는 CSS는 의미가 없습니다.</li>
<li>CSS는 기본 CSS말고도 sass, scss less, CSS-in-JS 등으로 활용 합니다.</li>
</ul>
<h2 id="javascript-역사">Javascript 역사<a aria-hidden="true" tabindex="-1" href="#javascript-역사"><span class="anchor"></span></a></h2>
<ul>
<li>자바스크립트는 1995년 당시 약 90%의 시장 점유율로 웹 브라우저 시장을 지배하고 있던 넷스케이프 커뮤니케이션즈에서 정적인 HTML을 동적으로 표현하기 위해 경량의 프로그래밍 언어를 도입하기로 결정했습니다. 그래서 탄생한 것이 브렌던 아이크가 개발한 자바스크립트입니다.</li>
<li>Javascript에서는 더글라스 크락포드, 니콜라스 자카스(ES LINT), 존 레식, 브렌던 아이크 4명이 영향력이 있는 사람이라고 합니다.</li>
<li>자바스크립트는 1996년 3월 넷스케이프 커뮤니케이션즈의 웹 브라우저인 Netscape Navigator 2에 탑재되었고 “Mocha”로 명명되었습니다. 그해 9월 “LiveScript”로 이름이 변경되었고, 12월 “JavaScript”로 최종 명명되었습니다.
<ul>
<li>Java와 구문이 유사하기도 하고 해서 이름을 JavaScript로 명명했다...는 표면상의 이유고 그 속은 Java의 유명세를 타서 묻어가려고 의도적으로 만든 것이라고 합니다.</li>
<li>이름의 최종 선정에 혼란이 야기되었는데 이 언어가 자바 프로그래밍 언어에서 파생되었다는 인상을 심었으며 이러한 선택이 마케팅적인 특징을 보였고 이는 넷스케이프가 당시 인기있는 웹 프로그래밍 언어로서 자바스크립트를 내밀기 위한 것이었습니다.</li>
<li>이는 사실 두 언어 모두 C 언어의 기본 구문에 바탕을 뒀기 비슷해 보이는 것이고, 실제로는 자바와 자바스크립트는 직접적인 관련성이 없습니다.</li>
<li>이름과 구문 외에는 자바보다 셀프나 스킴과 유사성이 많습니다.</li>
</ul>
</li>
<li>1996년 8월, 마이크로소프트는 자바스크립트의 파생 버전인 “JScript”를 Internet Explorer 3.0에 탑재하였습니다. 문제의 IE의 등장이네요. 그런데 문제는 JScript와 자바스크립트가 표준화되지 못하고 <code class="inline-code">적당히</code> 호환되었습니다. 즉, 자사 브라우저의 시장 점유율을 점유하기 위해 자사 브라우저에서만 동작하는 기능을 경쟁적으로 추가하기 시작했습니다. 이로 인해 브라우저에 따라 웹 페이지가 정상 동작하지 않는 크로스 브라우징 이슈가 발생하기 시작했고 모든 브라우저에서 동작하는 웹 페이지를 개발하는 것은 무척 어려워졌습니다. 이에 자바스크립트의 파편화를 방지하고 모든 브라우저에서 동일하게 동작하는 표준화된 자바스크립트에 대한 필요성이 제기되기 시작했습니다.</li>
<li>이를 위해 1996년 11월, 비영리 표준화 기구인 ECMA 인터내셔널에 자바스크립트의 표준화를 요청하였다. 1997년 7월, ECMA-262라 불리는 표준화된 자바스크립트 초판(ECMAScript 1)의 명세(specification)가 완성되었고 상표권 문제로 자바스크립트는 ECMAScript로 명명되었습니다.</li>
<li>당시 Sun사가 ‘JAVA‘라는 단어를 상표 등록을 해 놨기에 ‘JavaScript’라고 부를 수 없었습니다.</li>
<li>하지만 대외적으로 알리기 위해서 자바스크립트나 J스크립트라고 불렀다. 나중엔 표준 이나 구현 모두 ‘JavaScript’라는 이름으로 부르고 있습니다.</li>
<li>이후 1999년 ECMAScript 3(ES3)이 공개되었고 10년 만인 2009년 출시된 ECMAScript 5(ES5)는 HTML5와 함께 출현한 표준안입니다. ES4는 사라졌습니다.</li>
<li>2015년에는 ECMAScript 6인 ECMAScript 2015가 공개되었고 범용 프로그래밍 언어로서 갖추어야 할 기능들을 대거 도입하는 큰 변화가 있었다.</li>
<li>ES6 이후의 버전업은 작은 기능의 추가 레벨로 매년 공개할 것으로 예고되었다.</li>
<li>흔히 버전을 ES6+ 혹은 ES2015+로 표현하는데 매년 발표하기 때문에 연도를 붙여 말하는 것이 좀 더 권장 사항 입니다.</li>
<li>ECMA 표준에 등록되기 위해선 4가지 단계를 통과 할 필요가 있으며 최종 통과가 되지 않아도 바벨을 활용해 이용하거나 타입스크립트가 우선 지원하는 경우도 있습니다.</li>
<li>현재 웹 시장에서도 표준이 되지 않은 기능을 브라우저가 먼저 구현하고 프로포절에 던져놓는 경우가 많다고 합니다.</li>
</ul>
<h3 id="javascript의-발전">Javascript의 발전<a aria-hidden="true" tabindex="-1" href="#javascript의-발전"><span class="anchor"></span></a></h3>
<ul>
<li>초창기 자바스크립트는 웹 페이지의 보조적인 기능을 수행하기 위해 한정적인 용도로 사용 되었습니다.</li>
<li>이는 1999년, 자바스크립트를 이용해서 비동기적으로 서버와 브라우저가 데이터를 교환할 수 있는 통신 기능인 Ajax가 XMLHttpRequest이라는 이름으로 등장으로 인해 많은 것이 변화 하였습니다.</li>
<li>Ajax의 등장은 이전의 패러다임을 획기적으로 전환했습니다. 웹 페이지의 변경이 필요 없는 부분은 다시 렌더링하지 않고, 서버로부터 필요한 데이터만을 전송 받아 변경이 필요한 부분만을 한정적으로 렌더링하는 방식이 가능해졌습니다. 이로 인해 웹 브라우저에서도 데스크톱 애플리케이션과 유사한 빠른 퍼포먼스와 부드러운 화면 전환이 가능케 되었습니다.</li>
<li>2005년, 구글이 발표한 Google Maps는 웹 애플리케이션 개발 프로그래밍 언어로서 자바스크립트의 가능성을 확인하는 계기를 마련했습니다. 웹 브라우저에서 자바스크립트와 Ajax를 기반으로 동작하는 Google Maps가 데스크톱 애플리케이션과 비교해 손색이 없을 정도의 퍼포먼스와 부드러운 화면 전환 효과를 보여주었습니다.</li>
<li>2006년, jQuery의 등장으로 다소 번거롭고 논란이 있던 DOM(Document Object Model)을 보다 쉽게 제어할 수 있게 되었고 크로스 브라우징 이슈도 어느 정도 해결되었습니다. jQuery는 순식간에 넓은 사용자 층을 확보 했습니다. 이로 인해 당시 다소 까다로운 자바스크립트보다 배우기 쉽고 직관적인 jQuery를 더 선호하는 개발자가 양산되기도 했습니다.</li>
<li>요즘 프론트엔드를 시작한다면 jQuery는 피하는 것이 좋아 보입니다.</li>
<li>V8 자바스크립트 엔진의 등장으로 자바스크립트는 데스크톱 애플리케이션과 유사한 사용자 경험(user experience)을 제공할 수 있는 웹 애플리케이션 개발 프로그래밍 언어로 정착하게 되었습니다.</li>
<li>V8 자바스크립트 엔진으로 촉발된 자바스크립트의 발전으로 인해 과거 웹 서버에서 수행되던 역할들이 클라이언트(브라우저)로 이동하였고, 이로써 웹 애플리케이션에서 프런트엔드 영역이 주목받는 계기가 되었습니다.</li>
<li>2009년, 브라우저에서만 동작하던 자바스크립트를 브라우저 이외의 환경에서 동작시킬 수 있는 자바스크립트 실행 환경인 Node.js의 등장으로 자바스크립트는 웹 브라우저를 벗어나 서버 사이드 애플리케이션 개발에서도 사용되는 범용 프로그래밍 언어가 되었습니다.</li>
<li>웹 브라우저에서만 동작하는 반쪽짜리 프로그래밍 언어 취급을 받던 자바스크립트는 이제 프런트엔드 영역은 물론 백엔드 영역까지 아우르는 웹 프로그래밍 언어의 표준으로 자리잡고 있습니다. 람다에서 Node를 많이 활용하는 것 같습니다.</li>
<li>자바스크립트는 웹은 물론 모바일 하이브리드 앱, 서버 사이드, 데스크톱, 머신 러닝, 로보틱스 등 프로그래밍 언어로서 세계에서 가장 인기있는 프로그래밍 언어가 되었습니다. 이건 기준이 어디냐에 따라서 많이 다르더라구요. 본인이 믿고 싶은걸 믿으세요 !</li>
</ul>
<h3 id="javascript-사용처">Javascript 사용처<a aria-hidden="true" tabindex="-1" href="#javascript-사용처"><span class="anchor"></span></a></h3>
<ul>
<li>웹</li>
<li>모바일 하이브리드 앱(PhoneGap, Ionic)</li>
<li>모바일 하이브리드 앱(NativeScript, React Native)</li>
<li>서버 사이드(NodeJS)</li>
<li>데스크톱(Electron)</li>
<li>머신 러닝(TensorFlow.js)</li>
<li>로보틱스(Johnny-Five)</li>
</ul>
<h3 id="javascript-특징">Javascript 특징<a aria-hidden="true" tabindex="-1" href="#javascript-특징"><span class="anchor"></span></a></h3>
<ul>
<li>자바스크립트는 웹 브라우저에서 동작하는 유일한 프로그래밍 언어입니다(?) 이제는 확신이 없습니다.</li>
<li>자바스크립트는 개발자가 별도의 컴파일 작업을 수행하지 않는 인터프리터 언어입니다.</li>
<li>인터프리터는 소스코드를 즉시 실행하고 컴파일러는 빠르게 동작하는 머신 코드를 생성하고 최적화합니다. 이를 통해 컴파일 단계에서 추가적인 시간이 필요함에도 불구하고 보다 빠른 코드의 실행이 가능합니다.</li>
<li>자바스크립트는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어입니다.</li>
<li>클래스, 상속, 정보 은닉을 위한 키워드 private가 없어서 객체지향 언어가 아니라고 오해하는 경우도 있지만 자바스크립트는 클래스 기반 객체지향 언어보다 효율적이면서 강력한 프로토타입 기반의 객체지향 언어입니다.</li>
<li>클래스는 ES6에서 추가 되었습니다. 하지만 흔히들 신텍스 슈거로서 클래스를 흉내내고 있을 뿐이라고 하는데 일각에서는</li>
<li>클래스의 추가는 혁신적인 발전을 이뤘다고도 합니다.</li>
<li>또한 자바스크립트는 함수형 프로그래밍에 적합하지 않다고 하는 사람들도 있습니다.</li>
<li>이래저래 말이 많은 언어임은 확실합니다.</li>
</ul>
<h2 id="백본">백본<a aria-hidden="true" tabindex="-1" href="#백본"><span class="anchor"></span></a></h2>
<ul>
<li>백본은 2012 년쯤 혜성같이 등장한 Javascript MV* 프레임워크입니다.</li>
<li>나름 Angular 1 초창기에 대립구조를 가지다가 지금은 인지도가 많이 떨어진 프레임워크입니다.</li>
<li>전통적인 웹 개발 패러다임인 MVC 패턴에서 Controller를 별도로 구분하지 않고, View 에다가 뷰 이벤트 로직을 다 처리할 수 있는 구조 (MV*)로 구성이 되어있습니다.</li>
<li>기본적으로 화면 뒷단과의 통신은 JSON 기반의 REST API를 지원하고 있으며, 별도의 라이브러리들을 함께 구성하여 확장이 되게 편한 형태로 프레임워크가 구성되어 있습니다.</li>
<li>특히 Server Side 통신은 화면에서 간단히 Javascript API 사용했을 때, 기본적인 HTTP Request 요청을 모두 내부적으로 처리하여 Data Model에 담아주기 때문에, 서버 쪽에 관한 지식이 없는 프론트엔드 입문자분들께 더 편한 부분도 있다고 합니다.</li>
<li>배달의 민족으로 유명한 우아한 형제들에서도 Woowahan JS를 Backbone 기반으로 제작하였습니다.</li>
<li>하지만 이전보다는 많이 진일보했지만 아직 프레임워크라고 부르기에는 기능이 조금 부족합니다.</li>
<li>Backbone.js가 인기를 끌기 시작할때 제대로 된 프론트엔드 프레임워크들이 등장합니다. Ember, Knockout등이 등장하였는데 예전부터 각자의 프로젝트에서 활용하고 있던 것들을 잘 정리하여 오픈소스로 공개하였습니다. 이러한 프레임워크들은 소스사이즈가 컸고 성능은 무겁고 기능은 복잡하고 러닝커브는 마구 올라갔습니다. 뭔가 좋아보이기는 하는데 쓰기엔 너무 무거워 보였고 굳이 프론트엔드를 MVC로 구성해야 하는 생각도 듭니다.</li>
</ul>
<h2 id="웹-프론트엔드-3대장">웹 프론트엔드 3대장<a aria-hidden="true" tabindex="-1" href="#웹-프론트엔드-3대장"><span class="anchor"></span></a></h2>
<h3 id="앵귤러">앵귤러<a aria-hidden="true" tabindex="-1" href="#앵귤러"><span class="anchor"></span></a></h3>
<ul>
<li>앵귤러는 SPA 개발을 위한 구글의 오픈 소스 자바스크립트 프레임 워크 입니다.</li>
<li>앵귤러는 크게 앵귤러1인 앵귤러제이에스와 앵귤러2이상인 앵귤러로 구분 됩니다.</li>
<li>가장 큰 특징은 RxJS와 typescript를 기본으로 사용하며, 양방향 데이터 바인딩을 하며 리얼 돔을 사용합니다.</li>
<li>강대 했던 앵귤러가 무너진 이유는 후속 버전과의 호완선 문제가 빈번하게 발생하여 많은 혼란을 느껴 앵귤러제이에스 개발자가 앵귤러로 넘어가지 못한 점과 이 그 이후 에도 브레이킹 체인지가 너무 많았다는 점을 꼽곤 합니다.</li>
<li>버전 5 이후부터는 안정된 모습을 보인다고 합니다.</li>
<li>앵귤러는 웹 개발에 필요한 모든 것을 제공하기 때문에 높은 러닝 커브를 가지고 있습니다.</li>
</ul>
<h3 id="뷰">뷰<a aria-hidden="true" tabindex="-1" href="#뷰"><span class="anchor"></span></a></h3>
<ul>
<li>Vue는 Google의 전 개발자 Evan You에 의해 2014년 개발되었습니다.</li>
<li>문법이 단순하고 간결하여 초기 학습 비용이 낮고 누구나 쉽게 접근 가능합니다. 이 때문에 백엔드 개발자들이 어드민 개발에 많이 활용하는 거 같습니다.</li>
<li>대부분 Webpack 같은 모듈 번들러를 사용하여 프로젝트를 구성해야하는 앵귤러와 리액트와 달리, 단순히 CDN 에 있는 파일을 로딩 하는 형태로 스크립트를 불러와서 사용하기도 편합니다.</li>
<li>HTML을 템플릿처럼 그대로 사용 할 수도 있어서 마크업을 만들어주는 디자이너/퍼블리셔가 있는 경우 작업 흐름이 매우 매끄럽습니다. 이 부분은 앵귤러1을 차용한거 같습니다.</li>
<li>공식 라우터, 상태관리 라이브러리가 존재합니다.</li>
<li>vue라는 확장자를 사용하여 typescript와의 호완성이 좋지 못해서 typescript가 핫해진 근래에 조금 외면을 받은 경향도 있었습니다.
<ul>
<li>최근 3.0이 나오면서 typescript 지원을 한다고 합니다.</li>
</ul>
</li>
<li>양방향 데이터 바인딩을 기본으로 합니다. 하지만 컴포넌트 간 통신의 기본 골격은 React와 같이 단방향 데이터 흐름(부모 -> 자식)을 사용합니다.</li>
<li>다른 프런트엔드 프레임워크와 비교했을 때 상대적으로 가볍고 빠릅니다.</li>
</ul>
<h2 id="리액트">리액트<a aria-hidden="true" tabindex="-1" href="#리액트"><span class="anchor"></span></a></h2>
<ul>
<li>react는 Facebook이 만든 UI 컴포넌트 라이브러리입니다. 2013 년에 배포되었습니다.</li>
<li>MVC 패턴 중 V를 담당하고 있습니다.</li>
<li>컴포넌트 기반 아키텍처를 사용합니다.</li>
<li>babel의 도움으로 인해 JSX문법을 사용합니다.</li>
<li>Virtual DOM을 사용하여 성능향상을 도모 합니다.</li>
<li>단방향 데이터 흐름 지향 합니다.</li>
<li>React는 쉬우나 Redux가 어렵다는 말이 많이 있습니다.</li>
<li>프레임워크가 아닌 뷰라이브러리입니다.</li>
<li>HTTP 클라이언트, 라우터, 심화적 상태 관리 등의 기능들은 내장되어있지 않습니다</li>
<li>기본적으로 js를 사용하지만 ts 사용에도 문제가 없습니다. Jsx 확장자는 js와 tsx 확장자는 ts와 완벽히 호환합니다. 또한 라이브러리이기 때문에 다른 프레임워크와 함께 사용하거나 부분만 변경하는데에도 유연하게 적용할 수 있습니다.</li>
<li>최근 리액트 훅스에 도움으로 큰 변화가 생겼으나 리액트에서는 기존 문법을 무기한적으로 지원하기로 했습니다.</li>
<li>React의 단방향 데이터 바인딩은 일반적으로 예측 가능성이 높기 때문에 코드가 안정적이며 디버깅이 쉽습니다. 하지만, Angular의 전통적인 양방향 데이터 바인딩 또한 작업하기가 더 단순합니다.</li>
<li>리액트 라이브러리이기 때문에 리액트 라우터, 리덕스, 리덕스 사가, 모벡스, 넥스트 등 다양 서드 파티가 있고 이를 사용성에 맞게 적절하게 사용해야 합니다.</li>
</ul>
<h2 id="비교글">비교글<a aria-hidden="true" tabindex="-1" href="#비교글"><span class="anchor"></span></a></h2>
<ul>
<li>Angular는 모든 것이 준비된 주방으로우리의 Web App에 필요한 모든 tools와 재료들을 가지고 있다.만약 수 많은 개발자들이 일하는 거대한 회사라면,나는 모든 개발자들이 동일한 패턴으로 일을 하는 Angular를 좋아한다.</li>
<li>React는 oven (오븐) 이다. 케이크를 굽는 과정에서 분명히 추가적인 tools가 필요하지만 이것은 필요한 것을 만드는 과정에서 tools를 선택하는 유연함을 줄 수 있다. 내가 기술적인 회사에서 능력있는 몇몇 senior 개발자들과 함께 일을 하고 있다면 React는 좋은 선택이다.</li>
<li>Vue는 쉽고 효율적인 방법으로 요리를 정말 빠르게 만들 수 있다. 만약 startup 회사에서 새로 생긴 팀에서 엄격한 deadline을 가지고 있다면 나는 VueJS를 좋아할 것이다.</li>
</ul>
<h2 id="그-외">그 외<a aria-hidden="true" tabindex="-1" href="#그-외"><span class="anchor"></span></a></h2>
<ul>
<li>웹을 개발하기 위해선 프레임워크와 라이브러리들 이외에도 파일을 하나로 모아주는 웹팩, 자바스크립트 버전을 컨트롤 해주는 바벨, 자바스크립트에 부족함을 채워주는 타입스크립트에 대한 공부도 필요합니다.</li>
<li>그리고 서버사이드렌더링과 클라이언트사이드렌더랑과의 차이점과 SPA의 서버사이드 렌더링을 위한 학습도 필요합니다. 이에 따라 결국 서버와 인프라에 대한 공부가 필요 할수도 있습니다.</li>
<li>이 외에도 요즘에 갑작스럽게(?) 떠오른 스벨트, preact도 있습니다.</li>
<li>웹팩을 대신 할지도 모르는 파셀과 RESTAPI의 친구인 그라프큐엘을 지원하기 위한 아폴로에 대한 학습도 필요하게 될 수도 있습니다.</li>
<li>또한 모바일 웹, 반응형 웹, 적응형 웹, 웹뷰에 대한 지원도 필요합니다.</li>
<li>마지막으로 웹이 앱처럼 지원하기 위한 PWA와 PWA를 구글스토어에 배포하게 해주는 TWA라는 기술도 있습니다.</li>
</ul>
<h2 id="ppt">PPT<a aria-hidden="true" tabindex="-1" href="#ppt"><span class="anchor"></span></a></h2>
<ul>
<li><a href="https://speakerdeck.com/yuniq/frontend">FRONTEND</a>
<blockquote>
<p>[2020.01.11] ‘MASH-UP BACKEND’ 세미나에서 발표한 내용입니다. 프론트엔드를 공부하며 알게 되었던 부분들을 중심으로 HTML부터 React 이후까지 간랸한 이야기를 공유하였습니다.</p>
</blockquote>
</li>
</ul></div></div></div><div class="flex flex-col gap-5 my-10 max-w-4xl mx-auto px-4 xl:pr-[220px]"><div class="sponsor-button"><a class="flex items-center justify-center gap-3 px-6 py-3.5 bg-gradient-to-r from-amber-400 via-amber-500 to-amber-600 hover:from-amber-500 hover:via-amber-600 hover:to-amber-700 active:from-amber-600 active:via-amber-700 active:to-amber-800 text-white rounded-2xl transition-all duration-300 cursor-pointer border-0 shadow-lg hover:shadow-xl hover:scale-[1.02] active:scale-[0.98] font-semibold text-base no-underline" target="_blank" rel="noopener noreferrer" href="https://www.buymeacoffee.com/yuniq"><img src="https://www.buymeacoffee.com/assets/img/BMC-btn-logo.svg" alt="Buy me a coffee" class="w-7 h-7 flex-shrink-0"/><span>Buy me a coffee</span></a></div></div><div class="max-w-4xl mx-auto px-4 xl:pr-[220px]"><ins class="kakao_ad_area block" data-ad-unit="DAN-kkYIHzVbuDz3kYsq" data-ad-width="320" data-ad-height="50" style="width:320px;height:50px"></ins></div><div class="max-w-4xl mx-auto px-4 xl:pr-[220px]"><hr class="custom-hr"/></div><div class="my-8 max-w-4xl mx-auto px-4 xl:pr-[220px]"><div class="bio-container"><div class="author-description flex"><img class="bio-author-image" src="/images/profile.png" alt="yuni-q" width="72"/><div><span class="author-name-prefix text-[90%] mr-1">Written by</span><a class="author-name-content" href="/about/"><span>@<!-- -->yuni-q</span></a><div class="author-introduction mt-1 text-[80%] leading-[1.4]">yuni-q&#x27;s graffiti.</div><p class="author-socials mt-[-4px]"><a href="https://github.com/Yuni-Q" class="mr-2 text-[80%]">GitHub</a></p></div></div></div></div><div class="max-w-4xl mx-auto px-4 xl:pr-[220px]"><nav class="navigator my-8"><ul class="flex flex-col gap-4"><li><a rel="prev" class="block p-4 rounded-xl border border-gray-200 dark:border-gray-700 hover:border-blue-400 dark:hover:border-blue-500 hover:bg-blue-50 dark:hover:bg-blue-900/20 transition-all duration-200 group" href="/javascript/doublylinkedlist/"><div class="text-xs text-gray-500 dark:text-gray-400 mb-1 group-hover:text-blue-600 dark:group-hover:text-blue-400 transition-colors">이전 글</div><div class="text-sm font-medium text-gray-900 dark:text-gray-100 group-hover:text-blue-600 dark:group-hover:text-blue-400 transition-colors">← <!-- -->doublyLinkedList</div></a></li><li><a rel="next" class="block p-4 rounded-xl border border-gray-200 dark:border-gray-700 hover:border-blue-400 dark:hover:border-blue-500 hover:bg-blue-50 dark:hover:bg-blue-900/20 transition-all duration-200 group text-right" href="/frontend/height/"><div class="text-xs text-gray-500 dark:text-gray-400 mb-1 group-hover:text-blue-600 dark:group-hover:text-blue-400 transition-colors">다음 글</div><div class="text-sm font-medium text-gray-900 dark:text-gray-100 group-hover:text-blue-600 dark:group-hover:text-blue-400 transition-colors">height<!-- --> →</div></a></li></ul></nav></div><div class="max-w-4xl mx-auto px-4 xl:pr-[220px]"><div class="utterences"></div></div><footer class="pt-[52px] text-center text-xs">©<a href="https://github.com/Yuni-Q" class="no-underline">yuni-q</a>, Built with<!-- --> <a href="https://nextjs.org" class="no-underline">Next.js</a></footer></div><script src="/_next/static/chunks/webpack-57fdca2934e5ae0a.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/bc8bb31cb71603b2.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[1633,[],\"\"]\n5:I[808,[],\"\"]\n7:I[6217,[],\"\"]\n8:I[5217,[\"3185\",\"static/chunks/app/layout-3ad8bb7cb2292578.js\"],\"ServiceWorkerCleanup\"]\n9:I[6484,[\"3185\",\"static/chunks/app/layout-3ad8bb7cb2292578.js\"],\"ThemeProvider\"]\nb:I[7768,[],\"\"]\n6:[\"slug\",\"frontend/web-frontend\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[\"$\",\"$L2\",null,{\"buildId\":\"static-build-id\",\"assetPrefix\":\"\",\"urlParts\":[\"\",\"blog\",\"frontend\",\"web-frontend\",\"\"],\"initialTree\":[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"frontend/web-frontend\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"frontend\\\",\\\"web-frontend\\\"]}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"frontend/web-frontend\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\",null],null],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/bc8bb31cb71603b2.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"ko\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"preconnect\",\"href\":\"https://fonts.googleapis.com\"}],[\"$\",\"link\",null,{\"rel\":\"preconnect\",\"href\":\"https://fonts.gstatic.com\",\"crossOrigin\":\"anonymous\"}],[\"$\",\"link\",null,{\"href\":\"https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700\u0026display=swap\",\"rel\":\"stylesheet\"}],[\"$\",\"link\",null,{\"href\":\"https://fonts.googleapis.com/css2?family=Catamaran:wght@800\u0026display=swap\",\"rel\":\"stylesheet\"}],[\"$\",\"link\",null,{\"rel\":\"icon\",\"type\":\"image/png\",\"href\":\"/favicon2.png\"}],[\"$\",\"link\",null,{\"rel\":\"shortcut icon\",\"href\":\"/favicon2.png\"}],[\"$\",\"link\",null,{\"rel\":\"apple-touch-icon\",\"href\":\"/favicon2.png\"}],[\"$\",\"script\",null,{\"id\":\"ads\",\"async\":true,\"src\":\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"(adsbygoogle=window.adsbygoogle||[]).requestNonPersonalizedAds=1;\"}}]]}],[\"$\",\"body\",null,{\"children\":[[\"$\",\"noscript\",null,{\"children\":\"You need to enable JavaScript to run this app.\"}],[\"$\",\"$L8\",null,{}],[\"$\",\"$L9\",null,{\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[]}]}]]}]]}]],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]\n"])</script><script>self.__next_f.push([1,"d:I[5553,[\"9243\",\"static/chunks/9243-972bdccd4ceb11ae.js\",\"5800\",\"static/chunks/5800-4312aed1aa8a4305.js\",\"549\",\"static/chunks/549-2babc012700e23ed.js\",\"4853\",\"static/chunks/4853-73ca7990eb89674b.js\",\"6797\",\"static/chunks/app/blog/%5B...slug%5D/page-9b274a2e0073d544.js\"],\"BlogPostPageClient\"]\ne:T494e,"])</script><script>self.__next_f.push([1,"\n- HTML부터 React까지의 제가 알고 있는 웹 프론트엔드 흐름에 대해 정리를 해보고자 합니다.\n- 웹은 HTML, CSS, Javascript로 구성되어 있습니다. DART나 KOTLIN.JS, 웹어셈블리 등이 웹을 지원하기는 한다고 합니다.\n\n## HTML\n\n- 가장 먼저 HTML은 HyperText Markup Language로 웹페이지를 기술하기 위한 마크업 언어입니다.\n- 웹페이지의 내용과 구조를 담당하는 언어로써 태그를 통해 정보를 구조화하는 것입니다.\n- 현재 사용 되고 있는 버전은 HTML5입니다.\n\n## CSS\n\n- CSS는 Cascading Style Sheets로 HTML이나 XML과 같은 구조화 된 문서를 화면에 어떻게 렌더링할 것인지를 정의하기 위한 언어입니다.\n- HTML5 이전 버전의 HTML에는 style을 컨트롤할 수 있는 태그 font, center 등이 존재하여 CSS가 없이도 어느 정도의 스타일 표현이 가능했지만, 정보와 구조를 담당하는 HTML의 본연의 역할과 동떨어진 기능까지 추가됨으로서 복잡하고 혼란스러운 언어가 되어 현재는 구분되어 사용하고 있습니다.\n- HTML과 CSS는 각자의 문법을 갖는 별개의 언어이며 HTML은 CSS를 포함할 수 있습니다. 그러나 HTML없이 단독으로 존재하는 CSS는 의미가 없습니다.\n- CSS는 기본 CSS말고도 sass, scss less, CSS-in-JS 등으로 활용 합니다.\n\n## Javascript 역사\n\n- 자바스크립트는 1995년 당시 약 90%의 시장 점유율로 웹 브라우저 시장을 지배하고 있던 넷스케이프 커뮤니케이션즈에서 정적인 HTML을 동적으로 표현하기 위해 경량의 프로그래밍 언어를 도입하기로 결정했습니다. 그래서 탄생한 것이 브렌던 아이크가 개발한 자바스크립트입니다.\n- Javascript에서는 더글라스 크락포드, 니콜라스 자카스(ES LINT), 존 레식, 브렌던 아이크 4명이 영향력이 있는 사람이라고 합니다.\n- 자바스크립트는 1996년 3월 넷스케이프 커뮤니케이션즈의 웹 브라우저인 Netscape Navigator 2에 탑재되었고 “Mocha”로 명명되었습니다. 그해 9월 “LiveScript”로 이름이 변경되었고, 12월 “JavaScript”로 최종 명명되었습니다.\n  - Java와 구문이 유사하기도 하고 해서 이름을 JavaScript로 명명했다...는 표면상의 이유고 그 속은 Java의 유명세를 타서 묻어가려고 의도적으로 만든 것이라고 합니다.\n  - 이름의 최종 선정에 혼란이 야기되었는데 이 언어가 자바 프로그래밍 언어에서 파생되었다는 인상을 심었으며 이러한 선택이 마케팅적인 특징을 보였고 이는 넷스케이프가 당시 인기있는 웹 프로그래밍 언어로서 자바스크립트를 내밀기 위한 것이었습니다.\n  - 이는 사실 두 언어 모두 C 언어의 기본 구문에 바탕을 뒀기 비슷해 보이는 것이고, 실제로는 자바와 자바스크립트는 직접적인 관련성이 없습니다.\n  - 이름과 구문 외에는 자바보다 셀프나 스킴과 유사성이 많습니다.\n- 1996년 8월, 마이크로소프트는 자바스크립트의 파생 버전인 “JScript”를 Internet Explorer 3.0에 탑재하였습니다. 문제의 IE의 등장이네요. 그런데 문제는 JScript와 자바스크립트가 표준화되지 못하고 `적당히` 호환되었습니다. 즉, 자사 브라우저의 시장 점유율을 점유하기 위해 자사 브라우저에서만 동작하는 기능을 경쟁적으로 추가하기 시작했습니다. 이로 인해 브라우저에 따라 웹 페이지가 정상 동작하지 않는 크로스 브라우징 이슈가 발생하기 시작했고 모든 브라우저에서 동작하는 웹 페이지를 개발하는 것은 무척 어려워졌습니다. 이에 자바스크립트의 파편화를 방지하고 모든 브라우저에서 동일하게 동작하는 표준화된 자바스크립트에 대한 필요성이 제기되기 시작했습니다.\n- 이를 위해 1996년 11월, 비영리 표준화 기구인 ECMA 인터내셔널에 자바스크립트의 표준화를 요청하였다. 1997년 7월, ECMA-262라 불리는 표준화된 자바스크립트 초판(ECMAScript 1)의 명세(specification)가 완성되었고 상표권 문제로 자바스크립트는 ECMAScript로 명명되었습니다.\n- 당시 Sun사가 ‘JAVA‘라는 단어를 상표 등록을 해 놨기에 ‘JavaScript’라고 부를 수 없었습니다.\n- 하지만 대외적으로 알리기 위해서 자바스크립트나 J스크립트라고 불렀다. 나중엔 표준 이나 구현 모두 ‘JavaScript’라는 이름으로 부르고 있습니다.\n- 이후 1999년 ECMAScript 3(ES3)이 공개되었고 10년 만인 2009년 출시된 ECMAScript 5(ES5)는 HTML5와 함께 출현한 표준안입니다. ES4는 사라졌습니다.\n- 2015년에는 ECMAScript 6인 ECMAScript 2015가 공개되었고 범용 프로그래밍 언어로서 갖추어야 할 기능들을 대거 도입하는 큰 변화가 있었다.\n- ES6 이후의 버전업은 작은 기능의 추가 레벨로 매년 공개할 것으로 예고되었다.\n- 흔히 버전을 ES6+ 혹은 ES2015+로 표현하는데 매년 발표하기 때문에 연도를 붙여 말하는 것이 좀 더 권장 사항 입니다.\n- ECMA 표준에 등록되기 위해선 4가지 단계를 통과 할 필요가 있으며 최종 통과가 되지 않아도 바벨을 활용해 이용하거나 타입스크립트가 우선 지원하는 경우도 있습니다.\n- 현재 웹 시장에서도 표준이 되지 않은 기능을 브라우저가 먼저 구현하고 프로포절에 던져놓는 경우가 많다고 합니다.\n\n### Javascript의 발전\n\n- 초창기 자바스크립트는 웹 페이지의 보조적인 기능을 수행하기 위해 한정적인 용도로 사용 되었습니다.\n- 이는 1999년, 자바스크립트를 이용해서 비동기적으로 서버와 브라우저가 데이터를 교환할 수 있는 통신 기능인 Ajax가 XMLHttpRequest이라는 이름으로 등장으로 인해 많은 것이 변화 하였습니다.\n- Ajax의 등장은 이전의 패러다임을 획기적으로 전환했습니다. 웹 페이지의 변경이 필요 없는 부분은 다시 렌더링하지 않고, 서버로부터 필요한 데이터만을 전송 받아 변경이 필요한 부분만을 한정적으로 렌더링하는 방식이 가능해졌습니다. 이로 인해 웹 브라우저에서도 데스크톱 애플리케이션과 유사한 빠른 퍼포먼스와 부드러운 화면 전환이 가능케 되었습니다.\n- 2005년, 구글이 발표한 Google Maps는 웹 애플리케이션 개발 프로그래밍 언어로서 자바스크립트의 가능성을 확인하는 계기를 마련했습니다. 웹 브라우저에서 자바스크립트와 Ajax를 기반으로 동작하는 Google Maps가 데스크톱 애플리케이션과 비교해 손색이 없을 정도의 퍼포먼스와 부드러운 화면 전환 효과를 보여주었습니다.\n- 2006년, jQuery의 등장으로 다소 번거롭고 논란이 있던 DOM(Document Object Model)을 보다 쉽게 제어할 수 있게 되었고 크로스 브라우징 이슈도 어느 정도 해결되었습니다. jQuery는 순식간에 넓은 사용자 층을 확보 했습니다. 이로 인해 당시 다소 까다로운 자바스크립트보다 배우기 쉽고 직관적인 jQuery를 더 선호하는 개발자가 양산되기도 했습니다.\n- 요즘 프론트엔드를 시작한다면 jQuery는 피하는 것이 좋아 보입니다.\n- V8 자바스크립트 엔진의 등장으로 자바스크립트는 데스크톱 애플리케이션과 유사한 사용자 경험(user experience)을 제공할 수 있는 웹 애플리케이션 개발 프로그래밍 언어로 정착하게 되었습니다.\n- V8 자바스크립트 엔진으로 촉발된 자바스크립트의 발전으로 인해 과거 웹 서버에서 수행되던 역할들이 클라이언트(브라우저)로 이동하였고, 이로써 웹 애플리케이션에서 프런트엔드 영역이 주목받는 계기가 되었습니다.\n- 2009년, 브라우저에서만 동작하던 자바스크립트를 브라우저 이외의 환경에서 동작시킬 수 있는 자바스크립트 실행 환경인 Node.js의 등장으로 자바스크립트는 웹 브라우저를 벗어나 서버 사이드 애플리케이션 개발에서도 사용되는 범용 프로그래밍 언어가 되었습니다.\n- 웹 브라우저에서만 동작하는 반쪽짜리 프로그래밍 언어 취급을 받던 자바스크립트는 이제 프런트엔드 영역은 물론 백엔드 영역까지 아우르는 웹 프로그래밍 언어의 표준으로 자리잡고 있습니다. 람다에서 Node를 많이 활용하는 것 같습니다.\n- 자바스크립트는 웹은 물론 모바일 하이브리드 앱, 서버 사이드, 데스크톱, 머신 러닝, 로보틱스 등 프로그래밍 언어로서 세계에서 가장 인기있는 프로그래밍 언어가 되었습니다. 이건 기준이 어디냐에 따라서 많이 다르더라구요. 본인이 믿고 싶은걸 믿으세요 !\n\n### Javascript 사용처\n\n- 웹\n- 모바일 하이브리드 앱(PhoneGap, Ionic)\n- 모바일 하이브리드 앱(NativeScript, React Native)\n- 서버 사이드(NodeJS)\n- 데스크톱(Electron)\n- 머신 러닝(TensorFlow.js)\n- 로보틱스(Johnny-Five)\n\n### Javascript 특징\n\n- 자바스크립트는 웹 브라우저에서 동작하는 유일한 프로그래밍 언어입니다(?) 이제는 확신이 없습니다.\n- 자바스크립트는 개발자가 별도의 컴파일 작업을 수행하지 않는 인터프리터 언어입니다.\n- 인터프리터는 소스코드를 즉시 실행하고 컴파일러는 빠르게 동작하는 머신 코드를 생성하고 최적화합니다. 이를 통해 컴파일 단계에서 추가적인 시간이 필요함에도 불구하고 보다 빠른 코드의 실행이 가능합니다.\n- 자바스크립트는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어입니다.\n- 클래스, 상속, 정보 은닉을 위한 키워드 private가 없어서 객체지향 언어가 아니라고 오해하는 경우도 있지만 자바스크립트는 클래스 기반 객체지향 언어보다 효율적이면서 강력한 프로토타입 기반의 객체지향 언어입니다.\n- 클래스는 ES6에서 추가 되었습니다. 하지만 흔히들 신텍스 슈거로서 클래스를 흉내내고 있을 뿐이라고 하는데 일각에서는\n- 클래스의 추가는 혁신적인 발전을 이뤘다고도 합니다.\n- 또한 자바스크립트는 함수형 프로그래밍에 적합하지 않다고 하는 사람들도 있습니다.\n- 이래저래 말이 많은 언어임은 확실합니다.\n\n## 백본\n\n- 백본은 2012 년쯤 혜성같이 등장한 Javascript MV\\* 프레임워크입니다.\n- 나름 Angular 1 초창기에 대립구조를 가지다가 지금은 인지도가 많이 떨어진 프레임워크입니다.\n- 전통적인 웹 개발 패러다임인 MVC 패턴에서 Controller를 별도로 구분하지 않고, View 에다가 뷰 이벤트 로직을 다 처리할 수 있는 구조 (MV\\*)로 구성이 되어있습니다.\n- 기본적으로 화면 뒷단과의 통신은 JSON 기반의 REST API를 지원하고 있으며, 별도의 라이브러리들을 함께 구성하여 확장이 되게 편한 형태로 프레임워크가 구성되어 있습니다.\n- 특히 Server Side 통신은 화면에서 간단히 Javascript API 사용했을 때, 기본적인 HTTP Request 요청을 모두 내부적으로 처리하여 Data Model에 담아주기 때문에, 서버 쪽에 관한 지식이 없는 프론트엔드 입문자분들께 더 편한 부분도 있다고 합니다.\n- 배달의 민족으로 유명한 우아한 형제들에서도 Woowahan JS를 Backbone 기반으로 제작하였습니다.\n- 하지만 이전보다는 많이 진일보했지만 아직 프레임워크라고 부르기에는 기능이 조금 부족합니다.\n- Backbone.js가 인기를 끌기 시작할때 제대로 된 프론트엔드 프레임워크들이 등장합니다. Ember, Knockout등이 등장하였는데 예전부터 각자의 프로젝트에서 활용하고 있던 것들을 잘 정리하여 오픈소스로 공개하였습니다. 이러한 프레임워크들은 소스사이즈가 컸고 성능은 무겁고 기능은 복잡하고 러닝커브는 마구 올라갔습니다. 뭔가 좋아보이기는 하는데 쓰기엔 너무 무거워 보였고 굳이 프론트엔드를 MVC로 구성해야 하는 생각도 듭니다.\n\n## 웹 프론트엔드 3대장\n\n### 앵귤러\n\n- 앵귤러는 SPA 개발을 위한 구글의 오픈 소스 자바스크립트 프레임 워크 입니다.\n- 앵귤러는 크게 앵귤러1인 앵귤러제이에스와 앵귤러2이상인 앵귤러로 구분 됩니다.\n- 가장 큰 특징은 RxJS와 typescript를 기본으로 사용하며, 양방향 데이터 바인딩을 하며 리얼 돔을 사용합니다.\n- 강대 했던 앵귤러가 무너진 이유는 후속 버전과의 호완선 문제가 빈번하게 발생하여 많은 혼란을 느껴 앵귤러제이에스 개발자가 앵귤러로 넘어가지 못한 점과 이 그 이후 에도 브레이킹 체인지가 너무 많았다는 점을 꼽곤 합니다.\n- 버전 5 이후부터는 안정된 모습을 보인다고 합니다.\n- 앵귤러는 웹 개발에 필요한 모든 것을 제공하기 때문에 높은 러닝 커브를 가지고 있습니다.\n\n### 뷰\n\n- Vue는 Google의 전 개발자 Evan You에 의해 2014년 개발되었습니다.\n- 문법이 단순하고 간결하여 초기 학습 비용이 낮고 누구나 쉽게 접근 가능합니다. 이 때문에 백엔드 개발자들이 어드민 개발에 많이 활용하는 거 같습니다.\n- 대부분 Webpack 같은 모듈 번들러를 사용하여 프로젝트를 구성해야하는 앵귤러와 리액트와 달리, 단순히 CDN 에 있는 파일을 로딩 하는 형태로 스크립트를 불러와서 사용하기도 편합니다.\n- HTML을 템플릿처럼 그대로 사용 할 수도 있어서 마크업을 만들어주는 디자이너/퍼블리셔가 있는 경우 작업 흐름이 매우 매끄럽습니다. 이 부분은 앵귤러1을 차용한거 같습니다.\n- 공식 라우터, 상태관리 라이브러리가 존재합니다.\n- vue라는 확장자를 사용하여 typescript와의 호완성이 좋지 못해서 typescript가 핫해진 근래에 조금 외면을 받은 경향도 있었습니다.\n  - 최근 3.0이 나오면서 typescript 지원을 한다고 합니다.\n- 양방향 데이터 바인딩을 기본으로 합니다. 하지만 컴포넌트 간 통신의 기본 골격은 React와 같이 단방향 데이터 흐름(부모 -\u003e 자식)을 사용합니다.\n- 다른 프런트엔드 프레임워크와 비교했을 때 상대적으로 가볍고 빠릅니다.\n\n## 리액트\n\n- react는 Facebook이 만든 UI 컴포넌트 라이브러리입니다. 2013 년에 배포되었습니다.\n- MVC 패턴 중 V를 담당하고 있습니다.\n- 컴포넌트 기반 아키텍처를 사용합니다.\n- babel의 도움으로 인해 JSX문법을 사용합니다.\n- Virtual DOM을 사용하여 성능향상을 도모 합니다.\n- 단방향 데이터 흐름 지향 합니다.\n- React는 쉬우나 Redux가 어렵다는 말이 많이 있습니다.\n- 프레임워크가 아닌 뷰라이브러리입니다.\n- HTTP 클라이언트, 라우터, 심화적 상태 관리 등의 기능들은 내장되어있지 않습니다\n- 기본적으로 js를 사용하지만 ts 사용에도 문제가 없습니다. Jsx 확장자는 js와 tsx 확장자는 ts와 완벽히 호환합니다. 또한 라이브러리이기 때문에 다른 프레임워크와 함께 사용하거나 부분만 변경하는데에도 유연하게 적용할 수 있습니다.\n- 최근 리액트 훅스에 도움으로 큰 변화가 생겼으나 리액트에서는 기존 문법을 무기한적으로 지원하기로 했습니다.\n- React의 단방향 데이터 바인딩은 일반적으로 예측 가능성이 높기 때문에 코드가 안정적이며 디버깅이 쉽습니다. 하지만, Angular의 전통적인 양방향 데이터 바인딩 또한 작업하기가 더 단순합니다.\n- 리액트 라이브러리이기 때문에 리액트 라우터, 리덕스, 리덕스 사가, 모벡스, 넥스트 등 다양 서드 파티가 있고 이를 사용성에 맞게 적절하게 사용해야 합니다.\n\n## 비교글\n\n- Angular는 모든 것이 준비된 주방으로우리의 Web App에 필요한 모든 tools와 재료들을 가지고 있다.만약 수 많은 개발자들이 일하는 거대한 회사라면,나는 모든 개발자들이 동일한 패턴으로 일을 하는 Angular를 좋아한다.\n- React는 oven (오븐) 이다. 케이크를 굽는 과정에서 분명히 추가적인 tools가 필요하지만 이것은 필요한 것을 만드는 과정에서 tools를 선택하는 유연함을 줄 수 있다. 내가 기술적인 회사에서 능력있는 몇몇 senior 개발자들과 함께 일을 하고 있다면 React는 좋은 선택이다.\n- Vue는 쉽고 효율적인 방법으로 요리를 정말 빠르게 만들 수 있다. 만약 startup 회사에서 새로 생긴 팀에서 엄격한 deadline을 가지고 있다면 나는 VueJS를 좋아할 것이다.\n\n## 그 외\n\n- 웹을 개발하기 위해선 프레임워크와 라이브러리들 이외에도 파일을 하나로 모아주는 웹팩, 자바스크립트 버전을 컨트롤 해주는 바벨, 자바스크립트에 부족함을 채워주는 타입스크립트에 대한 공부도 필요합니다.\n- 그리고 서버사이드렌더링과 클라이언트사이드렌더랑과의 차이점과 SPA의 서버사이드 렌더링을 위한 학습도 필요합니다. 이에 따라 결국 서버와 인프라에 대한 공부가 필요 할수도 있습니다.\n- 이 외에도 요즘에 갑작스럽게(?) 떠오른 스벨트, preact도 있습니다.\n- 웹팩을 대신 할지도 모르는 파셀과 RESTAPI의 친구인 그라프큐엘을 지원하기 위한 아폴로에 대한 학습도 필요하게 될 수도 있습니다.\n- 또한 모바일 웹, 반응형 웹, 적응형 웹, 웹뷰에 대한 지원도 필요합니다.\n- 마지막으로 웹이 앱처럼 지원하기 위한 PWA와 PWA를 구글스토어에 배포하게 해주는 TWA라는 기술도 있습니다.\n\n## PPT\n\n- [FRONTEND](https://speakerdeck.com/yuniq/frontend)\n  \u003e [2020.01.11] ‘MASH-UP BACKEND’ 세미나에서 발표한 내용입니다. 프론트엔드를 공부하며 알게 되었던 부분들을 중심으로 HTML부터 React 이후까지 간랸한 이야기를 공유하였습니다.\n"])</script><script>self.__next_f.push([1,"f:T52e2,"])</script><script>self.__next_f.push([1,"\u003cul\u003e\n\u003cli\u003eHTML부터 React까지의 제가 알고 있는 웹 프론트엔드 흐름에 대해 정리를 해보고자 합니다.\u003c/li\u003e\n\u003cli\u003e웹은 HTML, CSS, Javascript로 구성되어 있습니다. DART나 KOTLIN.JS, 웹어셈블리 등이 웹을 지원하기는 한다고 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"html\"\u003eHTML\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#html\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e가장 먼저 HTML은 HyperText Markup Language로 웹페이지를 기술하기 위한 마크업 언어입니다.\u003c/li\u003e\n\u003cli\u003e웹페이지의 내용과 구조를 담당하는 언어로써 태그를 통해 정보를 구조화하는 것입니다.\u003c/li\u003e\n\u003cli\u003e현재 사용 되고 있는 버전은 HTML5입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"css\"\u003eCSS\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#css\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eCSS는 Cascading Style Sheets로 HTML이나 XML과 같은 구조화 된 문서를 화면에 어떻게 렌더링할 것인지를 정의하기 위한 언어입니다.\u003c/li\u003e\n\u003cli\u003eHTML5 이전 버전의 HTML에는 style을 컨트롤할 수 있는 태그 font, center 등이 존재하여 CSS가 없이도 어느 정도의 스타일 표현이 가능했지만, 정보와 구조를 담당하는 HTML의 본연의 역할과 동떨어진 기능까지 추가됨으로서 복잡하고 혼란스러운 언어가 되어 현재는 구분되어 사용하고 있습니다.\u003c/li\u003e\n\u003cli\u003eHTML과 CSS는 각자의 문법을 갖는 별개의 언어이며 HTML은 CSS를 포함할 수 있습니다. 그러나 HTML없이 단독으로 존재하는 CSS는 의미가 없습니다.\u003c/li\u003e\n\u003cli\u003eCSS는 기본 CSS말고도 sass, scss less, CSS-in-JS 등으로 활용 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"javascript-역사\"\u003eJavascript 역사\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#javascript-역사\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e자바스크립트는 1995년 당시 약 90%의 시장 점유율로 웹 브라우저 시장을 지배하고 있던 넷스케이프 커뮤니케이션즈에서 정적인 HTML을 동적으로 표현하기 위해 경량의 프로그래밍 언어를 도입하기로 결정했습니다. 그래서 탄생한 것이 브렌던 아이크가 개발한 자바스크립트입니다.\u003c/li\u003e\n\u003cli\u003eJavascript에서는 더글라스 크락포드, 니콜라스 자카스(ES LINT), 존 레식, 브렌던 아이크 4명이 영향력이 있는 사람이라고 합니다.\u003c/li\u003e\n\u003cli\u003e자바스크립트는 1996년 3월 넷스케이프 커뮤니케이션즈의 웹 브라우저인 Netscape Navigator 2에 탑재되었고 “Mocha”로 명명되었습니다. 그해 9월 “LiveScript”로 이름이 변경되었고, 12월 “JavaScript”로 최종 명명되었습니다.\n\u003cul\u003e\n\u003cli\u003eJava와 구문이 유사하기도 하고 해서 이름을 JavaScript로 명명했다...는 표면상의 이유고 그 속은 Java의 유명세를 타서 묻어가려고 의도적으로 만든 것이라고 합니다.\u003c/li\u003e\n\u003cli\u003e이름의 최종 선정에 혼란이 야기되었는데 이 언어가 자바 프로그래밍 언어에서 파생되었다는 인상을 심었으며 이러한 선택이 마케팅적인 특징을 보였고 이는 넷스케이프가 당시 인기있는 웹 프로그래밍 언어로서 자바스크립트를 내밀기 위한 것이었습니다.\u003c/li\u003e\n\u003cli\u003e이는 사실 두 언어 모두 C 언어의 기본 구문에 바탕을 뒀기 비슷해 보이는 것이고, 실제로는 자바와 자바스크립트는 직접적인 관련성이 없습니다.\u003c/li\u003e\n\u003cli\u003e이름과 구문 외에는 자바보다 셀프나 스킴과 유사성이 많습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e1996년 8월, 마이크로소프트는 자바스크립트의 파생 버전인 “JScript”를 Internet Explorer 3.0에 탑재하였습니다. 문제의 IE의 등장이네요. 그런데 문제는 JScript와 자바스크립트가 표준화되지 못하고 \u003ccode class=\"inline-code\"\u003e적당히\u003c/code\u003e 호환되었습니다. 즉, 자사 브라우저의 시장 점유율을 점유하기 위해 자사 브라우저에서만 동작하는 기능을 경쟁적으로 추가하기 시작했습니다. 이로 인해 브라우저에 따라 웹 페이지가 정상 동작하지 않는 크로스 브라우징 이슈가 발생하기 시작했고 모든 브라우저에서 동작하는 웹 페이지를 개발하는 것은 무척 어려워졌습니다. 이에 자바스크립트의 파편화를 방지하고 모든 브라우저에서 동일하게 동작하는 표준화된 자바스크립트에 대한 필요성이 제기되기 시작했습니다.\u003c/li\u003e\n\u003cli\u003e이를 위해 1996년 11월, 비영리 표준화 기구인 ECMA 인터내셔널에 자바스크립트의 표준화를 요청하였다. 1997년 7월, ECMA-262라 불리는 표준화된 자바스크립트 초판(ECMAScript 1)의 명세(specification)가 완성되었고 상표권 문제로 자바스크립트는 ECMAScript로 명명되었습니다.\u003c/li\u003e\n\u003cli\u003e당시 Sun사가 ‘JAVA‘라는 단어를 상표 등록을 해 놨기에 ‘JavaScript’라고 부를 수 없었습니다.\u003c/li\u003e\n\u003cli\u003e하지만 대외적으로 알리기 위해서 자바스크립트나 J스크립트라고 불렀다. 나중엔 표준 이나 구현 모두 ‘JavaScript’라는 이름으로 부르고 있습니다.\u003c/li\u003e\n\u003cli\u003e이후 1999년 ECMAScript 3(ES3)이 공개되었고 10년 만인 2009년 출시된 ECMAScript 5(ES5)는 HTML5와 함께 출현한 표준안입니다. ES4는 사라졌습니다.\u003c/li\u003e\n\u003cli\u003e2015년에는 ECMAScript 6인 ECMAScript 2015가 공개되었고 범용 프로그래밍 언어로서 갖추어야 할 기능들을 대거 도입하는 큰 변화가 있었다.\u003c/li\u003e\n\u003cli\u003eES6 이후의 버전업은 작은 기능의 추가 레벨로 매년 공개할 것으로 예고되었다.\u003c/li\u003e\n\u003cli\u003e흔히 버전을 ES6+ 혹은 ES2015+로 표현하는데 매년 발표하기 때문에 연도를 붙여 말하는 것이 좀 더 권장 사항 입니다.\u003c/li\u003e\n\u003cli\u003eECMA 표준에 등록되기 위해선 4가지 단계를 통과 할 필요가 있으며 최종 통과가 되지 않아도 바벨을 활용해 이용하거나 타입스크립트가 우선 지원하는 경우도 있습니다.\u003c/li\u003e\n\u003cli\u003e현재 웹 시장에서도 표준이 되지 않은 기능을 브라우저가 먼저 구현하고 프로포절에 던져놓는 경우가 많다고 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"javascript의-발전\"\u003eJavascript의 발전\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#javascript의-발전\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e초창기 자바스크립트는 웹 페이지의 보조적인 기능을 수행하기 위해 한정적인 용도로 사용 되었습니다.\u003c/li\u003e\n\u003cli\u003e이는 1999년, 자바스크립트를 이용해서 비동기적으로 서버와 브라우저가 데이터를 교환할 수 있는 통신 기능인 Ajax가 XMLHttpRequest이라는 이름으로 등장으로 인해 많은 것이 변화 하였습니다.\u003c/li\u003e\n\u003cli\u003eAjax의 등장은 이전의 패러다임을 획기적으로 전환했습니다. 웹 페이지의 변경이 필요 없는 부분은 다시 렌더링하지 않고, 서버로부터 필요한 데이터만을 전송 받아 변경이 필요한 부분만을 한정적으로 렌더링하는 방식이 가능해졌습니다. 이로 인해 웹 브라우저에서도 데스크톱 애플리케이션과 유사한 빠른 퍼포먼스와 부드러운 화면 전환이 가능케 되었습니다.\u003c/li\u003e\n\u003cli\u003e2005년, 구글이 발표한 Google Maps는 웹 애플리케이션 개발 프로그래밍 언어로서 자바스크립트의 가능성을 확인하는 계기를 마련했습니다. 웹 브라우저에서 자바스크립트와 Ajax를 기반으로 동작하는 Google Maps가 데스크톱 애플리케이션과 비교해 손색이 없을 정도의 퍼포먼스와 부드러운 화면 전환 효과를 보여주었습니다.\u003c/li\u003e\n\u003cli\u003e2006년, jQuery의 등장으로 다소 번거롭고 논란이 있던 DOM(Document Object Model)을 보다 쉽게 제어할 수 있게 되었고 크로스 브라우징 이슈도 어느 정도 해결되었습니다. jQuery는 순식간에 넓은 사용자 층을 확보 했습니다. 이로 인해 당시 다소 까다로운 자바스크립트보다 배우기 쉽고 직관적인 jQuery를 더 선호하는 개발자가 양산되기도 했습니다.\u003c/li\u003e\n\u003cli\u003e요즘 프론트엔드를 시작한다면 jQuery는 피하는 것이 좋아 보입니다.\u003c/li\u003e\n\u003cli\u003eV8 자바스크립트 엔진의 등장으로 자바스크립트는 데스크톱 애플리케이션과 유사한 사용자 경험(user experience)을 제공할 수 있는 웹 애플리케이션 개발 프로그래밍 언어로 정착하게 되었습니다.\u003c/li\u003e\n\u003cli\u003eV8 자바스크립트 엔진으로 촉발된 자바스크립트의 발전으로 인해 과거 웹 서버에서 수행되던 역할들이 클라이언트(브라우저)로 이동하였고, 이로써 웹 애플리케이션에서 프런트엔드 영역이 주목받는 계기가 되었습니다.\u003c/li\u003e\n\u003cli\u003e2009년, 브라우저에서만 동작하던 자바스크립트를 브라우저 이외의 환경에서 동작시킬 수 있는 자바스크립트 실행 환경인 Node.js의 등장으로 자바스크립트는 웹 브라우저를 벗어나 서버 사이드 애플리케이션 개발에서도 사용되는 범용 프로그래밍 언어가 되었습니다.\u003c/li\u003e\n\u003cli\u003e웹 브라우저에서만 동작하는 반쪽짜리 프로그래밍 언어 취급을 받던 자바스크립트는 이제 프런트엔드 영역은 물론 백엔드 영역까지 아우르는 웹 프로그래밍 언어의 표준으로 자리잡고 있습니다. 람다에서 Node를 많이 활용하는 것 같습니다.\u003c/li\u003e\n\u003cli\u003e자바스크립트는 웹은 물론 모바일 하이브리드 앱, 서버 사이드, 데스크톱, 머신 러닝, 로보틱스 등 프로그래밍 언어로서 세계에서 가장 인기있는 프로그래밍 언어가 되었습니다. 이건 기준이 어디냐에 따라서 많이 다르더라구요. 본인이 믿고 싶은걸 믿으세요 !\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"javascript-사용처\"\u003eJavascript 사용처\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#javascript-사용처\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e웹\u003c/li\u003e\n\u003cli\u003e모바일 하이브리드 앱(PhoneGap, Ionic)\u003c/li\u003e\n\u003cli\u003e모바일 하이브리드 앱(NativeScript, React Native)\u003c/li\u003e\n\u003cli\u003e서버 사이드(NodeJS)\u003c/li\u003e\n\u003cli\u003e데스크톱(Electron)\u003c/li\u003e\n\u003cli\u003e머신 러닝(TensorFlow.js)\u003c/li\u003e\n\u003cli\u003e로보틱스(Johnny-Five)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"javascript-특징\"\u003eJavascript 특징\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#javascript-특징\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e자바스크립트는 웹 브라우저에서 동작하는 유일한 프로그래밍 언어입니다(?) 이제는 확신이 없습니다.\u003c/li\u003e\n\u003cli\u003e자바스크립트는 개발자가 별도의 컴파일 작업을 수행하지 않는 인터프리터 언어입니다.\u003c/li\u003e\n\u003cli\u003e인터프리터는 소스코드를 즉시 실행하고 컴파일러는 빠르게 동작하는 머신 코드를 생성하고 최적화합니다. 이를 통해 컴파일 단계에서 추가적인 시간이 필요함에도 불구하고 보다 빠른 코드의 실행이 가능합니다.\u003c/li\u003e\n\u003cli\u003e자바스크립트는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어입니다.\u003c/li\u003e\n\u003cli\u003e클래스, 상속, 정보 은닉을 위한 키워드 private가 없어서 객체지향 언어가 아니라고 오해하는 경우도 있지만 자바스크립트는 클래스 기반 객체지향 언어보다 효율적이면서 강력한 프로토타입 기반의 객체지향 언어입니다.\u003c/li\u003e\n\u003cli\u003e클래스는 ES6에서 추가 되었습니다. 하지만 흔히들 신텍스 슈거로서 클래스를 흉내내고 있을 뿐이라고 하는데 일각에서는\u003c/li\u003e\n\u003cli\u003e클래스의 추가는 혁신적인 발전을 이뤘다고도 합니다.\u003c/li\u003e\n\u003cli\u003e또한 자바스크립트는 함수형 프로그래밍에 적합하지 않다고 하는 사람들도 있습니다.\u003c/li\u003e\n\u003cli\u003e이래저래 말이 많은 언어임은 확실합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"백본\"\u003e백본\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#백본\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e백본은 2012 년쯤 혜성같이 등장한 Javascript MV* 프레임워크입니다.\u003c/li\u003e\n\u003cli\u003e나름 Angular 1 초창기에 대립구조를 가지다가 지금은 인지도가 많이 떨어진 프레임워크입니다.\u003c/li\u003e\n\u003cli\u003e전통적인 웹 개발 패러다임인 MVC 패턴에서 Controller를 별도로 구분하지 않고, View 에다가 뷰 이벤트 로직을 다 처리할 수 있는 구조 (MV*)로 구성이 되어있습니다.\u003c/li\u003e\n\u003cli\u003e기본적으로 화면 뒷단과의 통신은 JSON 기반의 REST API를 지원하고 있으며, 별도의 라이브러리들을 함께 구성하여 확장이 되게 편한 형태로 프레임워크가 구성되어 있습니다.\u003c/li\u003e\n\u003cli\u003e특히 Server Side 통신은 화면에서 간단히 Javascript API 사용했을 때, 기본적인 HTTP Request 요청을 모두 내부적으로 처리하여 Data Model에 담아주기 때문에, 서버 쪽에 관한 지식이 없는 프론트엔드 입문자분들께 더 편한 부분도 있다고 합니다.\u003c/li\u003e\n\u003cli\u003e배달의 민족으로 유명한 우아한 형제들에서도 Woowahan JS를 Backbone 기반으로 제작하였습니다.\u003c/li\u003e\n\u003cli\u003e하지만 이전보다는 많이 진일보했지만 아직 프레임워크라고 부르기에는 기능이 조금 부족합니다.\u003c/li\u003e\n\u003cli\u003eBackbone.js가 인기를 끌기 시작할때 제대로 된 프론트엔드 프레임워크들이 등장합니다. Ember, Knockout등이 등장하였는데 예전부터 각자의 프로젝트에서 활용하고 있던 것들을 잘 정리하여 오픈소스로 공개하였습니다. 이러한 프레임워크들은 소스사이즈가 컸고 성능은 무겁고 기능은 복잡하고 러닝커브는 마구 올라갔습니다. 뭔가 좋아보이기는 하는데 쓰기엔 너무 무거워 보였고 굳이 프론트엔드를 MVC로 구성해야 하는 생각도 듭니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"웹-프론트엔드-3대장\"\u003e웹 프론트엔드 3대장\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#웹-프론트엔드-3대장\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003ch3 id=\"앵귤러\"\u003e앵귤러\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#앵귤러\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e앵귤러는 SPA 개발을 위한 구글의 오픈 소스 자바스크립트 프레임 워크 입니다.\u003c/li\u003e\n\u003cli\u003e앵귤러는 크게 앵귤러1인 앵귤러제이에스와 앵귤러2이상인 앵귤러로 구분 됩니다.\u003c/li\u003e\n\u003cli\u003e가장 큰 특징은 RxJS와 typescript를 기본으로 사용하며, 양방향 데이터 바인딩을 하며 리얼 돔을 사용합니다.\u003c/li\u003e\n\u003cli\u003e강대 했던 앵귤러가 무너진 이유는 후속 버전과의 호완선 문제가 빈번하게 발생하여 많은 혼란을 느껴 앵귤러제이에스 개발자가 앵귤러로 넘어가지 못한 점과 이 그 이후 에도 브레이킹 체인지가 너무 많았다는 점을 꼽곤 합니다.\u003c/li\u003e\n\u003cli\u003e버전 5 이후부터는 안정된 모습을 보인다고 합니다.\u003c/li\u003e\n\u003cli\u003e앵귤러는 웹 개발에 필요한 모든 것을 제공하기 때문에 높은 러닝 커브를 가지고 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"뷰\"\u003e뷰\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#뷰\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eVue는 Google의 전 개발자 Evan You에 의해 2014년 개발되었습니다.\u003c/li\u003e\n\u003cli\u003e문법이 단순하고 간결하여 초기 학습 비용이 낮고 누구나 쉽게 접근 가능합니다. 이 때문에 백엔드 개발자들이 어드민 개발에 많이 활용하는 거 같습니다.\u003c/li\u003e\n\u003cli\u003e대부분 Webpack 같은 모듈 번들러를 사용하여 프로젝트를 구성해야하는 앵귤러와 리액트와 달리, 단순히 CDN 에 있는 파일을 로딩 하는 형태로 스크립트를 불러와서 사용하기도 편합니다.\u003c/li\u003e\n\u003cli\u003eHTML을 템플릿처럼 그대로 사용 할 수도 있어서 마크업을 만들어주는 디자이너/퍼블리셔가 있는 경우 작업 흐름이 매우 매끄럽습니다. 이 부분은 앵귤러1을 차용한거 같습니다.\u003c/li\u003e\n\u003cli\u003e공식 라우터, 상태관리 라이브러리가 존재합니다.\u003c/li\u003e\n\u003cli\u003evue라는 확장자를 사용하여 typescript와의 호완성이 좋지 못해서 typescript가 핫해진 근래에 조금 외면을 받은 경향도 있었습니다.\n\u003cul\u003e\n\u003cli\u003e최근 3.0이 나오면서 typescript 지원을 한다고 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e양방향 데이터 바인딩을 기본으로 합니다. 하지만 컴포넌트 간 통신의 기본 골격은 React와 같이 단방향 데이터 흐름(부모 -\u003e 자식)을 사용합니다.\u003c/li\u003e\n\u003cli\u003e다른 프런트엔드 프레임워크와 비교했을 때 상대적으로 가볍고 빠릅니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"리액트\"\u003e리액트\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#리액트\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003ereact는 Facebook이 만든 UI 컴포넌트 라이브러리입니다. 2013 년에 배포되었습니다.\u003c/li\u003e\n\u003cli\u003eMVC 패턴 중 V를 담당하고 있습니다.\u003c/li\u003e\n\u003cli\u003e컴포넌트 기반 아키텍처를 사용합니다.\u003c/li\u003e\n\u003cli\u003ebabel의 도움으로 인해 JSX문법을 사용합니다.\u003c/li\u003e\n\u003cli\u003eVirtual DOM을 사용하여 성능향상을 도모 합니다.\u003c/li\u003e\n\u003cli\u003e단방향 데이터 흐름 지향 합니다.\u003c/li\u003e\n\u003cli\u003eReact는 쉬우나 Redux가 어렵다는 말이 많이 있습니다.\u003c/li\u003e\n\u003cli\u003e프레임워크가 아닌 뷰라이브러리입니다.\u003c/li\u003e\n\u003cli\u003eHTTP 클라이언트, 라우터, 심화적 상태 관리 등의 기능들은 내장되어있지 않습니다\u003c/li\u003e\n\u003cli\u003e기본적으로 js를 사용하지만 ts 사용에도 문제가 없습니다. Jsx 확장자는 js와 tsx 확장자는 ts와 완벽히 호환합니다. 또한 라이브러리이기 때문에 다른 프레임워크와 함께 사용하거나 부분만 변경하는데에도 유연하게 적용할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e최근 리액트 훅스에 도움으로 큰 변화가 생겼으나 리액트에서는 기존 문법을 무기한적으로 지원하기로 했습니다.\u003c/li\u003e\n\u003cli\u003eReact의 단방향 데이터 바인딩은 일반적으로 예측 가능성이 높기 때문에 코드가 안정적이며 디버깅이 쉽습니다. 하지만, Angular의 전통적인 양방향 데이터 바인딩 또한 작업하기가 더 단순합니다.\u003c/li\u003e\n\u003cli\u003e리액트 라이브러리이기 때문에 리액트 라우터, 리덕스, 리덕스 사가, 모벡스, 넥스트 등 다양 서드 파티가 있고 이를 사용성에 맞게 적절하게 사용해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"비교글\"\u003e비교글\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#비교글\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eAngular는 모든 것이 준비된 주방으로우리의 Web App에 필요한 모든 tools와 재료들을 가지고 있다.만약 수 많은 개발자들이 일하는 거대한 회사라면,나는 모든 개발자들이 동일한 패턴으로 일을 하는 Angular를 좋아한다.\u003c/li\u003e\n\u003cli\u003eReact는 oven (오븐) 이다. 케이크를 굽는 과정에서 분명히 추가적인 tools가 필요하지만 이것은 필요한 것을 만드는 과정에서 tools를 선택하는 유연함을 줄 수 있다. 내가 기술적인 회사에서 능력있는 몇몇 senior 개발자들과 함께 일을 하고 있다면 React는 좋은 선택이다.\u003c/li\u003e\n\u003cli\u003eVue는 쉽고 효율적인 방법으로 요리를 정말 빠르게 만들 수 있다. 만약 startup 회사에서 새로 생긴 팀에서 엄격한 deadline을 가지고 있다면 나는 VueJS를 좋아할 것이다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"그-외\"\u003e그 외\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#그-외\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e웹을 개발하기 위해선 프레임워크와 라이브러리들 이외에도 파일을 하나로 모아주는 웹팩, 자바스크립트 버전을 컨트롤 해주는 바벨, 자바스크립트에 부족함을 채워주는 타입스크립트에 대한 공부도 필요합니다.\u003c/li\u003e\n\u003cli\u003e그리고 서버사이드렌더링과 클라이언트사이드렌더랑과의 차이점과 SPA의 서버사이드 렌더링을 위한 학습도 필요합니다. 이에 따라 결국 서버와 인프라에 대한 공부가 필요 할수도 있습니다.\u003c/li\u003e\n\u003cli\u003e이 외에도 요즘에 갑작스럽게(?) 떠오른 스벨트, preact도 있습니다.\u003c/li\u003e\n\u003cli\u003e웹팩을 대신 할지도 모르는 파셀과 RESTAPI의 친구인 그라프큐엘을 지원하기 위한 아폴로에 대한 학습도 필요하게 될 수도 있습니다.\u003c/li\u003e\n\u003cli\u003e또한 모바일 웹, 반응형 웹, 적응형 웹, 웹뷰에 대한 지원도 필요합니다.\u003c/li\u003e\n\u003cli\u003e마지막으로 웹이 앱처럼 지원하기 위한 PWA와 PWA를 구글스토어에 배포하게 해주는 TWA라는 기술도 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"ppt\"\u003ePPT\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#ppt\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://speakerdeck.com/yuniq/frontend\"\u003eFRONTEND\u003c/a\u003e\n\u003cblockquote\u003e\n\u003cp\u003e[2020.01.11] ‘MASH-UP BACKEND’ 세미나에서 발표한 내용입니다. 프론트엔드를 공부하며 알게 되었던 부분들을 중심으로 HTML부터 React 이후까지 간랸한 이야기를 공유하였습니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003c/ul\u003e"])</script><script>self.__next_f.push([1,"4:[\"$\",\"$Ld\",null,{\"post\":{\"slug\":\"/frontend/web-frontend\",\"frontmatter\":{\"title\":\"WEB FRONTEND\",\"date\":\"2020-01-24T23:01:46.000Z\",\"category\":\"frontend\",\"draft\":false},\"content\":\"$e\",\"html\":\"$f\",\"excerpt\":\"- HTML부터 React까지의 제가 알고 있는 웹 프론트엔드 흐름에 대해 정리를 해보고자 합니다. - 웹은 HTML, CSS, Javascript로 구성되어 있습니다. DART나 KOTLIN.JS, 웹어셈블리 등이 웹을 지원하기는 한다고 합니다.  ## HTML  - 가장 먼저 HTML은 HyperText Markup Language로 웹페이지를 기술하\"},\"previousPost\":{\"slug\":\"/javascript/doublylinkedlist\",\"frontmatter\":{\"title\":\"doublyLinkedList\",\"date\":\"2020-01-24T23:01:14.000Z\",\"category\":\"javascript\",\"draft\":false}},\"nextPost\":{\"slug\":\"/frontend/height\",\"frontmatter\":{\"title\":\"height\",\"date\":\"2020-01-26T14:01:28.000Z\",\"category\":\"frontend\",\"draft\":false}}}]\na:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"WEB FRONTEND\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"- HTML부터 React까지의 제가 알고 있는 웹 프론트엔드 흐름에 대해 정리를 해보고자 합니다. - 웹은 HTML, CSS, Javascript로 구성되어 있습니다. DART나 KOTLIN.JS, 웹어셈블리 등이 웹을 지원하기는 한다고 합니다.  ## HTML  - 가장 먼저 HTML은 HyperText Markup Language로 웹페이지를 기술하\"}]]\n3:null\n"])</script></body></html>