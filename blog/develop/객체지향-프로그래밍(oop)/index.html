<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" as="image" href="https://www.buymeacoffee.com/assets/img/BMC-btn-logo.svg"/><link rel="preload" as="image" href="/images/profile.png"/><link rel="stylesheet" href="/_next/static/css/bc8bb31cb71603b2.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-57fdca2934e5ae0a.js"/><script src="/_next/static/chunks/6217bb07-738e49d824771fea.js" async=""></script><script src="/_next/static/chunks/5647-b33901b11da845dc.js" async=""></script><script src="/_next/static/chunks/main-app-ec1611f00934714e.js" async=""></script><script src="/_next/static/chunks/app/layout-3ad8bb7cb2292578.js" async=""></script><script src="/_next/static/chunks/9243-972bdccd4ceb11ae.js" async=""></script><script src="/_next/static/chunks/5800-4312aed1aa8a4305.js" async=""></script><script src="/_next/static/chunks/549-2babc012700e23ed.js" async=""></script><script src="/_next/static/chunks/4853-73ca7990eb89674b.js" async=""></script><script src="/_next/static/chunks/app/blog/%5B...slug%5D/page-9b274a2e0073d544.js" async=""></script><script id="ads" async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><title>객체지향 프로그래밍(OOP)</title><meta name="description" content="- 객체지향 프로그래밍은 컴퓨터 프로그래밍 패러다임(견해, 사고법)의 하나로, 프로그래밍에서 필요한 데이터를 추상화 시켜서 상태(속성, 어트리뷰트)와 행위(메서드)를 가진 객체로 만들고, 그 객체간의 상호작용을 통해 로직을 구성하는 방법입니다. - 객체지향 애플리케이션의 중심 사상은 연쇄적으로 메시지를 전송하고 수신하는 객체들 사이의 협력 관계를 기반으로"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"/><link rel="icon" type="image/png" href="/favicon2.png"/><link rel="shortcut icon" href="/favicon2.png"/><link rel="apple-touch-icon" href="/favicon2.png"/><link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&amp;display=swap" rel="stylesheet"/><link href="https://fonts.googleapis.com/css2?family=Catamaran:wght@800&amp;display=swap" rel="stylesheet"/><script>(adsbygoogle=window.adsbygoogle||[]).requestNonPersonalizedAds=1;</script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body><noscript>You need to enable JavaScript to run this app.</noscript><div class="top-header"><a class="top-link" href="/">Yuni-Q</a><div class="flex items-center"><button class="outline-0 bg-white mx-[5px] p-0 appearance-none items-center rounded-[5px] border-0 cursor-pointer inline-flex h-10 justify-center opacity-75 overflow-hidden relative scale-75 transition-opacity duration-300 ease-in-out w-10 flex-shrink-0 hover:bg-black max-[800px]:hover:bg-white"><a href="https://github.com/Yuni-Q/blog" class="github" aria-label="GitHub"><svg class="github transition-all duration-300 ease-in-out pt-1 text-[#78757a] w-8 hover:text-white max-[800px]:hover:text-[#78757a]" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg></a></button><button class="outline-0 bg-white mx-[5px] p-0 appearance-none items-center rounded-[5px] border-0 cursor-pointer inline-flex h-10 justify-center opacity-75 overflow-hidden relative scale-75 transition-opacity duration-300 ease-in-out w-10 flex-shrink-0 hover:bg-black max-[800px]:hover:bg-white group"><div class="theme1 rounded-full h-6 relative w-6 transition-all duration-[450ms] ease-in-out bg-[#78757a]" style="border:none;overflow:visible;transform:scale(0.55)"><div class="absolute rounded-full h-6 w-6 transition-transform duration-[450ms] ease-in-out" style="border:none;opacity:0;right:-9px;top:-9px;transform:translate(14px, -14px);background:#78757a"></div><div class="absolute rounded-full h-2 w-2 left-1/2 top-1/2 transition-all duration-[350ms] ease-in-out" style="box-shadow:0 -23px 0 #78757a, 0 23px 0 #78757a, 23px 0 0 #78757a, -23px 0 0 #78757a, 15px 15px 0 #78757a, -15px 15px 0 #78757a, 15px -15px 0 #78757a, -15px -15px 0 #78757a;transform:scale(1);margin:-4px 0px 0px -4px"></div></div><div class="theme2 rounded-full border-0 h-6 absolute right-0 top-0 w-6 transition-all duration-[450ms] ease-in-out" style="background:none;opacity:0;transform:translate(14px, -14px)"></div></button><button class="outline-0 bg-white mx-[5px] p-0 appearance-none items-center rounded-[5px] border-0 cursor-pointer inline-flex h-10 justify-center opacity-75 overflow-hidden relative scale-75 transition-opacity duration-300 ease-in-out w-10 flex-shrink-0 hover:bg-black max-[800px]:hover:bg-white group"><svg class="snow transition-all duration-300 ease-in-out w-7 group-hover:fill-white max-[800px]:group-hover:fill-[#78757a]" style="fill:#78757a" version="1.1" id="레이어_1" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 0 23.9 22.9"><path d="M23.9,10c0-0.3-0.2-0.5-0.4-0.6l-1.1-0.3C22.1,9.1,22,9,21.9,8.8c-0.1-0.2,0-0.4,0.1-0.6l0.8-0.9       c0.2-0.2,0.2-0.5,0-0.7c-1.2-1.4-3.1-2-5-1.4c-0.4,0.1-0.9,0.4-1.4,0.7c0.1-0.6,0.2-1.1,0.2-1.6c0-1.9-1.2-3.6-2.9-4.3       c-0.2-0.1-0.5,0-0.7,0.2l-0.6,1c-0.1,0.2-0.3,0.3-0.5,0.3c-0.2,0-0.4-0.1-0.5-0.3l-0.6-1C10.7,0,10.4-0.1,10.2,0       C8.5,0.7,7.3,2.4,7.3,4.3c0,0.5,0.1,1,0.2,1.6C7,5.6,6.5,5.4,6.1,5.2c-1.8-0.6-3.8,0-5,1.4c-0.2,0.2-0.2,0.5,0,0.7l0.8,0.9       C2,8.4,2.1,8.6,2,8.8c0,0.2-0.2,0.3-0.4,0.4L0.4,9.5C0.2,9.5,0,9.8,0,10c0.1,1.8,1.4,3.5,3.2,4c0.4,0.1,1,0.2,1.5,0.3       c-0.4,0.4-0.8,0.8-1.1,1.1c-1.1,1.6-1.2,3.6-0.2,5.2c0.1,0.2,0.4,0.3,0.7,0.2l1.1-0.4c0.2-0.1,0.4-0.1,0.6,0C6,20.6,6,20.8,6,21.1       l-0.1,1.2c0,0.3,0.2,0.5,0.4,0.6c1.8,0.4,3.7-0.2,4.8-1.8c0.3-0.4,0.5-0.8,0.8-1.4c0.2,0.5,0.5,1,0.8,1.4c1.1,1.6,3.1,2.2,4.8,1.8       c0.3-0.1,0.4-0.3,0.4-0.6l-0.1-1.2c0-0.3,0.1-0.4,0.2-0.5c0.1-0.1,0.3-0.1,0.6,0l1.1,0.4c0.2,0.1,0.5,0,0.7-0.2       c1-1.6,0.9-3.6-0.2-5.2c-0.3-0.4-0.6-0.8-1.1-1.1c0.6-0.1,1.1-0.2,1.5-0.3C22.6,13.5,23.8,11.8,23.9,10z M14.1,12.8       c0.3-0.2,0.7-0.3,1.1-0.1c0.4,0.3,0.6,0.8,0.3,1.3c-0.3,0.4-0.8,0.6-1.3,0.3c-0.3-0.2-0.5-0.6-0.4-1l-1.4-0.8v1.6       c0.4,0.1,0.6,0.5,0.6,0.9c0,0.5-0.4,0.9-0.9,0.9c-0.5,0-0.9-0.4-0.9-0.9c0-0.4,0.3-0.7,0.6-0.9v-1.6l-1.4,0.8c0.1,0.4-0.1,0.8-0.4,1       c-0.4,0.3-1,0.1-1.3-0.3c-0.3-0.4-0.1-1,0.3-1.3c0.3-0.2,0.8-0.1,1.1,0.1l1.4-0.8L10,11.1c-0.3,0.2-0.7,0.3-1.1,0.1       C8.5,11,8.3,10.4,8.6,10c0.3-0.4,0.8-0.6,1.3-0.3c0.3,0.2,0.5,0.6,0.4,1l1.4,0.8V9.8c-0.4-0.1-0.6-0.5-0.6-0.9C11.1,8.4,11.5,8,12,8       c0.5,0,0.9,0.4,0.9,0.9c0,0.4-0.3,0.7-0.6,0.9v1.6l1.4-0.8c-0.1-0.4,0.1-0.8,0.4-1c0.4-0.3,1-0.1,1.3,0.3c0.3,0.4,0.1,1-0.3,1.3       c-0.3,0.2-0.8,0.1-1.1-0.1l-1.4,0.8L14.1,12.8z"></path></svg></button><a class="w-[30px] h-[30px] leading-[30px] mx-[5px] text-black flex-shrink-0 flex items-center justify-center" href="/search/">검색</a></div></div><div class="layout-content" style="margin-right:0;max-width:none"><div class="mb-6 max-w-4xl mx-auto px-4 xl:pr-[220px]"><ins class="adsbygoogle block min-w-[320px] min-h-0 mx-auto bg-gray-300" data-ad-client="ca-pub-2667251850399676" data-ad-slot="9586629994" data-ad-format="auto" data-full-width-responsive="true"></ins></div><div class="relative"><div class="max-w-4xl mx-auto px-4 xl:pr-[220px]"><h1 class="text-4xl md:text-5xl font-extrabold mb-6 leading-tight text-gray-900 dark:text-gray-100">객체지향 프로그래밍(OOP)</h1><div class="flex flex-col gap-4 mb-8"><div class="flex items-center gap-2 text-gray-600 dark:text-gray-400"><span class="text-sm font-medium">yuni-q</span><span class="text-gray-400 dark:text-gray-500">·</span><span class="text-sm">2020년 7월 21일</span></div></div><div class="jsx-4115489982 post-content prose prose-lg max-w-none  prose-headings:font-semibold prose-p:leading-relaxed prose-a:text-blue-600 dark:prose-a:text-blue-400 prose-a:no-underline hover:prose-a:underline prose-strong:font-semibold prose-code:font-mono prose-code:text-sm prose-code:px-1 prose-code:py-0.5 prose-code:rounded prose-pre:bg-gray-900 dark:prose-pre:bg-gray-800 prose-blockquote:border-l-4 prose-blockquote:pl-4 prose-blockquote:italic prose-blockquote:my-6 prose-img:rounded-lg prose-img:shadow-md prose-table:w-full prose-ul:list-disc prose-ol:list-decimal prose-li:my-1"><ul>
<li>객체지향 프로그래밍은 컴퓨터 프로그래밍 패러다임(견해, 사고법)의 하나로, 프로그래밍에서 필요한 데이터를 추상화 시켜서 상태(속성, 어트리뷰트)와 행위(메서드)를 가진 객체로 만들고, 그 객체간의 상호작용을 통해 로직을 구성하는 방법입니다.</li>
<li>객체지향 애플리케이션의 중심 사상은 연쇄적으로 메시지를 전송하고 수신하는 객체들 사이의 협력 관계를 기반으로 사용자에게 유용한 기능을 제공하는 것입니다. 객체지향의 강력함은 객체들이 주고받는 메시지로부터 나옵니다. 객체지향의 애플리케이션은 클래스를 이용해 만들어지지만 메시지를 통해 정의됩니다.</li>
<li>객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 부과되는 규율입니다.</li>
</ul>
<h2 id="자율적인-책임">자율적인 책임<a aria-hidden="true" tabindex="-1" href="#자율적인-책임"><span class="anchor"></span></a></h2>
<ul>
<li>객체지향 공동체를 구성하는 기본 단위는 <code class="inline-code">자율적인 객체</code>입니다.</li>
<li>자율적인 객체란 스스로 정한 원칙에 따라 판단하고 스스로의 의지를 기반으로 행동하는 객체입니다. 객체가 어떤 행동을 하는 유일한 이유는 다른 객체로부터 요청을 수신했기 때문입니다. <code class="inline-code">요청을 처리하기 위해 객체가 수행하는 행동</code>을 책임이라고 합니다.</li>
<li>적절한 책임이 자율적인 객체를 낳고, 자율적인 객체들이 모여 유연하고 단순한 협력을 낳습니다. 따라서 <code class="inline-code">협력에 참여하는 객체가 얼마나 자율적인지가 전체 어플리케이션의 품질을 결정합니다</code>. 객체가 책임을 자율적으로 수행하기 위해서는 객체에게 할당되는 책임이 자율적이어야 합니다. 책임이 자율적이지 않다면 객체가 아무리 발버둥친다고 하더라도 자율적으로 책임을 수행하기 어렵습니다.</li>
<li>자율적인 책임의 특징은 객체가 어떻게해야 하는가가 아니라 <code class="inline-code">무엇을 해야하는가</code>를 설명한다는 것입니다. 책임이라는 말 속에는 어떤 행동을 수행한다는 의미가 포함돼 있습니다. 객체지향 공동체 안에 거주하는 객체는 다른 객체로부터 전송된 요청을 수신할 때만 어떤 행동을 시작합니다.</li>
<li>사실 객체가 다른 객체에게 접근할 수 있는 유일한 방법은 요청을 전송하는 것뿐입니다. 그리고 이 요청을 우리는 메시지라고 부릅니다. 메시지는 객체로 하여금 자신의 책임, 즉 행동을 수행하게 만드는 유일한 방법입니다.</li>
<li>성급한 일반화의 오류를 피하고 현재의 문맥에 가장 적합한 책임을 선택할 수 있는 날카로운 안목이 필요합니다.</li>
</ul>
<h2 id="메시지와-메서드">메시지와 메서드<a aria-hidden="true" tabindex="-1" href="#메시지와-메서드"><span class="anchor"></span></a></h2>
<ul>
<li>하나의 객체는 메시지를 전송함으로써 다른 객체에 접근합니다.</li>
<li>객체의 행동을 유발하는 행위를 가리켜 메시지-전송이라고 합니다.</li>
<li>메시지-전송 메커니즘은 객체가 다른 객체에 접근할 수 있는 유일한 방법입니다.</li>
<li>객체가 제공하는 메시지는 외부의 다른 객체가 볼 수 있는 공개된 영역에 속합니다. 메시지를 처리하기 위해 책임을 수행하는 방법은 외부의 다른 객체가 볼 수 없는 객체 자신의 사적인 영역에 속합니다. 객체가 유일하게 이해할 수 있는 의사소통 수단은 메시지뿐이며 객체는 메시지를 처리하기 위한 방법을 자율적으로 선택할 수 있습니다.</li>
<li>메시지가 '어떻게' 수행될 것인지는 명시하지 않습니다. 메시지는 단지 오퍼레이션을 통해 <code class="inline-code">무엇</code>이 실행되기를 바라는지만 명시하며, 어떤 메서드를 선택할 것인지는 전적으로 수신자의 결정에 좌우됩니다</li>
</ul>
<h2 id="다형성">다형성<a aria-hidden="true" tabindex="-1" href="#다형성"><span class="anchor"></span></a></h2>
<ul>
<li>다형성이란 서로 다른 유형의 객체가 동일한 메시지에 대해 서로 다르게 반응하는 것을 의미합니다.</li>
<li>서로 다른 타입에 속하는 객체들이 동일한 메시지를 수신할 경우 서로 다른 메서드를 이용해 메시를 이용해 메시지를 처리할 수 있는 메커니즘을 가리킵니다.</li>
<li>다형성은 역할, 책임, 협력과 깊은 관련이 있습니다. 서로 다른 객체들이 다형성을 만족시킨다는 것은 객체들이 동일한 책임을 공유한다는 것을 의미합니다. 메시지 수신자들이 동일한 오퍼레이션을 서로 다른 방식으로 처리하더라도 메시지 송신자의 관점에서 이 객체들은 동일한 책임을 수행하는 것입니다. 즉, 송신자의 관점에서 다형적인 수신자들을 구별할 필요가 없으며 자신의 요청을 수행할 책임을 지닌다는 점에서 모두 동일합니다.</li>
<li>다형성은 객체들의 대체 가능성을 이용해 설계를 유연하고 재사용 가능하게 만듭니다. 다형성을 사용하면 송신자가 수신자의 종류를 모르더라도 메시지를 전송할 수 있습니다. 즉, 다형성은 수신자의 종류를 캡슐화합니다.</li>
<li>객체지향 패러다임이 강력한 이유는 다형성을 이용해 협력을 유연하게 만들수 있기 때문입니다.</li>
</ul>
<h2 id="메시지를-따라라">메시지를 따라라<a aria-hidden="true" tabindex="-1" href="#메시지를-따라라"><span class="anchor"></span></a></h2>
<ul>
<li>객체지향 애플리케이션의 중심 사상은 연쇄적으로 메시지를 전송하고 수신하는 객체들 사이의 협력 관계를 기반으로 사용자에게 유용한 기능을 제공하는 것입니다. 클래스 기반의 객체지향 언어를 사용하는 대부분의 사람들은 객체지향 애플리케이션을 클래스의 집합으로 생각합니다. 프로그래머 입장에서는 클래스는 실제로 볼 수 있고 수정할 수 있는 구체적인 존재입니다. 대부분의 입문자들은 클래스 간의 상속 관계가 객체지향 설계를 가치 있게 만드는 핵심적인 매커니즘이라고 배웁니다. 하지만 객체지향의 강력함은 클래스가 아니라 객체들이 주고받는 메시지로부터 나옵니다. <code class="inline-code">객체지향의 애플리케이션은 클래스를 이용해 만들어지지만 메시지를 통해 정의됩니다</code>.</li>
<li>실제로 애플리케이션을 살아있게 만드는 것은 클래스가 아니라 <code class="inline-code">객체</code>입니다. 그리고 이런 객체들의 윤곽을 결정하는 것이 바로 객체들이 주고받는 메시지입니다. 클래스를 정의하는 것이 먼저가 아니라 객체들의 속성과 행위를 식별하는 것이 먼저입니다. 클래스는 객체의 속성과 행위를 담는 틀일 뿐입니다.</li>
<li>객체 자체에 초점을 맞출 경우 가장 흔히 범하게 되는 실수는 협력이라는 문맥을 배제한 채 객체 내부의 데이터 구조를 먼저 생각한 후 데이터 조작에 필요한 오퍼레이션을 나중에 고려하는 것입니다.</li>
<li>훌륭한 객체지향 설계는 어떤 객체가 어떤 메시지를 전송할 수 있는가와 어떤 객체가 어떤 메시지를 이해할 수 있는가를 중심으로 객체 사이의 협력 관계를 구성하는 것입니다.</li>
<li>객체지향 설계의 중심에는 메시지가 위치합니다. 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하게 해야 합니다. 객체지향 시스템은 협력하는 객체들의 연결망입니다.</li>
</ul>
<h2 id="객체-인터페이스-구현의-분리">객체 인터페이스, 구현의 분리<a aria-hidden="true" tabindex="-1" href="#객체-인터페이스-구현의-분리"><span class="anchor"></span></a></h2>
<ul>
<li>객체의 인터페이스는 객체가 수신할 수 있는 메시지의 목록으로 구성되며 객체가 어떤 메시지를 수신할 수 있는지가 제공하는 인터페이스의 모양을 빚습니다. 이때는 3가지의 원칙이 필요합니다.
<ul>
<li>좀 더 추상적인 인터페이스를 통해 수신자의 자율성을 보장합니다.</li>
<li>외부에서 사용할 필요가 없는 인터페이스는 최대한 노출하지 않습니다.</li>
<li>인터페이스와 구현 간에 차이가 있습니다.</li>
</ul>
</li>
<li>객체가 가져야 할 상태와 메서드 구현은 객체 내부에 속합니다. 이 부분을 수정하더라도 객체 외부에 영향을 미쳐서는 안됩니다. 객체 외부에 영향을 미치는 변경은 객체의 공용 인터페이스를 수정할 때 뿐입니다. 이렇게 인터페이스와 구현의 분리 원칙은 변경을 관리하기 위한 것입니다. 느슨한 인터페이스에 대해서만 결합되도록 만드는 것입니다.</li>
<li>인터페이스를 제외한 구현부를 외부로 부터 감추는 것을 <code class="inline-code">캡슐화</code>라고 합니다. 객체는 상태와 행위를 함께 캡슐화함으로써 충분히 협력적이고 만족스러울 정도로 자율적인 존재가 될 수 있습니다. 캡슐화를 <code class="inline-code">정보의 은닉</code>이라고 부르기도 합니다.</li>
</ul>
<h2 id="객체가-자율적인-책임을-갖는-것이-중요한-이유">객체가 자율적인 책임을 갖는 것이 중요한 이유<a aria-hidden="true" tabindex="-1" href="#객체가-자율적인-책임을-갖는-것이-중요한-이유"><span class="anchor"></span></a></h2>
<ul>
<li>책임의 자율성이 협력의 품질을 결정합니다.
<ul>
<li>객체의 책임이 자율적일수록 협력이 이해하기 쉬워지고 유연하게 변경할 수 있게 됩니다. 결과적으로 책임이 얼마나 자율적인지가 전체적인 협력의 설계 품질을 결정하게 됩니다.</li>
</ul>
</li>
<li>자율적인 책임은 협력을 단순하게 만듭니다.</li>
<li>자율적인 책임은 외부와 내부를 명확하게 분리합니다.</li>
<li>책임이 자율적일 경우 책임을 수행하는 내부적인 방법을 변경하더라도 외부에 영향을 미치지 않습니다.(결합도가 낮아집니다)</li>
<li>자율적인 책임은 협력의 대상을 다양하게 선택할 수 있는 유연성을 제공합니다.</li>
<li>객체가 수행하는 책임들이 자율적일수록 객체의 역할을 이해하기 쉬워집니다.</li>
<li>책임이 자율적일수록 적절하게 추상화되며, 응집도가 높아지고, 결합도가 낮아지며, 캡슐화가 증진되고, 인터페이스와 구현이 명확히 분리되며, 설계의 유연성과 재사용성이 향상됩니다.</li>
<li>객체지향의 강력함을 누리기 위한 출발점은 책임을 자율적으로 만드는 것입니다.</li>
</ul>
<h2 id="장점">장점<a aria-hidden="true" tabindex="-1" href="#장점"><span class="anchor"></span></a></h2>
<ul>
<li>다른 클래스를 가져와 사용할 수 있고, 상속받을 수 있어 코드의 재사용성이 높습니다.</li>
<li>절차지향보다 유지보수가 간단하고 수정에 용이합니다.</li>
<li>클래스 단위로 모듈화가 가능하여, 대형 프로젝트에 적합합니다.</li>
</ul>
<h2 id="단점">단점<a aria-hidden="true" tabindex="-1" href="#단점"><span class="anchor"></span></a></h2>
<ul>
<li>처리속도가 상대적으로 느립니다.</li>
<li>객체가 많으면 용량이 커집니다.</li>
<li>설계시 많은 노력과 시간이 필요합니다.</li>
</ul>
<h2 id="oop의-6가지-키워드">OOP의 6가지 키워드<a aria-hidden="true" tabindex="-1" href="#oop의-6가지-키워드"><span class="anchor"></span></a></h2>
<h3 id="클래스">클래스<a aria-hidden="true" tabindex="-1" href="#클래스"><span class="anchor"></span></a></h3>
<ul>
<li>현실 세계의 객체를 추상화시켜, 속성과 메서드로 정의한 것입니다.(논리적 개념)</li>
</ul>
<h3 id="인스턴스">인스턴스<a aria-hidden="true" tabindex="-1" href="#인스턴스"><span class="anchor"></span></a></h3>
<ul>
<li>클래스에서 정의한 것을 토대로 만든 실제 메모리상에 할당된 것, 실제 데이터 입니다.</li>
</ul>
<h3 id="추상화">추상화<a aria-hidden="true" tabindex="-1" href="#추상화"><span class="anchor"></span></a></h3>
<ul>
<li>객체지향 관점에서 클래스를 정의하는 것입니다. 불필요한 정보 외 중요한 정보만 표현함으로써 공통의 속성과 기능을 묶어 이름을 붙이는 것입니다.</li>
</ul>
<h3 id="캡슐화">캡슐화<a aria-hidden="true" tabindex="-1" href="#캡슐화"><span class="anchor"></span></a></h3>
<ul>
<li>코드를 수정없이 재활용 하는 것을 목적으로 합니다. 클래스라는 캡슐에 기능과 특성을 담아 묶습니다. 목적을 기준으로 묶습니다</li>
<li>은닉화와의 차이 : 은닉화는 캡슐화의 일부라고 볼 수 있으며, 목적으로 묶인 캡슐 안을 사용자는 볼 수 없다는 것이 은닉화 입니다.</li>
</ul>
<h3 id="상속">상속<a aria-hidden="true" tabindex="-1" href="#상속"><span class="anchor"></span></a></h3>
<ul>
<li>클래스로부터 속성과 메서드를 물려받는 것입니다. 다른 클래스를 가져와서 수정할 일이 있다면, 그 클래스를 직접 수정하는 대신 상속을 받아 변경하고자 하는 부분만 변경합니다.</li>
</ul>
<h3 id="다형성-1">다형성<a aria-hidden="true" tabindex="-1" href="#다형성-1"><span class="anchor"></span></a></h3>
<ul>
<li>하나의 변수명이나 함수명이 상황에 따라 다르게 해석될 수 있습니다. 대표적인 다형성이 오버라이딩과 오버로딩 입니다.</li>
</ul>
<h2 id="oop의-5가지-법칙-solid">OOP의 5가지 법칙 (SOLID)<a aria-hidden="true" tabindex="-1" href="#oop의-5가지-법칙-solid"><span class="anchor"></span></a></h2>
<h3 id="single-responsibility-principle-단일-책임-법칙">Single Responsibility Principle, 단일 책임 법칙<a aria-hidden="true" tabindex="-1" href="#single-responsibility-principle-단일-책임-법칙"><span class="anchor"></span></a></h3>
<ul>
<li>각 클래스는 목적을 하나씩만 가지고 그에 대한 책임을 져야 합니다.</li>
</ul>
<h3 id="open-close-principle-개방-폐쇄-법칙">Open Close Principle, 개방 폐쇄 법칙<a aria-hidden="true" tabindex="-1" href="#open-close-principle-개방-폐쇄-법칙"><span class="anchor"></span></a></h3>
<ul>
<li>각 클래스는 클래스에 대한 수정을 폐쇄하고, 확장에 대해 개방해야 합니다.</li>
<li>즉 클래스를 수정해야 한다면 그 클래스를 상속, 즉 확장하여 수정합니다.</li>
</ul>
<h3 id="liskov-substitusion-principle-리스코프-치환-법칙">Liskov Substitusion Principle, 리스코프 치환 법칙<a aria-hidden="true" tabindex="-1" href="#liskov-substitusion-principle-리스코프-치환-법칙"><span class="anchor"></span></a></h3>
<ul>
<li>자식 클래스를 사용 중일때, 거기에 부모 클래스로 치환하여도 문제가 없어야 합니다.</li>
</ul>
<h3 id="interface-segreation-principle-인터페이스-분리-법칙">Interface Segreation Principle, 인터페이스 분리 법칙<a aria-hidden="true" tabindex="-1" href="#interface-segreation-principle-인터페이스-분리-법칙"><span class="anchor"></span></a></h3>
<ul>
<li>각 행위에 대한 인터페이스는 서로 분리되어야 합니다.</li>
</ul>
<h3 id="dependency-inversion-principle-의존성-역전-법칙">Dependency Inversion Principle, 의존성 역전 법칙<a aria-hidden="true" tabindex="-1" href="#dependency-inversion-principle-의존성-역전-법칙"><span class="anchor"></span></a></h3>
<ul>
<li>상위 클래스가 하위 클래스에 의존하면 안됩니다. 즉 기본적인 공통되는 속성을 하위 클래스에 의존하면 안됩니다.</li>
</ul>
<h2 id="참고">참고<a aria-hidden="true" tabindex="-1" href="#참고"><span class="anchor"></span></a></h2>
<ul>
<li><a href="https://baek.dev/post/22/?fbclid=IwAR05MUOFjMFheaB-B0dTCeH4hO0GWlNT9RJZwO3HCTIEv9SFU6nBq1G4O-A">객체지향을 한 단어로 설명한다면 그것은 클래스가 아니라 메시지이다</a></li>
</ul></div></div></div><div class="flex flex-col gap-5 my-10 max-w-4xl mx-auto px-4 xl:pr-[220px]"><div class="sponsor-button"><a class="flex items-center justify-center gap-3 px-6 py-3.5 bg-gradient-to-r from-amber-400 via-amber-500 to-amber-600 hover:from-amber-500 hover:via-amber-600 hover:to-amber-700 active:from-amber-600 active:via-amber-700 active:to-amber-800 text-white rounded-2xl transition-all duration-300 cursor-pointer border-0 shadow-lg hover:shadow-xl hover:scale-[1.02] active:scale-[0.98] font-semibold text-base no-underline" target="_blank" rel="noopener noreferrer" href="https://www.buymeacoffee.com/yuniq"><img src="https://www.buymeacoffee.com/assets/img/BMC-btn-logo.svg" alt="Buy me a coffee" class="w-7 h-7 flex-shrink-0"/><span>Buy me a coffee</span></a></div></div><div class="max-w-4xl mx-auto px-4 xl:pr-[220px]"><ins class="kakao_ad_area block" data-ad-unit="DAN-kkYIHzVbuDz3kYsq" data-ad-width="320" data-ad-height="50" style="width:320px;height:50px"></ins></div><div class="max-w-4xl mx-auto px-4 xl:pr-[220px]"><hr class="custom-hr"/></div><div class="my-8 max-w-4xl mx-auto px-4 xl:pr-[220px]"><div class="bio-container"><div class="author-description flex"><img class="bio-author-image" src="/images/profile.png" alt="yuni-q" width="72"/><div><span class="author-name-prefix text-[90%] mr-1">Written by</span><a class="author-name-content" href="/about/"><span>@<!-- -->yuni-q</span></a><div class="author-introduction mt-1 text-[80%] leading-[1.4]">yuni-q&#x27;s graffiti.</div><p class="author-socials mt-[-4px]"><a href="https://github.com/Yuni-Q" class="mr-2 text-[80%]">GitHub</a></p></div></div></div></div><div class="max-w-4xl mx-auto px-4 xl:pr-[220px]"><nav class="navigator my-8"><ul class="flex flex-col gap-4"><li><a rel="prev" class="block p-4 rounded-xl border border-gray-200 dark:border-gray-700 hover:border-blue-400 dark:hover:border-blue-500 hover:bg-blue-50 dark:hover:bg-blue-900/20 transition-all duration-200 group" href="/javascript/freeze/"><div class="text-xs text-gray-500 dark:text-gray-400 mb-1 group-hover:text-blue-600 dark:group-hover:text-blue-400 transition-colors">이전 글</div><div class="text-sm font-medium text-gray-900 dark:text-gray-100 group-hover:text-blue-600 dark:group-hover:text-blue-400 transition-colors">← <!-- -->freeze</div></a></li><li><a rel="next" class="block p-4 rounded-xl border border-gray-200 dark:border-gray-700 hover:border-blue-400 dark:hover:border-blue-500 hover:bg-blue-50 dark:hover:bg-blue-900/20 transition-all duration-200 group text-right" href="/develop/prototype-based-OOP/"><div class="text-xs text-gray-500 dark:text-gray-400 mb-1 group-hover:text-blue-600 dark:group-hover:text-blue-400 transition-colors">다음 글</div><div class="text-sm font-medium text-gray-900 dark:text-gray-100 group-hover:text-blue-600 dark:group-hover:text-blue-400 transition-colors">prototype based OOP<!-- --> →</div></a></li></ul></nav></div><div class="max-w-4xl mx-auto px-4 xl:pr-[220px]"><div class="utterences"></div></div><footer class="pt-[52px] text-center text-xs">©<a href="https://github.com/Yuni-Q" class="no-underline">yuni-q</a>, Built with<!-- --> <a href="https://nextjs.org" class="no-underline">Next.js</a></footer></div><script src="/_next/static/chunks/webpack-57fdca2934e5ae0a.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/bc8bb31cb71603b2.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[1633,[],\"\"]\n5:I[808,[],\"\"]\n7:I[6217,[],\"\"]\n8:I[5217,[\"3185\",\"static/chunks/app/layout-3ad8bb7cb2292578.js\"],\"ServiceWorkerCleanup\"]\n9:I[6484,[\"3185\",\"static/chunks/app/layout-3ad8bb7cb2292578.js\"],\"ThemeProvider\"]\nb:I[7768,[],\"\"]\n6:[\"slug\",\"develop/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D(oop)\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[\"$\",\"$L2\",null,{\"buildId\":\"static-build-id\",\"assetPrefix\":\"\",\"urlParts\":[\"\",\"blog\",\"develop\",\"%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D(oop)\",\"\"],\"initialTree\":[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"develop/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D(oop)\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"develop\\\",\\\"객체지향-프로그래밍(oop)\\\"]}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"develop/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D(oop)\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\",null],null],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/bc8bb31cb71603b2.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"ko\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"preconnect\",\"href\":\"https://fonts.googleapis.com\"}],[\"$\",\"link\",null,{\"rel\":\"preconnect\",\"href\":\"https://fonts.gstatic.com\",\"crossOrigin\":\"anonymous\"}],[\"$\",\"link\",null,{\"href\":\"https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700\u0026display=swap\",\"rel\":\"stylesheet\"}],[\"$\",\"link\",null,{\"href\":\"https://fonts.googleapis.com/css2?family=Catamaran:wght@800\u0026display=swap\",\"rel\":\"stylesheet\"}],[\"$\",\"link\",null,{\"rel\":\"icon\",\"type\":\"image/png\",\"href\":\"/favicon2.png\"}],[\"$\",\"link\",null,{\"rel\":\"shortcut icon\",\"href\":\"/favicon2.png\"}],[\"$\",\"link\",null,{\"rel\":\"apple-touch-icon\",\"href\":\"/favicon2.png\"}],[\"$\",\"script\",null,{\"id\":\"ads\",\"async\":true,\"src\":\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"(adsbygoogle=window.adsbygoogle||[]).requestNonPersonalizedAds=1;\"}}]]}],[\"$\",\"body\",null,{\"children\":[[\"$\",\"noscript\",null,{\"children\":\"You need to enable JavaScript to run this app.\"}],[\"$\",\"$L8\",null,{}],[\"$\",\"$L9\",null,{\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[]}]}]]}]]}]],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]\n"])</script><script>self.__next_f.push([1,"d:I[5553,[\"9243\",\"static/chunks/9243-972bdccd4ceb11ae.js\",\"5800\",\"static/chunks/5800-4312aed1aa8a4305.js\",\"549\",\"static/chunks/549-2babc012700e23ed.js\",\"4853\",\"static/chunks/4853-73ca7990eb89674b.js\",\"6797\",\"static/chunks/app/blog/%5B...slug%5D/page-9b274a2e0073d544.js\"],\"BlogPostPageClient\"]\ne:T3212,"])</script><script>self.__next_f.push([1,"\n- 객체지향 프로그래밍은 컴퓨터 프로그래밍 패러다임(견해, 사고법)의 하나로, 프로그래밍에서 필요한 데이터를 추상화 시켜서 상태(속성, 어트리뷰트)와 행위(메서드)를 가진 객체로 만들고, 그 객체간의 상호작용을 통해 로직을 구성하는 방법입니다.\n- 객체지향 애플리케이션의 중심 사상은 연쇄적으로 메시지를 전송하고 수신하는 객체들 사이의 협력 관계를 기반으로 사용자에게 유용한 기능을 제공하는 것입니다. 객체지향의 강력함은 객체들이 주고받는 메시지로부터 나옵니다. 객체지향의 애플리케이션은 클래스를 이용해 만들어지지만 메시지를 통해 정의됩니다.\n- 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 부과되는 규율입니다.\n\n## 자율적인 책임\n\n- 객체지향 공동체를 구성하는 기본 단위는 `자율적인 객체`입니다.\n- 자율적인 객체란 스스로 정한 원칙에 따라 판단하고 스스로의 의지를 기반으로 행동하는 객체입니다. 객체가 어떤 행동을 하는 유일한 이유는 다른 객체로부터 요청을 수신했기 때문입니다. `요청을 처리하기 위해 객체가 수행하는 행동`을 책임이라고 합니다.\n- 적절한 책임이 자율적인 객체를 낳고, 자율적인 객체들이 모여 유연하고 단순한 협력을 낳습니다. 따라서 `협력에 참여하는 객체가 얼마나 자율적인지가 전체 어플리케이션의 품질을 결정합니다`. 객체가 책임을 자율적으로 수행하기 위해서는 객체에게 할당되는 책임이 자율적이어야 합니다. 책임이 자율적이지 않다면 객체가 아무리 발버둥친다고 하더라도 자율적으로 책임을 수행하기 어렵습니다.\n- 자율적인 책임의 특징은 객체가 어떻게해야 하는가가 아니라 `무엇을 해야하는가`를 설명한다는 것입니다. 책임이라는 말 속에는 어떤 행동을 수행한다는 의미가 포함돼 있습니다. 객체지향 공동체 안에 거주하는 객체는 다른 객체로부터 전송된 요청을 수신할 때만 어떤 행동을 시작합니다.\n- 사실 객체가 다른 객체에게 접근할 수 있는 유일한 방법은 요청을 전송하는 것뿐입니다. 그리고 이 요청을 우리는 메시지라고 부릅니다. 메시지는 객체로 하여금 자신의 책임, 즉 행동을 수행하게 만드는 유일한 방법입니다.\n- 성급한 일반화의 오류를 피하고 현재의 문맥에 가장 적합한 책임을 선택할 수 있는 날카로운 안목이 필요합니다.\n\n## 메시지와 메서드\n\n- 하나의 객체는 메시지를 전송함으로써 다른 객체에 접근합니다.\n- 객체의 행동을 유발하는 행위를 가리켜 메시지-전송이라고 합니다.\n- 메시지-전송 메커니즘은 객체가 다른 객체에 접근할 수 있는 유일한 방법입니다.\n- 객체가 제공하는 메시지는 외부의 다른 객체가 볼 수 있는 공개된 영역에 속합니다. 메시지를 처리하기 위해 책임을 수행하는 방법은 외부의 다른 객체가 볼 수 없는 객체 자신의 사적인 영역에 속합니다. 객체가 유일하게 이해할 수 있는 의사소통 수단은 메시지뿐이며 객체는 메시지를 처리하기 위한 방법을 자율적으로 선택할 수 있습니다.\n- 메시지가 '어떻게' 수행될 것인지는 명시하지 않습니다. 메시지는 단지 오퍼레이션을 통해 `무엇`이 실행되기를 바라는지만 명시하며, 어떤 메서드를 선택할 것인지는 전적으로 수신자의 결정에 좌우됩니다\n\n## 다형성\n\n- 다형성이란 서로 다른 유형의 객체가 동일한 메시지에 대해 서로 다르게 반응하는 것을 의미합니다.\n- 서로 다른 타입에 속하는 객체들이 동일한 메시지를 수신할 경우 서로 다른 메서드를 이용해 메시를 이용해 메시지를 처리할 수 있는 메커니즘을 가리킵니다.\n- 다형성은 역할, 책임, 협력과 깊은 관련이 있습니다. 서로 다른 객체들이 다형성을 만족시킨다는 것은 객체들이 동일한 책임을 공유한다는 것을 의미합니다. 메시지 수신자들이 동일한 오퍼레이션을 서로 다른 방식으로 처리하더라도 메시지 송신자의 관점에서 이 객체들은 동일한 책임을 수행하는 것입니다. 즉, 송신자의 관점에서 다형적인 수신자들을 구별할 필요가 없으며 자신의 요청을 수행할 책임을 지닌다는 점에서 모두 동일합니다.\n- 다형성은 객체들의 대체 가능성을 이용해 설계를 유연하고 재사용 가능하게 만듭니다. 다형성을 사용하면 송신자가 수신자의 종류를 모르더라도 메시지를 전송할 수 있습니다. 즉, 다형성은 수신자의 종류를 캡슐화합니다.\n- 객체지향 패러다임이 강력한 이유는 다형성을 이용해 협력을 유연하게 만들수 있기 때문입니다.\n\n## 메시지를 따라라\n\n- 객체지향 애플리케이션의 중심 사상은 연쇄적으로 메시지를 전송하고 수신하는 객체들 사이의 협력 관계를 기반으로 사용자에게 유용한 기능을 제공하는 것입니다. 클래스 기반의 객체지향 언어를 사용하는 대부분의 사람들은 객체지향 애플리케이션을 클래스의 집합으로 생각합니다. 프로그래머 입장에서는 클래스는 실제로 볼 수 있고 수정할 수 있는 구체적인 존재입니다. 대부분의 입문자들은 클래스 간의 상속 관계가 객체지향 설계를 가치 있게 만드는 핵심적인 매커니즘이라고 배웁니다. 하지만 객체지향의 강력함은 클래스가 아니라 객체들이 주고받는 메시지로부터 나옵니다. `객체지향의 애플리케이션은 클래스를 이용해 만들어지지만 메시지를 통해 정의됩니다`.\n- 실제로 애플리케이션을 살아있게 만드는 것은 클래스가 아니라 `객체`입니다. 그리고 이런 객체들의 윤곽을 결정하는 것이 바로 객체들이 주고받는 메시지입니다. 클래스를 정의하는 것이 먼저가 아니라 객체들의 속성과 행위를 식별하는 것이 먼저입니다. 클래스는 객체의 속성과 행위를 담는 틀일 뿐입니다.\n- 객체 자체에 초점을 맞출 경우 가장 흔히 범하게 되는 실수는 협력이라는 문맥을 배제한 채 객체 내부의 데이터 구조를 먼저 생각한 후 데이터 조작에 필요한 오퍼레이션을 나중에 고려하는 것입니다.\n- 훌륭한 객체지향 설계는 어떤 객체가 어떤 메시지를 전송할 수 있는가와 어떤 객체가 어떤 메시지를 이해할 수 있는가를 중심으로 객체 사이의 협력 관계를 구성하는 것입니다.\n- 객체지향 설계의 중심에는 메시지가 위치합니다. 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하게 해야 합니다. 객체지향 시스템은 협력하는 객체들의 연결망입니다.\n\n## 객체 인터페이스, 구현의 분리\n\n- 객체의 인터페이스는 객체가 수신할 수 있는 메시지의 목록으로 구성되며 객체가 어떤 메시지를 수신할 수 있는지가 제공하는 인터페이스의 모양을 빚습니다. 이때는 3가지의 원칙이 필요합니다.\n  - 좀 더 추상적인 인터페이스를 통해 수신자의 자율성을 보장합니다.\n  - 외부에서 사용할 필요가 없는 인터페이스는 최대한 노출하지 않습니다.\n  - 인터페이스와 구현 간에 차이가 있습니다.\n- 객체가 가져야 할 상태와 메서드 구현은 객체 내부에 속합니다. 이 부분을 수정하더라도 객체 외부에 영향을 미쳐서는 안됩니다. 객체 외부에 영향을 미치는 변경은 객체의 공용 인터페이스를 수정할 때 뿐입니다. 이렇게 인터페이스와 구현의 분리 원칙은 변경을 관리하기 위한 것입니다. 느슨한 인터페이스에 대해서만 결합되도록 만드는 것입니다.\n- 인터페이스를 제외한 구현부를 외부로 부터 감추는 것을 `캡슐화`라고 합니다. 객체는 상태와 행위를 함께 캡슐화함으로써 충분히 협력적이고 만족스러울 정도로 자율적인 존재가 될 수 있습니다. 캡슐화를 `정보의 은닉`이라고 부르기도 합니다.\n\n## 객체가 자율적인 책임을 갖는 것이 중요한 이유\n\n- 책임의 자율성이 협력의 품질을 결정합니다.\n  - 객체의 책임이 자율적일수록 협력이 이해하기 쉬워지고 유연하게 변경할 수 있게 됩니다. 결과적으로 책임이 얼마나 자율적인지가 전체적인 협력의 설계 품질을 결정하게 됩니다.\n- 자율적인 책임은 협력을 단순하게 만듭니다.\n- 자율적인 책임은 외부와 내부를 명확하게 분리합니다.\n- 책임이 자율적일 경우 책임을 수행하는 내부적인 방법을 변경하더라도 외부에 영향을 미치지 않습니다.(결합도가 낮아집니다)\n- 자율적인 책임은 협력의 대상을 다양하게 선택할 수 있는 유연성을 제공합니다.\n- 객체가 수행하는 책임들이 자율적일수록 객체의 역할을 이해하기 쉬워집니다.\n- 책임이 자율적일수록 적절하게 추상화되며, 응집도가 높아지고, 결합도가 낮아지며, 캡슐화가 증진되고, 인터페이스와 구현이 명확히 분리되며, 설계의 유연성과 재사용성이 향상됩니다.\n- 객체지향의 강력함을 누리기 위한 출발점은 책임을 자율적으로 만드는 것입니다.\n\n## 장점\n\n- 다른 클래스를 가져와 사용할 수 있고, 상속받을 수 있어 코드의 재사용성이 높습니다.\n- 절차지향보다 유지보수가 간단하고 수정에 용이합니다.\n- 클래스 단위로 모듈화가 가능하여, 대형 프로젝트에 적합합니다.\n\n## 단점\n\n- 처리속도가 상대적으로 느립니다.\n- 객체가 많으면 용량이 커집니다.\n- 설계시 많은 노력과 시간이 필요합니다.\n\n## OOP의 6가지 키워드\n\n### 클래스\n\n- 현실 세계의 객체를 추상화시켜, 속성과 메서드로 정의한 것입니다.(논리적 개념)\n\n### 인스턴스\n\n- 클래스에서 정의한 것을 토대로 만든 실제 메모리상에 할당된 것, 실제 데이터 입니다.\n\n### 추상화\n\n- 객체지향 관점에서 클래스를 정의하는 것입니다. 불필요한 정보 외 중요한 정보만 표현함으로써 공통의 속성과 기능을 묶어 이름을 붙이는 것입니다.\n\n### 캡슐화\n\n- 코드를 수정없이 재활용 하는 것을 목적으로 합니다. 클래스라는 캡슐에 기능과 특성을 담아 묶습니다. 목적을 기준으로 묶습니다\n- 은닉화와의 차이 : 은닉화는 캡슐화의 일부라고 볼 수 있으며, 목적으로 묶인 캡슐 안을 사용자는 볼 수 없다는 것이 은닉화 입니다.\n\n### 상속\n\n- 클래스로부터 속성과 메서드를 물려받는 것입니다. 다른 클래스를 가져와서 수정할 일이 있다면, 그 클래스를 직접 수정하는 대신 상속을 받아 변경하고자 하는 부분만 변경합니다.\n\n### 다형성\n\n- 하나의 변수명이나 함수명이 상황에 따라 다르게 해석될 수 있습니다. 대표적인 다형성이 오버라이딩과 오버로딩 입니다.\n\n## OOP의 5가지 법칙 (SOLID)\n\n### Single Responsibility Principle, 단일 책임 법칙\n\n- 각 클래스는 목적을 하나씩만 가지고 그에 대한 책임을 져야 합니다.\n\n### Open Close Principle, 개방 폐쇄 법칙\n\n- 각 클래스는 클래스에 대한 수정을 폐쇄하고, 확장에 대해 개방해야 합니다.\n- 즉 클래스를 수정해야 한다면 그 클래스를 상속, 즉 확장하여 수정합니다.\n\n### Liskov Substitusion Principle, 리스코프 치환 법칙\n\n- 자식 클래스를 사용 중일때, 거기에 부모 클래스로 치환하여도 문제가 없어야 합니다.\n\n### Interface Segreation Principle, 인터페이스 분리 법칙\n\n- 각 행위에 대한 인터페이스는 서로 분리되어야 합니다.\n\n### Dependency Inversion Principle, 의존성 역전 법칙\n\n- 상위 클래스가 하위 클래스에 의존하면 안됩니다. 즉 기본적인 공통되는 속성을 하위 클래스에 의존하면 안됩니다.\n\n## 참고\n\n- [객체지향을 한 단어로 설명한다면 그것은 클래스가 아니라 메시지이다](https://baek.dev/post/22/?fbclid=IwAR05MUOFjMFheaB-B0dTCeH4hO0GWlNT9RJZwO3HCTIEv9SFU6nBq1G4O-A)\n"])</script><script>self.__next_f.push([1,"f:T419b,"])</script><script>self.__next_f.push([1,"\u003cul\u003e\n\u003cli\u003e객체지향 프로그래밍은 컴퓨터 프로그래밍 패러다임(견해, 사고법)의 하나로, 프로그래밍에서 필요한 데이터를 추상화 시켜서 상태(속성, 어트리뷰트)와 행위(메서드)를 가진 객체로 만들고, 그 객체간의 상호작용을 통해 로직을 구성하는 방법입니다.\u003c/li\u003e\n\u003cli\u003e객체지향 애플리케이션의 중심 사상은 연쇄적으로 메시지를 전송하고 수신하는 객체들 사이의 협력 관계를 기반으로 사용자에게 유용한 기능을 제공하는 것입니다. 객체지향의 강력함은 객체들이 주고받는 메시지로부터 나옵니다. 객체지향의 애플리케이션은 클래스를 이용해 만들어지지만 메시지를 통해 정의됩니다.\u003c/li\u003e\n\u003cli\u003e객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 부과되는 규율입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"자율적인-책임\"\u003e자율적인 책임\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#자율적인-책임\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e객체지향 공동체를 구성하는 기본 단위는 \u003ccode class=\"inline-code\"\u003e자율적인 객체\u003c/code\u003e입니다.\u003c/li\u003e\n\u003cli\u003e자율적인 객체란 스스로 정한 원칙에 따라 판단하고 스스로의 의지를 기반으로 행동하는 객체입니다. 객체가 어떤 행동을 하는 유일한 이유는 다른 객체로부터 요청을 수신했기 때문입니다. \u003ccode class=\"inline-code\"\u003e요청을 처리하기 위해 객체가 수행하는 행동\u003c/code\u003e을 책임이라고 합니다.\u003c/li\u003e\n\u003cli\u003e적절한 책임이 자율적인 객체를 낳고, 자율적인 객체들이 모여 유연하고 단순한 협력을 낳습니다. 따라서 \u003ccode class=\"inline-code\"\u003e협력에 참여하는 객체가 얼마나 자율적인지가 전체 어플리케이션의 품질을 결정합니다\u003c/code\u003e. 객체가 책임을 자율적으로 수행하기 위해서는 객체에게 할당되는 책임이 자율적이어야 합니다. 책임이 자율적이지 않다면 객체가 아무리 발버둥친다고 하더라도 자율적으로 책임을 수행하기 어렵습니다.\u003c/li\u003e\n\u003cli\u003e자율적인 책임의 특징은 객체가 어떻게해야 하는가가 아니라 \u003ccode class=\"inline-code\"\u003e무엇을 해야하는가\u003c/code\u003e를 설명한다는 것입니다. 책임이라는 말 속에는 어떤 행동을 수행한다는 의미가 포함돼 있습니다. 객체지향 공동체 안에 거주하는 객체는 다른 객체로부터 전송된 요청을 수신할 때만 어떤 행동을 시작합니다.\u003c/li\u003e\n\u003cli\u003e사실 객체가 다른 객체에게 접근할 수 있는 유일한 방법은 요청을 전송하는 것뿐입니다. 그리고 이 요청을 우리는 메시지라고 부릅니다. 메시지는 객체로 하여금 자신의 책임, 즉 행동을 수행하게 만드는 유일한 방법입니다.\u003c/li\u003e\n\u003cli\u003e성급한 일반화의 오류를 피하고 현재의 문맥에 가장 적합한 책임을 선택할 수 있는 날카로운 안목이 필요합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"메시지와-메서드\"\u003e메시지와 메서드\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#메시지와-메서드\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e하나의 객체는 메시지를 전송함으로써 다른 객체에 접근합니다.\u003c/li\u003e\n\u003cli\u003e객체의 행동을 유발하는 행위를 가리켜 메시지-전송이라고 합니다.\u003c/li\u003e\n\u003cli\u003e메시지-전송 메커니즘은 객체가 다른 객체에 접근할 수 있는 유일한 방법입니다.\u003c/li\u003e\n\u003cli\u003e객체가 제공하는 메시지는 외부의 다른 객체가 볼 수 있는 공개된 영역에 속합니다. 메시지를 처리하기 위해 책임을 수행하는 방법은 외부의 다른 객체가 볼 수 없는 객체 자신의 사적인 영역에 속합니다. 객체가 유일하게 이해할 수 있는 의사소통 수단은 메시지뿐이며 객체는 메시지를 처리하기 위한 방법을 자율적으로 선택할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e메시지가 '어떻게' 수행될 것인지는 명시하지 않습니다. 메시지는 단지 오퍼레이션을 통해 \u003ccode class=\"inline-code\"\u003e무엇\u003c/code\u003e이 실행되기를 바라는지만 명시하며, 어떤 메서드를 선택할 것인지는 전적으로 수신자의 결정에 좌우됩니다\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"다형성\"\u003e다형성\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#다형성\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e다형성이란 서로 다른 유형의 객체가 동일한 메시지에 대해 서로 다르게 반응하는 것을 의미합니다.\u003c/li\u003e\n\u003cli\u003e서로 다른 타입에 속하는 객체들이 동일한 메시지를 수신할 경우 서로 다른 메서드를 이용해 메시를 이용해 메시지를 처리할 수 있는 메커니즘을 가리킵니다.\u003c/li\u003e\n\u003cli\u003e다형성은 역할, 책임, 협력과 깊은 관련이 있습니다. 서로 다른 객체들이 다형성을 만족시킨다는 것은 객체들이 동일한 책임을 공유한다는 것을 의미합니다. 메시지 수신자들이 동일한 오퍼레이션을 서로 다른 방식으로 처리하더라도 메시지 송신자의 관점에서 이 객체들은 동일한 책임을 수행하는 것입니다. 즉, 송신자의 관점에서 다형적인 수신자들을 구별할 필요가 없으며 자신의 요청을 수행할 책임을 지닌다는 점에서 모두 동일합니다.\u003c/li\u003e\n\u003cli\u003e다형성은 객체들의 대체 가능성을 이용해 설계를 유연하고 재사용 가능하게 만듭니다. 다형성을 사용하면 송신자가 수신자의 종류를 모르더라도 메시지를 전송할 수 있습니다. 즉, 다형성은 수신자의 종류를 캡슐화합니다.\u003c/li\u003e\n\u003cli\u003e객체지향 패러다임이 강력한 이유는 다형성을 이용해 협력을 유연하게 만들수 있기 때문입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"메시지를-따라라\"\u003e메시지를 따라라\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#메시지를-따라라\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e객체지향 애플리케이션의 중심 사상은 연쇄적으로 메시지를 전송하고 수신하는 객체들 사이의 협력 관계를 기반으로 사용자에게 유용한 기능을 제공하는 것입니다. 클래스 기반의 객체지향 언어를 사용하는 대부분의 사람들은 객체지향 애플리케이션을 클래스의 집합으로 생각합니다. 프로그래머 입장에서는 클래스는 실제로 볼 수 있고 수정할 수 있는 구체적인 존재입니다. 대부분의 입문자들은 클래스 간의 상속 관계가 객체지향 설계를 가치 있게 만드는 핵심적인 매커니즘이라고 배웁니다. 하지만 객체지향의 강력함은 클래스가 아니라 객체들이 주고받는 메시지로부터 나옵니다. \u003ccode class=\"inline-code\"\u003e객체지향의 애플리케이션은 클래스를 이용해 만들어지지만 메시지를 통해 정의됩니다\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e실제로 애플리케이션을 살아있게 만드는 것은 클래스가 아니라 \u003ccode class=\"inline-code\"\u003e객체\u003c/code\u003e입니다. 그리고 이런 객체들의 윤곽을 결정하는 것이 바로 객체들이 주고받는 메시지입니다. 클래스를 정의하는 것이 먼저가 아니라 객체들의 속성과 행위를 식별하는 것이 먼저입니다. 클래스는 객체의 속성과 행위를 담는 틀일 뿐입니다.\u003c/li\u003e\n\u003cli\u003e객체 자체에 초점을 맞출 경우 가장 흔히 범하게 되는 실수는 협력이라는 문맥을 배제한 채 객체 내부의 데이터 구조를 먼저 생각한 후 데이터 조작에 필요한 오퍼레이션을 나중에 고려하는 것입니다.\u003c/li\u003e\n\u003cli\u003e훌륭한 객체지향 설계는 어떤 객체가 어떤 메시지를 전송할 수 있는가와 어떤 객체가 어떤 메시지를 이해할 수 있는가를 중심으로 객체 사이의 협력 관계를 구성하는 것입니다.\u003c/li\u003e\n\u003cli\u003e객체지향 설계의 중심에는 메시지가 위치합니다. 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하게 해야 합니다. 객체지향 시스템은 협력하는 객체들의 연결망입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"객체-인터페이스-구현의-분리\"\u003e객체 인터페이스, 구현의 분리\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#객체-인터페이스-구현의-분리\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e객체의 인터페이스는 객체가 수신할 수 있는 메시지의 목록으로 구성되며 객체가 어떤 메시지를 수신할 수 있는지가 제공하는 인터페이스의 모양을 빚습니다. 이때는 3가지의 원칙이 필요합니다.\n\u003cul\u003e\n\u003cli\u003e좀 더 추상적인 인터페이스를 통해 수신자의 자율성을 보장합니다.\u003c/li\u003e\n\u003cli\u003e외부에서 사용할 필요가 없는 인터페이스는 최대한 노출하지 않습니다.\u003c/li\u003e\n\u003cli\u003e인터페이스와 구현 간에 차이가 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e객체가 가져야 할 상태와 메서드 구현은 객체 내부에 속합니다. 이 부분을 수정하더라도 객체 외부에 영향을 미쳐서는 안됩니다. 객체 외부에 영향을 미치는 변경은 객체의 공용 인터페이스를 수정할 때 뿐입니다. 이렇게 인터페이스와 구현의 분리 원칙은 변경을 관리하기 위한 것입니다. 느슨한 인터페이스에 대해서만 결합되도록 만드는 것입니다.\u003c/li\u003e\n\u003cli\u003e인터페이스를 제외한 구현부를 외부로 부터 감추는 것을 \u003ccode class=\"inline-code\"\u003e캡슐화\u003c/code\u003e라고 합니다. 객체는 상태와 행위를 함께 캡슐화함으로써 충분히 협력적이고 만족스러울 정도로 자율적인 존재가 될 수 있습니다. 캡슐화를 \u003ccode class=\"inline-code\"\u003e정보의 은닉\u003c/code\u003e이라고 부르기도 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"객체가-자율적인-책임을-갖는-것이-중요한-이유\"\u003e객체가 자율적인 책임을 갖는 것이 중요한 이유\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#객체가-자율적인-책임을-갖는-것이-중요한-이유\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e책임의 자율성이 협력의 품질을 결정합니다.\n\u003cul\u003e\n\u003cli\u003e객체의 책임이 자율적일수록 협력이 이해하기 쉬워지고 유연하게 변경할 수 있게 됩니다. 결과적으로 책임이 얼마나 자율적인지가 전체적인 협력의 설계 품질을 결정하게 됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e자율적인 책임은 협력을 단순하게 만듭니다.\u003c/li\u003e\n\u003cli\u003e자율적인 책임은 외부와 내부를 명확하게 분리합니다.\u003c/li\u003e\n\u003cli\u003e책임이 자율적일 경우 책임을 수행하는 내부적인 방법을 변경하더라도 외부에 영향을 미치지 않습니다.(결합도가 낮아집니다)\u003c/li\u003e\n\u003cli\u003e자율적인 책임은 협력의 대상을 다양하게 선택할 수 있는 유연성을 제공합니다.\u003c/li\u003e\n\u003cli\u003e객체가 수행하는 책임들이 자율적일수록 객체의 역할을 이해하기 쉬워집니다.\u003c/li\u003e\n\u003cli\u003e책임이 자율적일수록 적절하게 추상화되며, 응집도가 높아지고, 결합도가 낮아지며, 캡슐화가 증진되고, 인터페이스와 구현이 명확히 분리되며, 설계의 유연성과 재사용성이 향상됩니다.\u003c/li\u003e\n\u003cli\u003e객체지향의 강력함을 누리기 위한 출발점은 책임을 자율적으로 만드는 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"장점\"\u003e장점\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#장점\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e다른 클래스를 가져와 사용할 수 있고, 상속받을 수 있어 코드의 재사용성이 높습니다.\u003c/li\u003e\n\u003cli\u003e절차지향보다 유지보수가 간단하고 수정에 용이합니다.\u003c/li\u003e\n\u003cli\u003e클래스 단위로 모듈화가 가능하여, 대형 프로젝트에 적합합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"단점\"\u003e단점\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#단점\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e처리속도가 상대적으로 느립니다.\u003c/li\u003e\n\u003cli\u003e객체가 많으면 용량이 커집니다.\u003c/li\u003e\n\u003cli\u003e설계시 많은 노력과 시간이 필요합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"oop의-6가지-키워드\"\u003eOOP의 6가지 키워드\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#oop의-6가지-키워드\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003ch3 id=\"클래스\"\u003e클래스\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#클래스\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e현실 세계의 객체를 추상화시켜, 속성과 메서드로 정의한 것입니다.(논리적 개념)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"인스턴스\"\u003e인스턴스\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#인스턴스\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e클래스에서 정의한 것을 토대로 만든 실제 메모리상에 할당된 것, 실제 데이터 입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"추상화\"\u003e추상화\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#추상화\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e객체지향 관점에서 클래스를 정의하는 것입니다. 불필요한 정보 외 중요한 정보만 표현함으로써 공통의 속성과 기능을 묶어 이름을 붙이는 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"캡슐화\"\u003e캡슐화\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#캡슐화\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e코드를 수정없이 재활용 하는 것을 목적으로 합니다. 클래스라는 캡슐에 기능과 특성을 담아 묶습니다. 목적을 기준으로 묶습니다\u003c/li\u003e\n\u003cli\u003e은닉화와의 차이 : 은닉화는 캡슐화의 일부라고 볼 수 있으며, 목적으로 묶인 캡슐 안을 사용자는 볼 수 없다는 것이 은닉화 입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"상속\"\u003e상속\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#상속\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e클래스로부터 속성과 메서드를 물려받는 것입니다. 다른 클래스를 가져와서 수정할 일이 있다면, 그 클래스를 직접 수정하는 대신 상속을 받아 변경하고자 하는 부분만 변경합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"다형성-1\"\u003e다형성\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#다형성-1\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e하나의 변수명이나 함수명이 상황에 따라 다르게 해석될 수 있습니다. 대표적인 다형성이 오버라이딩과 오버로딩 입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"oop의-5가지-법칙-solid\"\u003eOOP의 5가지 법칙 (SOLID)\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#oop의-5가지-법칙-solid\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003ch3 id=\"single-responsibility-principle-단일-책임-법칙\"\u003eSingle Responsibility Principle, 단일 책임 법칙\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#single-responsibility-principle-단일-책임-법칙\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e각 클래스는 목적을 하나씩만 가지고 그에 대한 책임을 져야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"open-close-principle-개방-폐쇄-법칙\"\u003eOpen Close Principle, 개방 폐쇄 법칙\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#open-close-principle-개방-폐쇄-법칙\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e각 클래스는 클래스에 대한 수정을 폐쇄하고, 확장에 대해 개방해야 합니다.\u003c/li\u003e\n\u003cli\u003e즉 클래스를 수정해야 한다면 그 클래스를 상속, 즉 확장하여 수정합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"liskov-substitusion-principle-리스코프-치환-법칙\"\u003eLiskov Substitusion Principle, 리스코프 치환 법칙\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#liskov-substitusion-principle-리스코프-치환-법칙\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e자식 클래스를 사용 중일때, 거기에 부모 클래스로 치환하여도 문제가 없어야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"interface-segreation-principle-인터페이스-분리-법칙\"\u003eInterface Segreation Principle, 인터페이스 분리 법칙\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#interface-segreation-principle-인터페이스-분리-법칙\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e각 행위에 대한 인터페이스는 서로 분리되어야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"dependency-inversion-principle-의존성-역전-법칙\"\u003eDependency Inversion Principle, 의존성 역전 법칙\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#dependency-inversion-principle-의존성-역전-법칙\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e상위 클래스가 하위 클래스에 의존하면 안됩니다. 즉 기본적인 공통되는 속성을 하위 클래스에 의존하면 안됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"참고\"\u003e참고\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#참고\"\u003e\u003cspan class=\"anchor\"\u003e\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://baek.dev/post/22/?fbclid=IwAR05MUOFjMFheaB-B0dTCeH4hO0GWlNT9RJZwO3HCTIEv9SFU6nBq1G4O-A\"\u003e객체지향을 한 단어로 설명한다면 그것은 클래스가 아니라 메시지이다\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e"])</script><script>self.__next_f.push([1,"4:[\"$\",\"$Ld\",null,{\"post\":{\"slug\":\"/develop/객체지향-프로그래밍(oop)\",\"frontmatter\":{\"title\":\"객체지향 프로그래밍(OOP)\",\"date\":\"2020-07-21T12:08:11.000Z\",\"category\":\"develop\",\"draft\":false},\"content\":\"$e\",\"html\":\"$f\",\"excerpt\":\"- 객체지향 프로그래밍은 컴퓨터 프로그래밍 패러다임(견해, 사고법)의 하나로, 프로그래밍에서 필요한 데이터를 추상화 시켜서 상태(속성, 어트리뷰트)와 행위(메서드)를 가진 객체로 만들고, 그 객체간의 상호작용을 통해 로직을 구성하는 방법입니다. - 객체지향 애플리케이션의 중심 사상은 연쇄적으로 메시지를 전송하고 수신하는 객체들 사이의 협력 관계를 기반으로\"},\"previousPost\":{\"slug\":\"/javascript/freeze\",\"frontmatter\":{\"title\":\"freeze\",\"date\":\"2020-07-19T21:07:26.000Z\",\"category\":\"javascript\",\"draft\":false}},\"nextPost\":{\"slug\":\"/develop/prototype-based-OOP\",\"frontmatter\":{\"title\":\"prototype based OOP\",\"date\":\"2020-07-21T12:08:11.000Z\",\"category\":\"develop\",\"draft\":false}}}]\na:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"객체지향 프로그래밍(OOP)\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"- 객체지향 프로그래밍은 컴퓨터 프로그래밍 패러다임(견해, 사고법)의 하나로, 프로그래밍에서 필요한 데이터를 추상화 시켜서 상태(속성, 어트리뷰트)와 행위(메서드)를 가진 객체로 만들고, 그 객체간의 상호작용을 통해 로직을 구성하는 방법입니다. - 객체지향 애플리케이션의 중심 사상은 연쇄적으로 메시지를 전송하고 수신하는 객체들 사이의 협력 관계를 기반으로\"}]]\n3:null\n"])</script></body></html>