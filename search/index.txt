3:I[808,[],""]
4:I[6217,[],""]
5:I[5217,["3185","static/chunks/app/layout-3ad8bb7cb2292578.js"],"ServiceWorkerCleanup"]
6:I[6484,["3185","static/chunks/app/layout-3ad8bb7cb2292578.js"],"ThemeProvider"]
0:["static-build-id",[[["",{"children":["search",{"children":["__PAGE__",{}]}]},"$undefined","$undefined",true],["",{"children":["search",{"children":["__PAGE__",{},[["$L1","$L2",null],null],null]},[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","search","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/bc8bb31cb71603b2.css","precedence":"next","crossOrigin":"$undefined"}]],["$","html",null,{"lang":"ko","children":[["$","head",null,{"children":[["$","link",null,{"rel":"preconnect","href":"https://fonts.googleapis.com"}],["$","link",null,{"rel":"preconnect","href":"https://fonts.gstatic.com","crossOrigin":"anonymous"}],["$","link",null,{"href":"https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap","rel":"stylesheet"}],["$","link",null,{"href":"https://fonts.googleapis.com/css2?family=Catamaran:wght@800&display=swap","rel":"stylesheet"}],["$","link",null,{"rel":"icon","type":"image/png","href":"/favicon2.png"}],["$","link",null,{"rel":"shortcut icon","href":"/favicon2.png"}],["$","link",null,{"rel":"apple-touch-icon","href":"/favicon2.png"}],["$","script",null,{"id":"ads","async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"}],["$","script",null,{"dangerouslySetInnerHTML":{"__html":"(adsbygoogle=window.adsbygoogle||[]).requestNonPersonalizedAds=1;"}}]]}],["$","body",null,{"children":[["$","noscript",null,{"children":"You need to enable JavaScript to run this app."}],["$","$L5",null,{}],["$","$L6",null,{"children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[]}]}]]}]]}]],null],null],["$L7",null]]]]
8:I[5272,["9243","static/chunks/9243-972bdccd4ceb11ae.js","549","static/chunks/549-2babc012700e23ed.js","2797","static/chunks/app/search/page-b919763f74073b0c.js"],"SearchPageClient"]
2:["$","$L8",null,{"posts":[{"slug":"/develop/CorePack 아키텍처 개편","frontmatter":{"title":"CorePack 아키텍처 개편","date":"2025-12-28T00:00:00.000Z","category":"develop","tags":["React","Next.js","아키텍처","빌더패턴","상태관리","StrictMode","모노레포"],"draft":false},"excerpt":"> Next.js 기반의 대규모 모노레포에서 CorePack 아키텍처를 전면 개편한 경험을 공유합니다. React Strict Mode로 인한 상태 관리 문제, AuthStore 초기화 문제, 빌더 패턴 적용 등 다양한 기술적 도전을 해결했습니다.  ## 📊 프로젝트 개요  ### 영향 범위  - **프레임워크**: Next.js 14, React 18 - **주요 목표**: React Strict Mode 지원 및 초기화 로직 체계화 - **성과**: 메모리 사용량 30% 감소, 상태 관리 코드 중복 35% 감소  ### 핵심 성과  - ✅ React Strict Mode 환경 안정성 확보 - ✅ 첫 실행 시 auth 데이터 누락 문제 근본 해결 - ✅ store 인스턴스 단일화로 메모리 최적화 (30% 감소) - ✅ 빌더 패턴 적용으로 초기화 순서 체계화 - ✅ 상태 업데이트 로직 통합으로 코드 중복 감소 (35%) - ✅ 로그인 상태 기반 자동 재빌드 메커니즘 구현 - ✅","searchableText":"corepack 아키텍처 개편 develop react next.js 아키텍처 빌더패턴 상태관리 strictmode 모노레포 > next.js 기반의 대규모 모노레포에서 corepack 아키텍처를 전면 개편한 경험을 공유합니다. react strict mode로 인한 상태 관리 문제, authstore 초기화 문제, 빌더 패턴 적용 등 다양한 기술적 도전을 해결했습니다.  ## 📊 프로젝트 개요  ### 영향 범위  - **프레임워크**: next.js 14, react 18 - **주요 목표**: react strict mode 지원 및 초기화 로직 체계화 - **성과**: 메모리 사용량 30% 감소, 상태 관리 코드 중복 35% 감소  ### 핵심 성과  - ✅ react strict mode 환경 안정성 확보 - ✅ 첫 실행 시 auth 데이터 누락 문제 근본 해결 - ✅ store 인스턴스 단일화로 메모리 최적화 (30% 감소) - ✅ 빌더 패턴 적용으로 초기화 순서 체계화 - ✅ 상태 업데이트 로직 통합으로 코드 중복 감소 (35%) - ✅ 로그인 상태 기반 자동 재빌드 메커니즘 구현 - ✅"},{"slug":"/develop/Next.js 빌드 최적화","frontmatter":{"title":"Next.js 빌드 최적화","date":"2025-12-28T00:00:00.000Z","category":"develop","tags":["Next.js","빌드최적화","Webpack","CI/CD","성능최적화"],"draft":false},"excerpt":"> Next.js 프로젝트에서 빌드 시간을 48% 단축하고 SIGKILL 에러를 100% 해결한 경험을 공유합니다. SSR 전환, ISR 조정 등 여러 방법을 시도했지만 취소했고, 결국 메모리 증가와 캐시 최적화로 문제를 해결했습니다.  ## 📊 최종 성과  ### 로컬 환경 성과  | 지표                 | 이전 (develop) | 현재 (최적화 후) | 개선율            | | -------------------- | -------------- | ---------------- | ----------------- | | **로컬 빌드 시간**   | 462초 (7.7분)  | 154초 (2.6분)    | **-66.7%** ⭐⭐⭐ | | **Next.js Build**    | ~450초         | 141초            | **-68.7%** ⭐⭐⭐ | | **Webpack 컴파일**   | 174초          | 79초","searchableText":"next.js 빌드 최적화 develop next.js 빌드최적화 webpack ci/cd 성능최적화 > next.js 프로젝트에서 빌드 시간을 48% 단축하고 sigkill 에러를 100% 해결한 경험을 공유합니다. ssr 전환, isr 조정 등 여러 방법을 시도했지만 취소했고, 결국 메모리 증가와 캐시 최적화로 문제를 해결했습니다.  ## 📊 최종 성과  ### 로컬 환경 성과  | 지표                 | 이전 (develop) | 현재 (최적화 후) | 개선율            | | -------------------- | -------------- | ---------------- | ----------------- | | **로컬 빌드 시간**   | 462초 (7.7분)  | 154초 (2.6분)    | **-66.7%** ⭐⭐⭐ | | **next.js build**    | ~450초         | 141초            | **-68.7%** ⭐⭐⭐ | | **webpack 컴파일**   | 174초          | 79초"},{"slug":"/develop/React Query 개선","frontmatter":{"title":"React Query 개선","date":"2025-12-28T00:00:00.000Z","category":"develop","tags":["React-Query","Next.js","SSR","Props-Drilling","아키텍처","모노레포"],"draft":false},"excerpt":"> Next.js 기반의 대규모 모노레포에서 React Query 레이어를 구축하여 props drilling을 제거하고 SSR/CSR 환경을 통합 처리한 경험을 공유합니다. Provider level에서 하이드레이트 대응으로 사용처의 react-query 디펜던시를 제거했습니다.  ## 📊 프로젝트 개요  ### 배경  - **프레임워크**: Next.js 14, React 18 - **목표**: props drilling 제거 및 SSR/CSR 환경 통합 처리 - **성과**: 사용처 react-query 디펜던시 제거, 모듈 독립성 확보  ### 핵심 성과  - ✅ Provider level에서 하이드레이트 대응 - ✅ prefetch/query/useQuery를 이용한 props drilling 제거 - ✅ 쿼리 키와 queryFn을 함께 묶어서 사용하여 캐시 미스 방지 - ✅ 사용처 react-query 디펜던시 제거 - ✅ SSR에 컴포넌트를 유연하게 대응 - ✅ 모듈","searchableText":"react query 개선 develop react-query next.js ssr props-drilling 아키텍처 모노레포 > next.js 기반의 대규모 모노레포에서 react query 레이어를 구축하여 props drilling을 제거하고 ssr/csr 환경을 통합 처리한 경험을 공유합니다. provider level에서 하이드레이트 대응으로 사용처의 react-query 디펜던시를 제거했습니다.  ## 📊 프로젝트 개요  ### 배경  - **프레임워크**: next.js 14, react 18 - **목표**: props drilling 제거 및 ssr/csr 환경 통합 처리 - **성과**: 사용처 react-query 디펜던시 제거, 모듈 독립성 확보  ### 핵심 성과  - ✅ provider level에서 하이드레이트 대응 - ✅ prefetch/query/usequery를 이용한 props drilling 제거 - ✅ 쿼리 키와 queryfn을 함께 묶어서 사용하여 캐시 미스 방지 - ✅ 사용처 react-query 디펜던시 제거 - ✅ ssr에 컴포넌트를 유연하게 대응 - ✅ 모듈"},{"slug":"/develop/개발 프로세스 자동화 구축","frontmatter":{"title":"개발 프로세스 자동화 구축","date":"2025-12-28T00:00:00.000Z","category":"develop","tags":["자동화","GitHub-Actions","JIRA","CI/CD","개발프로세스","대시보드","DevOps"],"draft":false},"excerpt":"> GitHub Actions, JIRA API, Confluence API를 활용하여 개발 프로세스를 전면 자동화한 경험을 공유합니다. PR 자동 할당, JIRA 티켓 상태 자동 업데이트, 데일리 리포트 자동 생성으로 개발 생산성을 크게 향상시켰습니다.  ## 📊 프로젝트 개요  ### 목표  - PR 처리 시간 50% 단축 - 개발 프로세스 자동화 구현 - JIRA 티켓과 GitHub PR 연동 - 데일리 업무 리포트 자동 생성  ### 핵심 성과  - ✅ PR 기본 정보 자동화 (어싸이니, 리뷰어, 라벨) - ✅ JIRA 티켓 상태 자동 업데이트 (진행중 → 해결) - ✅ OSS PR 연동 시 티켓 상태 자동 변경 - ✅ 데일리 리포트 자동 생성 (주간보고, 배포 현황, 티켓 브리핑, 코드리뷰) - ✅ 개발 시간 절약 및 프로세스 일관성 확보  ---  ## 🔴 문제 상황  ### 1. 수동 작업의 반복성  **문제**:  - PR 생성 시마다 어싸이니, 리뷰어, 라벨을","searchableText":"개발 프로세스 자동화 구축 develop 자동화 github-actions jira ci/cd 개발프로세스 대시보드 devops > github actions, jira api, confluence api를 활용하여 개발 프로세스를 전면 자동화한 경험을 공유합니다. pr 자동 할당, jira 티켓 상태 자동 업데이트, 데일리 리포트 자동 생성으로 개발 생산성을 크게 향상시켰습니다.  ## 📊 프로젝트 개요  ### 목표  - pr 처리 시간 50% 단축 - 개발 프로세스 자동화 구현 - jira 티켓과 github pr 연동 - 데일리 업무 리포트 자동 생성  ### 핵심 성과  - ✅ pr 기본 정보 자동화 (어싸이니, 리뷰어, 라벨) - ✅ jira 티켓 상태 자동 업데이트 (진행중 → 해결) - ✅ oss pr 연동 시 티켓 상태 자동 변경 - ✅ 데일리 리포트 자동 생성 (주간보고, 배포 현황, 티켓 브리핑, 코드리뷰) - ✅ 개발 시간 절약 및 프로세스 일관성 확보  ---  ## 🔴 문제 상황  ### 1. 수동 작업의 반복성  **문제**:  - pr 생성 시마다 어싸이니, 리뷰어, 라벨을"},{"slug":"/develop/우아한웤플로","frontmatter":{"title":"우아한웤플로","date":"2025-12-28T00:00:00.000Z","category":"develop","tags":["자동화","Slack","JIRA","GitLab","워크플로우","협업","프로덕트","DevOps"],"draft":false},"excerpt":"## 시작하며  \"매일 반복되는 수작업 때문에 정작 중요한 일에 집중할 수 없어요.\"  우아한형제들에서 프론트엔드 개발자로 일하던 중, 여러 팀에서 들려오는 공통된 아쉬움이었습니다. Slack에서 업무 요청을 받으면 Jira에 수동으로 등록하고, 위키 문서를 매번 직접 작성하고, 코드 리뷰 알림을 하나하나 확인하는 일들이 개발자들의 시간을 빼앗고 있었죠.  이런 문제를 해결하기 위해 시작한 프로젝트가 바로 **우아한웤플로**입니다. 단순히 자동화 도구를 만드는 것을 넘어서, 조직의 업무 프로세스를 근본적으로 개선하고 협업 문화를 강화하는 플랫폼을 만들어가는 여정을 공유하고자 합니다.  ---  ## 문제 정의: 파편화된 업무 프로세스  ### 변화하는 업무 환경  제가 입사한 2019년, 우아한형제들의 구성원은 1,000명이 조금 넘었습니다. 하지만 시간이 지나면서 2,000명을 넘어 두 배 이상 늘어났고, 코로나를 지나며 매일 가던 오피스는 일주일에 한 번 가는 것으로 바뀌었습니","searchableText":"우아한웤플로 develop 자동화 slack jira gitlab 워크플로우 협업 프로덕트 devops ## 시작하며  \"매일 반복되는 수작업 때문에 정작 중요한 일에 집중할 수 없어요.\"  우아한형제들에서 프론트엔드 개발자로 일하던 중, 여러 팀에서 들려오는 공통된 아쉬움이었습니다. slack에서 업무 요청을 받으면 jira에 수동으로 등록하고, 위키 문서를 매번 직접 작성하고, 코드 리뷰 알림을 하나하나 확인하는 일들이 개발자들의 시간을 빼앗고 있었죠.  이런 문제를 해결하기 위해 시작한 프로젝트가 바로 **우아한웤플로**입니다. 단순히 자동화 도구를 만드는 것을 넘어서, 조직의 업무 프로세스를 근본적으로 개선하고 협업 문화를 강화하는 플랫폼을 만들어가는 여정을 공유하고자 합니다.  ---  ## 문제 정의: 파편화된 업무 프로세스  ### 변화하는 업무 환경  제가 입사한 2019년, 우아한형제들의 구성원은 1,000명이 조금 넘었습니다. 하지만 시간이 지나면서 2,000명을 넘어 두 배 이상 늘어났고, 코로나를 지나며 매일 가던 오피스는 일주일에 한 번 가는 것으로 바뀌었습니"},{"slug":"/develop/히스토리 복원 시스템 재설계","frontmatter":{"title":"히스토리 복원 시스템 재설계","date":"2025-12-28T00:00:00.000Z","category":"develop","tags":["Next.js","React","히스토리복원","BF-Cache","CSR","SSR","모노레포"],"draft":false},"excerpt":"> Next.js 기반의 히스토리 복원 시스템을 재설계한 경험을 공유합니다. React Strict Mode로 인한 상태 관리 문제, Next.js의 history.state 덮어쓰기 문제, BF Cache 대응 등 다양한 기술적 도전을 해결했습니다.  ## 📊 프로젝트 개요  - **주요 목표**: 완벽한 히스토리 복원 지원 - **기술 스택**: Next.js 14, React 18, TypeScript  ### 핵심 성과  - ✅ 명시적 클릭 이벤트 기반 저장 시스템 구축 - ✅ React Strict Mode로 인한 상태 관리 문제 완벽 해결 - ✅ Next.js의 history.state 덮어쓰기 문제 해결 - ✅ BF Cache 대응 및 CSR/SSR 환경 통합 처리 - ✅ Safari/Chrome 등 모든 브라우저 호환 - ✅ API 호출 최적화 (204 응답 캐싱 처리로 레이아웃 시프트 해결)  ---  ## 🔴 문제 상황  ### 1. 히스토리 복원 키 불일치","searchableText":"히스토리 복원 시스템 재설계 develop next.js react 히스토리복원 bf-cache csr ssr 모노레포 > next.js 기반의 히스토리 복원 시스템을 재설계한 경험을 공유합니다. react strict mode로 인한 상태 관리 문제, next.js의 history.state 덮어쓰기 문제, bf cache 대응 등 다양한 기술적 도전을 해결했습니다.  ## 📊 프로젝트 개요  - **주요 목표**: 완벽한 히스토리 복원 지원 - **기술 스택**: next.js 14, react 18, typescript  ### 핵심 성과  - ✅ 명시적 클릭 이벤트 기반 저장 시스템 구축 - ✅ react strict mode로 인한 상태 관리 문제 완벽 해결 - ✅ next.js의 history.state 덮어쓰기 문제 해결 - ✅ bf cache 대응 및 csr/ssr 환경 통합 처리 - ✅ safari/chrome 등 모든 브라우저 호환 - ✅ api 호출 최적화 (204 응답 캐싱 처리로 레이아웃 시프트 해결)  ---  ## 🔴 문제 상황  ### 1. 히스토리 복원 키 불일치"},{"slug":"/book/업무시각화","frontmatter":{"title":"업무 시각화: 시간 도둑을 잡고 효율적인 업무 흐름 만들기","date":"2025-12-27T21:00:00.000Z","category":"book","tags":["업무시각화","칸반","생산성","시간관리","프로젝트관리"],"draft":false},"excerpt":"> \"업무 시각화 2/e: 효율적으로 업무를 처리하는 시간 관리 비법\"을 읽고 정리한 내용입니다.  ## 들어가며  시간은 우리가 가장 원하는 것인데도 엉망으로 사용한다. 업무를 효율적으로 처리하고 싶지만, 어디서 시간이 사라지는지 모를 때가 많다.   **칸반(Kanban)**은 업무와 문제를 시각화하고, 업무 흐름의 효율성을 개선하기 위한 접근 방식이다. 궁극적인 목적은 **문제를 수면 위로 끌어올리는 것**이다.  이 글에서는 업무 효율성을 저해하는 **시간을 훔쳐가는 다섯 도둑**을 찾아내고, 이를 시각화하여 해결하는 방법을 다룬다.  ---  ## 시간을 훔쳐가는 다섯 도둑  업무 효율성을 저해하는 주요 요인들은 다음과 같다.  ### 1. 너무 많은 진행 중 업무(WIP)  **소화하기 힘들 정도로 초과 업무를 맡는 이유**  1. 우리는 요청한 사람을 좋아한다 2. 우리는 팀에 소속된 사람이다 3. 굴욕감을 느끼기를 두려워한다 4. 새롭고 반짝이는 것을 좋아한다 5.","searchableText":"업무 시각화: 시간 도둑을 잡고 효율적인 업무 흐름 만들기 book 업무시각화 칸반 생산성 시간관리 프로젝트관리 > \"업무 시각화 2/e: 효율적으로 업무를 처리하는 시간 관리 비법\"을 읽고 정리한 내용입니다.  ## 들어가며  시간은 우리가 가장 원하는 것인데도 엉망으로 사용한다. 업무를 효율적으로 처리하고 싶지만, 어디서 시간이 사라지는지 모를 때가 많다.   **칸반(kanban)**은 업무와 문제를 시각화하고, 업무 흐름의 효율성을 개선하기 위한 접근 방식이다. 궁극적인 목적은 **문제를 수면 위로 끌어올리는 것**이다.  이 글에서는 업무 효율성을 저해하는 **시간을 훔쳐가는 다섯 도둑**을 찾아내고, 이를 시각화하여 해결하는 방법을 다룬다.  ---  ## 시간을 훔쳐가는 다섯 도둑  업무 효율성을 저해하는 주요 요인들은 다음과 같다.  ### 1. 너무 많은 진행 중 업무(wip)  **소화하기 힘들 정도로 초과 업무를 맡는 이유**  1. 우리는 요청한 사람을 좋아한다 2. 우리는 팀에 소속된 사람이다 3. 굴욕감을 느끼기를 두려워한다 4. 새롭고 반짝이는 것을 좋아한다 5."},{"slug":"/docs/프로젝트 회고","frontmatter":{"title":"프로젝트 회고 가이드 - KPT 방법론을 활용한 효과적인 회고","date":"2024-06-10T19:07:32.000Z","category":"docs","tags":["회고","KPT","프로젝트관리","협업"],"excerpt":"프로젝트를 함께 진행한 팀원들과 효과적으로 회고를 진행하는 방법을 정리했습니다. KPT(Keep, Problem, Try) 방법론을 활용한 실전 회고 가이드입니다.","draft":false},"excerpt":"프로젝트를 함께 진행한 담당자들과 회고를 진행하는 것은 지나간 일을 돌이켜 생각하고, 더 나은 내일을 계획하는 중요한 과정입니다. 이 글에서는 KPT(Keep, Problem, Try) 방법론을 활용한 효과적인 프로젝트 회고 가이드를 정리했습니다.  ## 회고란?  회고는 지나간 일을 돌이켜 생각해 보고, 더 나은 내일을 계획함을 의미합니다. 프로젝트를 함께 진행한 팀원들이 모여 프로젝트 과정에서의 경험을 공유하고, 개선점을 도출하는 시간입니다.  ## 회고의 장점  ### 1. 중간 모니터링의 계기  동료 구성원 간의 연결을 촉진하여 즉각적인 피드백이 가능해집니다. 프로젝트 진행 중 발생한 이슈를 빠르게 파악하고 대응할 수 있습니다.  ### 2. 투명한 커뮤니케이션  자신의 의견을 투명하게 공유하여 서로가 어떤 일을 하는지, 어떤 도움을 줄 수 있는지 예측 가능해집니다. 이를 통해 동적 목표를 관리할 수 있습니다.  ### 3. 성과 인정과 동기부여  서로가 어떤 도움을 줬는지","searchableText":"프로젝트 회고 가이드 - kpt 방법론을 활용한 효과적인 회고 docs 회고 kpt 프로젝트관리 협업 프로젝트를 함께 진행한 담당자들과 회고를 진행하는 것은 지나간 일을 돌이켜 생각하고, 더 나은 내일을 계획하는 중요한 과정입니다. 이 글에서는 kpt(keep, problem, try) 방법론을 활용한 효과적인 프로젝트 회고 가이드를 정리했습니다.  ## 회고란?  회고는 지나간 일을 돌이켜 생각해 보고, 더 나은 내일을 계획함을 의미합니다. 프로젝트를 함께 진행한 팀원들이 모여 프로젝트 과정에서의 경험을 공유하고, 개선점을 도출하는 시간입니다.  ## 회고의 장점  ### 1. 중간 모니터링의 계기  동료 구성원 간의 연결을 촉진하여 즉각적인 피드백이 가능해집니다. 프로젝트 진행 중 발생한 이슈를 빠르게 파악하고 대응할 수 있습니다.  ### 2. 투명한 커뮤니케이션  자신의 의견을 투명하게 공유하여 서로가 어떤 일을 하는지, 어떤 도움을 줄 수 있는지 예측 가능해집니다. 이를 통해 동적 목표를 관리할 수 있습니다.  ### 3. 성과 인정과 동기부여  서로가 어떤 도움을 줬는지"},{"slug":"/book/가설이 무기가 된다/1장-일단,-가설이-있어야-한다","frontmatter":{"title":"1장 일단, 가설이 있어야 한다","date":"2024-04-20T11:04:07.000Z","category":"가설이 무기가 된다","tags":[],"draft":false},"excerpt":"## 1. 왜 가설사고가 필요한가  ### 문제 해결 속도가 눈에 띄게 빨라진다  - 가설사고는 해답부터 생각하는 것이다.   - 가장 좋은 해답을 가장 짧은 시간에 찾아내는 방법이라고 말할 수도 있다. - 일단 해답을 내놓고 그것을 분해서해서 증명한다. - 일을 시작하기 전에 가설을 세우면 무엇을 해야 할지 그 대상이 분명해지고 논점도 좀 더 깊이 생각할 수 있다.  ### 보는 것만으로 해답을 안다  - 경험을 쌓으면 가설사고 능력이 높아져 단기간에 해답을 낼 수 있다.  ### 현장에서 얻은 자극과 경험을 조합한다  - 오랜 시간 반복적으로 경험을 쌓다 보면 직감이 작용해서 어느 정도 예측은 할 수 있다.  ## 2. 선견지명 능력과 결단력을 지원한다  ### 앞일이 불투명한 상황에서 필요한 것은?  - 직장인에게 중요한 능력은 선견성, 결단력, 실행력이다.   - 선견성과 결단력은 가설사고와 밀접한 관계가 잇다.  ### 오프트 매직은 가설사고에서 탄생했다  - 특성을 바탕","searchableText":"1장 일단, 가설이 있어야 한다 가설이 무기가 된다 ## 1. 왜 가설사고가 필요한가  ### 문제 해결 속도가 눈에 띄게 빨라진다  - 가설사고는 해답부터 생각하는 것이다.   - 가장 좋은 해답을 가장 짧은 시간에 찾아내는 방법이라고 말할 수도 있다. - 일단 해답을 내놓고 그것을 분해서해서 증명한다. - 일을 시작하기 전에 가설을 세우면 무엇을 해야 할지 그 대상이 분명해지고 논점도 좀 더 깊이 생각할 수 있다.  ### 보는 것만으로 해답을 안다  - 경험을 쌓으면 가설사고 능력이 높아져 단기간에 해답을 낼 수 있다.  ### 현장에서 얻은 자극과 경험을 조합한다  - 오랜 시간 반복적으로 경험을 쌓다 보면 직감이 작용해서 어느 정도 예측은 할 수 있다.  ## 2. 선견지명 능력과 결단력을 지원한다  ### 앞일이 불투명한 상황에서 필요한 것은?  - 직장인에게 중요한 능력은 선견성, 결단력, 실행력이다.   - 선견성과 결단력은 가설사고와 밀접한 관계가 잇다.  ### 오프트 매직은 가설사고에서 탄생했다  - 특성을 바탕"},{"slug":"/book/가설이 무기가 된다/0장(서장)-가설사고란-무엇인가","frontmatter":{"title":"0장(서장) 가설사고란 무엇인가","date":"2024-04-20T10:05:39.000Z","category":"가설이 무기가 된다","tags":[],"draft":false},"excerpt":"### 정보가 많으면 올바른 의사결정을 할 수 있을까?  - 사람이 비즈니스에서 모든 것을 조사한다는 진행방식을 활용해서는 바람직한 결과를 얻을 수 없다  ### 이른 단계에서 가설을 세울 수 있으면 좋은 결과를 얻는다  - 일처리가 빠른 사람은 한정된 정보를 토대로 다른 사람보다 빠르고 정확하게 문제점을 발견할 수 있고, 해결책과 연결 할 수 있는 사고법을 갖추고 있다.  ### 가설은 현재 시점에서 '가장 정답에 가깝다'고 여겨지는 해답이다  - 가설은 말 그대로 '가상의 이야기'이며 컨설턴트 세계에서는 '아직 증명되지 않았지만 가정 정답에 가깝다고 여겨지는 해답'이다 - 해답이라고 하지만 그것이 문제인 경도 있고 해결책인 경우도 있다.  ### 비즈니스를 성공으로 이끄는 가설사고를 갖추기 위해  - 가설사고를 갖추면 신속하면서 정확하게 과제의 본질을 해명하고, 그 해결책을 도출해낼 수 있다 - 한정된 정보를 바탕으로 가설사고를 활용하여 가장 적합한 의사결정을 내려야 한다.","searchableText":"0장(서장) 가설사고란 무엇인가 가설이 무기가 된다 ### 정보가 많으면 올바른 의사결정을 할 수 있을까?  - 사람이 비즈니스에서 모든 것을 조사한다는 진행방식을 활용해서는 바람직한 결과를 얻을 수 없다  ### 이른 단계에서 가설을 세울 수 있으면 좋은 결과를 얻는다  - 일처리가 빠른 사람은 한정된 정보를 토대로 다른 사람보다 빠르고 정확하게 문제점을 발견할 수 있고, 해결책과 연결 할 수 있는 사고법을 갖추고 있다.  ### 가설은 현재 시점에서 '가장 정답에 가깝다'고 여겨지는 해답이다  - 가설은 말 그대로 '가상의 이야기'이며 컨설턴트 세계에서는 '아직 증명되지 않았지만 가정 정답에 가깝다고 여겨지는 해답'이다 - 해답이라고 하지만 그것이 문제인 경도 있고 해결책인 경우도 있다.  ### 비즈니스를 성공으로 이끄는 가설사고를 갖추기 위해  - 가설사고를 갖추면 신속하면서 정확하게 과제의 본질을 해명하고, 그 해결책을 도출해낼 수 있다 - 한정된 정보를 바탕으로 가설사고를 활용하여 가장 적합한 의사결정을 내려야 한다."},{"slug":"/docs/내향인도-발표-고수로-만드는-직장인의-발표-스킬-10가지","frontmatter":{"title":"내향인도 발표 고수로 만드는 직장인의 발표 스킬 10가지","date":"2024-04-15T00:04:46.000Z","category":"docs","tags":[],"draft":false},"excerpt":"- [내향인도 발표 고수로 만드는 직장인의 발표 스킬 10가지](https://publy.co/content/7527?c_order=3&c_id=70&fr=home) - [회의, 보고, 발표할 때 바로 써먹는 회사어 전략 - 직장인의 말하기3 [실전편]](https://publy.co/content/5038?fr=chapter-text) - [회사어도 외국어다: 0개 국어 탈출을 위한 직장인의 말하기1 [이론편]](https://publy.co/content/4862?fr=series) - [회사어 완전 정복! 4주 커리큘럼 - 직장인의 말하기2 [연습편]](https://publy.co/set/1016?fr=series)  ## 발표의 기본은 말하기와 태도  ### 1. 회의, 보고, 발표할 때 바로 써먹는 회사어 전략 - 직장인의 말하기  #### 1. 이론편  - 회사어는 정보를 취합해 의견을 전달하는 말이 많을 거예요. 즉, `정보전달`이 주목적입니다.   - 정보전달을 위","searchableText":"내향인도 발표 고수로 만드는 직장인의 발표 스킬 10가지 docs - [내향인도 발표 고수로 만드는 직장인의 발표 스킬 10가지](https://publy.co/content/7527?c_order=3&c_id=70&fr=home) - [회의, 보고, 발표할 때 바로 써먹는 회사어 전략 - 직장인의 말하기3 [실전편]](https://publy.co/content/5038?fr=chapter-text) - [회사어도 외국어다: 0개 국어 탈출을 위한 직장인의 말하기1 [이론편]](https://publy.co/content/4862?fr=series) - [회사어 완전 정복! 4주 커리큘럼 - 직장인의 말하기2 [연습편]](https://publy.co/set/1016?fr=series)  ## 발표의 기본은 말하기와 태도  ### 1. 회의, 보고, 발표할 때 바로 써먹는 회사어 전략 - 직장인의 말하기  #### 1. 이론편  - 회사어는 정보를 취합해 의견을 전달하는 말이 많을 거예요. 즉, `정보전달`이 주목적입니다.   - 정보전달을 위"},{"slug":"/develop/Jira 활용 가이드","frontmatter":{"title":"Jira 활용 가이드 - 효율적인 프로젝트 관리 방법","date":"2024-02-05T15:30:00.000Z","category":"develop","tags":["Jira","프로젝트관리","지라","애자일","티켓관리"],"excerpt":"Jira를 활용한 효율적인 프로젝트 관리 방법을 정리했습니다. 대시보드 설정부터 티켓 작성, 워크플로우 관리까지 실전 경험을 바탕으로 정리했습니다.","draft":false},"excerpt":"Jira는 애자일 프로젝트 관리의 핵심 도구입니다. 하지만 제대로 활용하지 못하면 오히려 업무 효율을 떨어뜨릴 수 있습니다. 이 글에서는 실제 프로젝트에서 사용한 Jira 활용 방법을 정리했습니다.  ## 대시보드 설정  대시보드는 프로젝트의 전체적인 상황을 한눈에 파악할 수 있는 핵심 화면입니다. 다음과 같은 가젯을 활용하여 구성합니다.  ### Configure Rich Filter Smart Counters Gadget  - **상태별 이슈 카운트**: 각 상태(TODO, DOING, DONE 등)별로 티켓 수를 한눈에 확인  ### Configure Rich Filter Results Gadget  - **작업 티켓 목록**: 현재 진행 중인 작업 티켓들을 표시 - **Smart filters, Views 활용**: 커스텀 필터와 뷰를 활용하여 필요한 정보만 표시  ### Rich Filter Simple Gauge  - **스토리 포인트 진행률**: 스프린트 내 스토리 포","searchableText":"jira 활용 가이드 - 효율적인 프로젝트 관리 방법 develop jira 프로젝트관리 지라 애자일 티켓관리 jira는 애자일 프로젝트 관리의 핵심 도구입니다. 하지만 제대로 활용하지 못하면 오히려 업무 효율을 떨어뜨릴 수 있습니다. 이 글에서는 실제 프로젝트에서 사용한 jira 활용 방법을 정리했습니다.  ## 대시보드 설정  대시보드는 프로젝트의 전체적인 상황을 한눈에 파악할 수 있는 핵심 화면입니다. 다음과 같은 가젯을 활용하여 구성합니다.  ### configure rich filter smart counters gadget  - **상태별 이슈 카운트**: 각 상태(todo, doing, done 등)별로 티켓 수를 한눈에 확인  ### configure rich filter results gadget  - **작업 티켓 목록**: 현재 진행 중인 작업 티켓들을 표시 - **smart filters, views 활용**: 커스텀 필터와 뷰를 활용하여 필요한 정보만 표시  ### rich filter simple gauge  - **스토리 포인트 진행률**: 스프린트 내 스토리 포"},{"slug":"/book/이펙티브 엔지니어/0장-글","frontmatter":{"title":"0장 글","date":"2024-01-17T22:09:37.000Z","category":"이펙티브 엔지니어","tags":["이펙티브"],"draft":false},"excerpt":"## 지은이 서문  ### 이펙티브 엔지니어란 어떤 개발자일까?  - 효울적으로 임무를 완수하는 사람 - 가치와 효과를 내는 데 집중하며 어떤 성과를 낼지 선택할 줄도 아는 사람 - 일한 시간당 생산하는 가치의 비율로 정의된다.  ## 이 책에서 배우는 내용  - 효율성에서 매우 중요하지만 개발자들이 종종 간과하는 것이 `메타 기술(다른 기능적인 기술을 빠르고 효율적으로 습득할 수 있는 기술)`이다. 메타 기술은 시간과 에너지를 어디에 집중해야 들어간 노력에 대비 더 큰 효과로 이어질지 알아내는 데 도움이 된다. - 레버리지라는 유용한 프레임워크는 영향력을 높이는 데 필요한, 실행 가능한 도구를 갖추게 해 줄 것이다. 그리고 소중한 시간과 에너지를 낭비하게 하는 엔지니어링 분야의 일반적인 함정에 대한 통찰력도 기를 수 있다.","searchableText":"0장 글 이펙티브 엔지니어 이펙티브 ## 지은이 서문  ### 이펙티브 엔지니어란 어떤 개발자일까?  - 효울적으로 임무를 완수하는 사람 - 가치와 효과를 내는 데 집중하며 어떤 성과를 낼지 선택할 줄도 아는 사람 - 일한 시간당 생산하는 가치의 비율로 정의된다.  ## 이 책에서 배우는 내용  - 효율성에서 매우 중요하지만 개발자들이 종종 간과하는 것이 `메타 기술(다른 기능적인 기술을 빠르고 효율적으로 습득할 수 있는 기술)`이다. 메타 기술은 시간과 에너지를 어디에 집중해야 들어간 노력에 대비 더 큰 효과로 이어질지 알아내는 데 도움이 된다. - 레버리지라는 유용한 프레임워크는 영향력을 높이는 데 필요한, 실행 가능한 도구를 갖추게 해 줄 것이다. 그리고 소중한 시간과 에너지를 낭비하게 하는 엔지니어링 분야의 일반적인 함정에 대한 통찰력도 기를 수 있다."},{"slug":"/book/프로그래머의 뇌/08장-명명을-잘하는-방법","frontmatter":{"title":"08장 명명을 잘하는 방법","date":"2022-12-11T22:13:39.000Z","category":"프로그래머의 뇌","tags":[],"draft":false},"excerpt":"### 이 장에서는 다음과 같은 내용을 다룬다.  - 좋은 이름 짓기에 대한 여러 가지 관점의 비교 - 이름과 인지 과정 간의 관계 파악 - 다양한 명명법의 효과 - 잘못된 이름이 버그 및 오류에 미치는 영향 - 변수 이름을 구조화하여 이해도를 극대화하는 방법  ## 서론  - 8장부터는 코드를 작성하는 과정을 살펴본다. - 좋은 이름을 사용하면 LTM을 활성화하여 코드 도메인에 대해 이미 알고 있는 관련 정보를 찾을 수 있다.   - 반면, 나쁜 이름은 코드에 대한 잘못된 추측을 하게 하고 오개념을 유발할 수 있다. - 작업 기억의 용량을 초과하지 않도록 쉬운 이름을 선택하는 것이 인지적 관점에서 타당하다.  ## 8.1 이름이 중요한 이유  ### 8.1.1 명명이 중요한 이유  - 이름은 코드베이스의 상단 부분을 차지한다.   - 200만 줄의 코드로 구성된 이클립스 소스 코드에서 토큰의 33%, 문자의 72%가 식별자에 해당된다. - 코드 리뷰 시 이름의 역할   - 코드","searchableText":"08장 명명을 잘하는 방법 프로그래머의 뇌 ### 이 장에서는 다음과 같은 내용을 다룬다.  - 좋은 이름 짓기에 대한 여러 가지 관점의 비교 - 이름과 인지 과정 간의 관계 파악 - 다양한 명명법의 효과 - 잘못된 이름이 버그 및 오류에 미치는 영향 - 변수 이름을 구조화하여 이해도를 극대화하는 방법  ## 서론  - 8장부터는 코드를 작성하는 과정을 살펴본다. - 좋은 이름을 사용하면 ltm을 활성화하여 코드 도메인에 대해 이미 알고 있는 관련 정보를 찾을 수 있다.   - 반면, 나쁜 이름은 코드에 대한 잘못된 추측을 하게 하고 오개념을 유발할 수 있다. - 작업 기억의 용량을 초과하지 않도록 쉬운 이름을 선택하는 것이 인지적 관점에서 타당하다.  ## 8.1 이름이 중요한 이유  ### 8.1.1 명명이 중요한 이유  - 이름은 코드베이스의 상단 부분을 차지한다.   - 200만 줄의 코드로 구성된 이클립스 소스 코드에서 토큰의 33%, 문자의 72%가 식별자에 해당된다. - 코드 리뷰 시 이름의 역할   - 코드"},{"slug":"/book/이펙티브 엔지니어/1장-레버리지가-높은-활동에-집중하라","frontmatter":{"title":"1장 레버리지가 높은 활동에 집중하라","date":"2022-09-04T22:09:37.000Z","category":"이펙티브 엔지니어","tags":["Part1 올바른 마인드셋을 갖춰라"],"draft":false},"excerpt":"- 신입 개발자를 효과적으로 온보딩한다면 직접 만든 어떤 코드보다 더 큰 효과를 낼 것이다.  ## 레버리지를 효과성의 측정 기준으로 삼아라  - 레버리지란 투자한 시간당 생산한 가치, 또는 효과이다.   - 레버리지 = 생산한 효과 / 투자한 시간 - 레버리지는 투입한 노력에 대한 `투자 자본 수익률(Return On Investment, ROI)`이다. - 이펙티브 엔지니어는 업무를 효율적으로 완수하고, 제한된 시간에 더 많은 가치를 생산한다. - 레버리지가 매우 중요한 이유는 `시간이 가장 제한적인 자원이기 때문`이다. - 신입 개발자를 최대한 빠르고 매끄럽게 양성하는 프로그램에 투자하는 건 우리가 할 수 있는 일 중에서 레버리지가 매우 높은 일이다.  ## 레버리지를 늘리는 세 가지 방법  1. 특정 활동을 완료하는 데 드는 시간 줄이기 2. 특정 활동의 생산량 늘리기 3. 레버리지가 높은 활동으로 전환하기  ### 질문 세 가지  1. 이 활동을 더 짧은 시간에 완료하려면","searchableText":"1장 레버리지가 높은 활동에 집중하라 이펙티브 엔지니어 part1 올바른 마인드셋을 갖춰라 - 신입 개발자를 효과적으로 온보딩한다면 직접 만든 어떤 코드보다 더 큰 효과를 낼 것이다.  ## 레버리지를 효과성의 측정 기준으로 삼아라  - 레버리지란 투자한 시간당 생산한 가치, 또는 효과이다.   - 레버리지 = 생산한 효과 / 투자한 시간 - 레버리지는 투입한 노력에 대한 `투자 자본 수익률(return on investment, roi)`이다. - 이펙티브 엔지니어는 업무를 효율적으로 완수하고, 제한된 시간에 더 많은 가치를 생산한다. - 레버리지가 매우 중요한 이유는 `시간이 가장 제한적인 자원이기 때문`이다. - 신입 개발자를 최대한 빠르고 매끄럽게 양성하는 프로그램에 투자하는 건 우리가 할 수 있는 일 중에서 레버리지가 매우 높은 일이다.  ## 레버리지를 늘리는 세 가지 방법  1. 특정 활동을 완료하는 데 드는 시간 줄이기 2. 특정 활동의 생산량 늘리기 3. 레버리지가 높은 활동으로 전환하기  ### 질문 세 가지  1. 이 활동을 더 짧은 시간에 완료하려면"},{"slug":"/develop/first-class-citizen","frontmatter":{"title":"First-class citizen","date":"2022-04-14T23:04:15.000Z","category":"develop","tags":[],"draft":false},"excerpt":"## 1급 객체의 조건 3가지  - 변수나 데이타에 할당 할 수 있어야 합니다. - 객체의 인자로 넘길 수 있어야 합니다. - 객체의 리턴값으로 리턴 할수 있어야 합니다.   ## 자바에서의 1급 객체란?  - JAVA에서는 함수가 1급 객체에 해당하지 않습니다. Kotlin, JavaScript 등의 언어에서는 변수에 함수를 할당하고 사용할 수 있지만 JAVA는 불가능합니다. - JAVA의 Lambda는 메서드가 1개만 존재하는 인터페이스/클래스를 통해, 마치 함수를 전달하는 것처럼 여겨서, 함수를 1급 객체로 취급하지 않는 JAVA의 단점을 어느정도나마 해결한 것이라고 볼 수 있습니다.   - 람다식을 자바 8에서는 함수형 인터페이스로 정의합니다. 함수형 인터페이스는 메서드가 하나만 정의되어있다고 약속한 인터페이스입니다. 이 약속을 통해서 이 인터페이스를 구현한 객체에는 함수 하나만 있다고 믿고 자바는 마치 함수처럼 코드를 작성하고 표현할 수 있는 것입니다.","searchableText":"first-class citizen develop ## 1급 객체의 조건 3가지  - 변수나 데이타에 할당 할 수 있어야 합니다. - 객체의 인자로 넘길 수 있어야 합니다. - 객체의 리턴값으로 리턴 할수 있어야 합니다.   ## 자바에서의 1급 객체란?  - java에서는 함수가 1급 객체에 해당하지 않습니다. kotlin, javascript 등의 언어에서는 변수에 함수를 할당하고 사용할 수 있지만 java는 불가능합니다. - java의 lambda는 메서드가 1개만 존재하는 인터페이스/클래스를 통해, 마치 함수를 전달하는 것처럼 여겨서, 함수를 1급 객체로 취급하지 않는 java의 단점을 어느정도나마 해결한 것이라고 볼 수 있습니다.   - 람다식을 자바 8에서는 함수형 인터페이스로 정의합니다. 함수형 인터페이스는 메서드가 하나만 정의되어있다고 약속한 인터페이스입니다. 이 약속을 통해서 이 인터페이스를 구현한 객체에는 함수 하나만 있다고 믿고 자바는 마치 함수처럼 코드를 작성하고 표현할 수 있는 것입니다."},{"slug":"/book/객체지향의 사실과 오해/부록a-추상화-기법","frontmatter":{"title":"부록A 추상화 기법","date":"2022-03-15T22:04:07.000Z","category":"객체지향의 사실과 오해","tags":[],"draft":false},"excerpt":"## 추상화 기법  - 추상화는 도메인의 복잡성을 단순화하고 직관적인 멘탈 모델을 만드는 데 사용할 수 있는 가장 기본적인 인지 수단입니다.  - 사람들은 도메인에 존재하는 개념들을 구조화하고 단순화하기 위해 다양한 추상화 기법을 사용합니다. - 특성을 공유하는 객체들을 동일한 타입으로 분류하는 것은 객체지향 패러다임에서 사용하는 추상화 기법의 한 예입니다.   ### 추상화 기법  - 객체지향의 가장 큰 장점은 동일한 추상화 기법을 프로그램의 분석, 설계, 구현 단계에 걸쳐 일관성 있게 적용할 수 있다는 점입니다. - 추상화 기법의 종류   - 분류와 인스턴스화 : `분류`는 객체의 구체적인  세부 사항을 숨기고 인스턴스 간에 공유하는 공통적인 특성을 기반으로 범주를 형성하는 과정입니다. 분류의 역은 범주로부터 객체를 생성하는 `인스턴스화` 과정입니다.   - 일반화와 특수화 : `일반화`는 범주 사이의 차이를 숨기고 범주 간에 공유하는 공통적인 특성을 강조합니다. 일반화의 역을","searchableText":"부록a 추상화 기법 객체지향의 사실과 오해 ## 추상화 기법  - 추상화는 도메인의 복잡성을 단순화하고 직관적인 멘탈 모델을 만드는 데 사용할 수 있는 가장 기본적인 인지 수단입니다.  - 사람들은 도메인에 존재하는 개념들을 구조화하고 단순화하기 위해 다양한 추상화 기법을 사용합니다. - 특성을 공유하는 객체들을 동일한 타입으로 분류하는 것은 객체지향 패러다임에서 사용하는 추상화 기법의 한 예입니다.   ### 추상화 기법  - 객체지향의 가장 큰 장점은 동일한 추상화 기법을 프로그램의 분석, 설계, 구현 단계에 걸쳐 일관성 있게 적용할 수 있다는 점입니다. - 추상화 기법의 종류   - 분류와 인스턴스화 : `분류`는 객체의 구체적인  세부 사항을 숨기고 인스턴스 간에 공유하는 공통적인 특성을 기반으로 범주를 형성하는 과정입니다. 분류의 역은 범주로부터 객체를 생성하는 `인스턴스화` 과정입니다.   - 일반화와 특수화 : `일반화`는 범주 사이의 차이를 숨기고 범주 간에 공유하는 공통적인 특성을 강조합니다. 일반화의 역을"},{"slug":"/typescript/타입스크립트-모델링","frontmatter":{"title":"타입스크립트 모델링","date":"2022-02-07T20:02:09.000Z","category":"typescript","tags":[],"draft":false},"excerpt":"## 타입스크립트의 타이핑  - 자바스크립트는 덕 타이핑(duck typing) 기반이고 타입스크립트가 이를 모델링하기 위해 `구조적 타이핑`을 사용합니다.   - 타입스크립트가 구조적 타이핑을 도입한 이유는 동적 타입 언어인 자바스크립트를 기반으로 하기 때문입니다.   - Java 기반의 객체지향에서는 `명목적 타이핑`을 사용합니다.  ## 구조적 타이핑이란?  - 구조적 타이핑은 값 자체의 타입보다는 값이 가진 `내부 구조`에 기반해서 타입 호환성을 검사한다. - **좋든 싫든 타입은 열려있습니다**. - 타입스크립트의 클래스 역시 구조적 타이핑 규칙을 따릅니다.   - 클래스의 인스턴스가 Java 기반의 객체지향과 다를 수 있습니다. - 어떤 인터페이스에 할당 가능한 값이라면 타입 선언에 명시적으로 나열된 속성들을 가지고 있을 겁니다. 타입은 `봉인`되어 있지 않습니다. - 추가 속성이 있으면 값의 집합은 더 작아집니다. - 반대로 유니온 타입이 있으면 값의 집합은 더 커집니","searchableText":"타입스크립트 모델링 typescript ## 타입스크립트의 타이핑  - 자바스크립트는 덕 타이핑(duck typing) 기반이고 타입스크립트가 이를 모델링하기 위해 `구조적 타이핑`을 사용합니다.   - 타입스크립트가 구조적 타이핑을 도입한 이유는 동적 타입 언어인 자바스크립트를 기반으로 하기 때문입니다.   - java 기반의 객체지향에서는 `명목적 타이핑`을 사용합니다.  ## 구조적 타이핑이란?  - 구조적 타이핑은 값 자체의 타입보다는 값이 가진 `내부 구조`에 기반해서 타입 호환성을 검사한다. - **좋든 싫든 타입은 열려있습니다**. - 타입스크립트의 클래스 역시 구조적 타이핑 규칙을 따릅니다.   - 클래스의 인스턴스가 java 기반의 객체지향과 다를 수 있습니다. - 어떤 인터페이스에 할당 가능한 값이라면 타입 선언에 명시적으로 나열된 속성들을 가지고 있을 겁니다. 타입은 `봉인`되어 있지 않습니다. - 추가 속성이 있으면 값의 집합은 더 작아집니다. - 반대로 유니온 타입이 있으면 값의 집합은 더 커집니"},{"slug":"/javascript/prototype","frontmatter":{"title":"prototype","date":"2022-01-20T00:02:22.000Z","category":"javascript","tags":[],"draft":false},"excerpt":"## 1. 프로토타입 객체  - Java, C++과 같은 클래스 기반 객체지향 프로그래밍 언어와 달리 자바스크립트는 프로토타입 기반 객체지향 프로그래밍 언어입니다.   - [자바스크립트는 왜 프로토타입을 선택했을까](https://medium.com/@limsungmook/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%99%9C-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%84-%EC%84%A0%ED%83%9D%ED%96%88%EC%9D%84%EA%B9%8C-997f985adb42)   - 프로토타입 기반 객체지향 프로그래밍 언어는 클래스 없이(Class-less)도 객체를 생성할 수 있습니다.(ECMAScript 6에서 클래스가 추가되었습니다.) - 프로토타입 패턴으로 객체를 생성하는 방법은, 자바스크립트의 가장 자연스러운 객체 생성 패턴입니다. - new를","searchableText":"prototype javascript ## 1. 프로토타입 객체  - java, c++과 같은 클래스 기반 객체지향 프로그래밍 언어와 달리 자바스크립트는 프로토타입 기반 객체지향 프로그래밍 언어입니다.   - [자바스크립트는 왜 프로토타입을 선택했을까](https://medium.com/@limsungmook/%ec%9e%90%eb%b0%94%ec%8a%a4%ed%81%ac%eb%a6%bd%ed%8a%b8%eb%8a%94-%ec%99%9c-%ed%94%84%eb%a1%9c%ed%86%a0%ed%83%80%ec%9e%85%ec%9d%84-%ec%84%a0%ed%83%9d%ed%96%88%ec%9d%84%ea%b9%8c-997f985adb42)   - 프로토타입 기반 객체지향 프로그래밍 언어는 클래스 없이(class-less)도 객체를 생성할 수 있습니다.(ecmascript 6에서 클래스가 추가되었습니다.) - 프로토타입 패턴으로 객체를 생성하는 방법은, 자바스크립트의 가장 자연스러운 객체 생성 패턴입니다. - new를"},{"slug":"/javascript/자바스크립트-조금-더-알아보기","frontmatter":{"title":"자바스크립트 조금 더 알아보기","date":"2022-01-19T23:01:46.000Z","category":"javascript","tags":["javascript"],"draft":false},"excerpt":"## 1. 실행 컨텍스트(Execution Context)  - 코드를 실행하기 위해 필요한 정보들을 가진 범위를 객체 형태로 나타낸 것입니다. 코드의 실제 진행 상황을 추적하는데 도움이 됩니다.   - 전역 공간에서 자동으로 생성되는 전연 컨텍스트   - 함수 실행에 의한 컨텍스트   - eval함수 - 자바스크립트가 로드되고 이를 엔진이 처리하면서 실행 컨텍스트를 만듭니다. 어떤 코드를 실행하고 이 컨텍스트에는 어떤 변수들이 있는지 알기 위한 정보들이 있습니다. - 실행 컨텍스트를 구성하는 LexicalEnvironment는 현재의 실행 컨텍스트가 실행되기 위한 여러 정보를 담고 있습니다. LexicalEnvironment는 식별자들에 대한 정보를 담은 EnvironmentRecord와, 상위 LexicalEnvironment를 참조해 스코프 체인을 가능하게 하는 OuterEnvironmentReference 정보로 구성되어 있습니다. EnvironmentRecord는 식별자","searchableText":"자바스크립트 조금 더 알아보기 javascript javascript ## 1. 실행 컨텍스트(execution context)  - 코드를 실행하기 위해 필요한 정보들을 가진 범위를 객체 형태로 나타낸 것입니다. 코드의 실제 진행 상황을 추적하는데 도움이 됩니다.   - 전역 공간에서 자동으로 생성되는 전연 컨텍스트   - 함수 실행에 의한 컨텍스트   - eval함수 - 자바스크립트가 로드되고 이를 엔진이 처리하면서 실행 컨텍스트를 만듭니다. 어떤 코드를 실행하고 이 컨텍스트에는 어떤 변수들이 있는지 알기 위한 정보들이 있습니다. - 실행 컨텍스트를 구성하는 lexicalenvironment는 현재의 실행 컨텍스트가 실행되기 위한 여러 정보를 담고 있습니다. lexicalenvironment는 식별자들에 대한 정보를 담은 environmentrecord와, 상위 lexicalenvironment를 참조해 스코프 체인을 가능하게 하는 outerenvironmentreference 정보로 구성되어 있습니다. environmentrecord는 식별자"},{"slug":"/develop/osi-7-계층","frontmatter":{"title":"OSI 7 계층","date":"2021-10-22T23:10:19.000Z","category":"develop","tags":[],"draft":false},"excerpt":"## Layered 아키텍처를 따르는 대표적인 예 - 네트워크 시스템  - OSI 7 Layer 모델은 거대한 네트워크 소프트웨어 구조를 설명하는 것입니다.  ## OSI 7 계층  - OSI 7 계층은 국제표준화기구(International Standard Organization, ISO)에서 1984년에 발표한 네트워크 표준 모델입니다. - OSI 모델(Open Systems Interconnection Model)은 국제 표준화 기구(International Organization for Standardization, IOS)에서 만든 컴퓨터의 통신 기능을 계층 구조로 나눈 모델입니다. 이를 이용하면 특정 네트워킹 시스템에서 일어나는 일을 계층을 활용해 시각적으로 이해할 수 있습니다. 총 7계층으로 이루어져 있습니다. 데이터가 네트워크로 나갈 때는 위층에서부터, 네트워크에서 데이터를 받을 때는 아래층에서부터 들어옵니다. - 하위계층으로 갈수록 하드웨어에 가까워지고, 상위계층으","searchableText":"osi 7 계층 develop ## layered 아키텍처를 따르는 대표적인 예 - 네트워크 시스템  - osi 7 layer 모델은 거대한 네트워크 소프트웨어 구조를 설명하는 것입니다.  ## osi 7 계층  - osi 7 계층은 국제표준화기구(international standard organization, iso)에서 1984년에 발표한 네트워크 표준 모델입니다. - osi 모델(open systems interconnection model)은 국제 표준화 기구(international organization for standardization, ios)에서 만든 컴퓨터의 통신 기능을 계층 구조로 나눈 모델입니다. 이를 이용하면 특정 네트워킹 시스템에서 일어나는 일을 계층을 활용해 시각적으로 이해할 수 있습니다. 총 7계층으로 이루어져 있습니다. 데이터가 네트워크로 나갈 때는 위층에서부터, 네트워크에서 데이터를 받을 때는 아래층에서부터 들어옵니다. - 하위계층으로 갈수록 하드웨어에 가까워지고, 상위계층으"},{"slug":"/javascript/타입스크립트의-오버로드","frontmatter":{"title":"타입스크립트의 오버로드","date":"2021-08-14T01:08:02.000Z","category":"javascript","tags":[],"draft":false},"excerpt":"## 오버로드  - C나 Java같은 정적 타입 언어의 경우, 매개변수의 갯수와 타입에 따라서 정적으로 여러 개의 함수를 구현할 수 있습니다. 하지만 JavaScript는 하나의 함수 내부에서 `타입 검사`를 해서 동적으로 오버로딩을 구현할 수 있습니다. - TypeScript의 경우, 오버로딩이 불가능하지는 않지만 그 방식은 정적 타입 언어인 C나 Java보다는 동적 타입언어인 JavaScript와 유사합니다. 다른 인자를 받는 여러 개의 함수를 구현하는 것이 아니라, `하나의 함수에서 인자의 타입이나 갯수에 따라 여러 분기`를 태우는 것입니다. - 일단 TypeScript는 함수에 정해진 타입과 정해진 수의 인자를 넘기지 않으면 에러를 발생시키므로 함수를 선언할 때 어느정도의 유연성을 확보해야 오버로딩을 구현할 수 있습니다. 인자 갯수의 유연성을 확보하는 것이 바로 `Optional Parameter` 입니다.  ### 하고 싶은 오버로드(비지터 패턴)  ```java publ","searchableText":"타입스크립트의 오버로드 javascript ## 오버로드  - c나 java같은 정적 타입 언어의 경우, 매개변수의 갯수와 타입에 따라서 정적으로 여러 개의 함수를 구현할 수 있습니다. 하지만 javascript는 하나의 함수 내부에서 `타입 검사`를 해서 동적으로 오버로딩을 구현할 수 있습니다. - typescript의 경우, 오버로딩이 불가능하지는 않지만 그 방식은 정적 타입 언어인 c나 java보다는 동적 타입언어인 javascript와 유사합니다. 다른 인자를 받는 여러 개의 함수를 구현하는 것이 아니라, `하나의 함수에서 인자의 타입이나 갯수에 따라 여러 분기`를 태우는 것입니다. - 일단 typescript는 함수에 정해진 타입과 정해진 수의 인자를 넘기지 않으면 에러를 발생시키므로 함수를 선언할 때 어느정도의 유연성을 확보해야 오버로딩을 구현할 수 있습니다. 인자 갯수의 유연성을 확보하는 것이 바로 `optional parameter` 입니다.  ### 하고 싶은 오버로드(비지터 패턴)  ```java publ"},{"slug":"/javascript/javascript-call-by-reference가-존재하는가","frontmatter":{"title":"javascript call by reference가 존재하는가","date":"2021-07-26T00:08:23.000Z","category":"javascript","tags":[],"draft":false},"excerpt":"## Call by reference란 무엇인가?  ### Call by reference를 알기 위해 평가 전략(컴퓨터 프로그래밍)을 먼저 보겠습니다.  - 평가 전략(Evaluation Strategy)은 프로그래밍 언어에서 함수 호출의 아규먼트(argument)의 순서를 언제 결정하고 함수에 어떤 종류의 값을 통과시킬지 결정하는 것입니다. - 람다 대수에서 축소 전략(reduction strategy)과 유사하지만 다릅니다. - 근래의 대부분의 프로그래밍 언어들은 값에 의한 호출(call-by-value)과 참조에 의한 전달(pass-by-reference)가 통합되고 있습니다.  ### call-by-value에 대해서도 짚어보고 가겠습니다.  - 값이 넘어올 때 복사된 값이 넘어옵니다. - caller(호출하는 녀석)가 인자를 복사해서 넘겨줬으므로 callee(호출당한 녀석)에서 해당 인자를 지지고 볶아도 caller는 영향을 받지 않습니다. - 기본적으로 자바스크립트는","searchableText":"javascript call by reference가 존재하는가 javascript ## call by reference란 무엇인가?  ### call by reference를 알기 위해 평가 전략(컴퓨터 프로그래밍)을 먼저 보겠습니다.  - 평가 전략(evaluation strategy)은 프로그래밍 언어에서 함수 호출의 아규먼트(argument)의 순서를 언제 결정하고 함수에 어떤 종류의 값을 통과시킬지 결정하는 것입니다. - 람다 대수에서 축소 전략(reduction strategy)과 유사하지만 다릅니다. - 근래의 대부분의 프로그래밍 언어들은 값에 의한 호출(call-by-value)과 참조에 의한 전달(pass-by-reference)가 통합되고 있습니다.  ### call-by-value에 대해서도 짚어보고 가겠습니다.  - 값이 넘어올 때 복사된 값이 넘어옵니다. - caller(호출하는 녀석)가 인자를 복사해서 넘겨줬으므로 callee(호출당한 녀석)에서 해당 인자를 지지고 볶아도 caller는 영향을 받지 않습니다. - 기본적으로 자바스크립트는"},{"slug":"/design-pattern/dependency-injection-pattern","frontmatter":{"title":"dependency injection pattern","date":"2021-04-15T10:05:33.000Z","category":"design pattern","tags":["design pattern"],"draft":false},"excerpt":"## Object Dependencies(객체 의존성)  - 현재 객체가 다른 객체와 상호작용(참조)하고 있다면 현재 객체는 다른 객체에 의존성을 가집니다. - 하나의 모듈이 바뀌면 의존한 다른 모듈까지 변경 되어야 합니다. 또한 두 객체 사이의 의존성이 존재하면 Unit Test 작성이 어려워집니다. - `의존성`은 서비스로 사용할 수 있는 객체입니다.  ## Dependency Injection(의존성 주입)  - 의존성 주입은 `역 제어(Inversion of Control, IOC) 테크닉의 한 형태`로 어떤 서비스를 호출하려는 컴포넌트는 그 서비스가 어떻게 구성되었는지 알지 못해야 합니다. - 클라이언트가 어떤 서비스를 사용할 것인지 지정하는 대신, 클라이언트에게 무슨 서비스를 사용할 것인지를 말(주입)해주는 것이다.   - `주입`은 의존성(서비스)을 사용하려는 객체(클라이언트)로 전달하는 것을 의미합니다. 서비스는 클라이언트 상태의 일부입니다. 클라이언트가 서비스를 구","searchableText":"dependency injection pattern design pattern design pattern ## object dependencies(객체 의존성)  - 현재 객체가 다른 객체와 상호작용(참조)하고 있다면 현재 객체는 다른 객체에 의존성을 가집니다. - 하나의 모듈이 바뀌면 의존한 다른 모듈까지 변경 되어야 합니다. 또한 두 객체 사이의 의존성이 존재하면 unit test 작성이 어려워집니다. - `의존성`은 서비스로 사용할 수 있는 객체입니다.  ## dependency injection(의존성 주입)  - 의존성 주입은 `역 제어(inversion of control, ioc) 테크닉의 한 형태`로 어떤 서비스를 호출하려는 컴포넌트는 그 서비스가 어떻게 구성되었는지 알지 못해야 합니다. - 클라이언트가 어떤 서비스를 사용할 것인지 지정하는 대신, 클라이언트에게 무슨 서비스를 사용할 것인지를 말(주입)해주는 것이다.   - `주입`은 의존성(서비스)을 사용하려는 객체(클라이언트)로 전달하는 것을 의미합니다. 서비스는 클라이언트 상태의 일부입니다. 클라이언트가 서비스를 구"},{"slug":"/design-pattern/singleton-pattern","frontmatter":{"title":"singleton pattern","date":"2021-04-14T21:05:29.000Z","category":"design pattern","tags":["design pattern"],"draft":false},"excerpt":"## 생성 패턴  - 디자인 패턴 분류인 생성, 구조, 행위 중 객체 생성에 관련 된 `생성 패턴`으로 간주됩니다. - 생성 패턴은 객체의 생성과 조합을 캡슐화해 특정 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 유연성을 제공합니다.  ## 단 `하나`의 인스턴스를 생성해 사용하는 디자인 패턴(`유일한` 객체를 생성하는 방법)  - 애플리케이션이 시작될 때 어떤 클래스가 `최초 한번만` 메모리를 할당하고(static) 그 메모리에 인스턴스를 만들어 사용하는 디자인패턴입니다.   - 전역 변수를 사용하지 않고 `객체를 하나만 생성` 하도록 하며, 생성된 객체를 `어디에서든지 참조`할 수 있습니다.   - 생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 `하나`고 최초 생성 이후에 호출된 생성자는 `최초에 생성한 객체를 반환`합니다. - 유일한 인스턴스가 서브클래싱으로 확장되어야 하며, 사용자는 코드의 수정없이 확장된 서브클래스의 인스턴스를 사용할 수","searchableText":"singleton pattern design pattern design pattern ## 생성 패턴  - 디자인 패턴 분류인 생성, 구조, 행위 중 객체 생성에 관련 된 `생성 패턴`으로 간주됩니다. - 생성 패턴은 객체의 생성과 조합을 캡슐화해 특정 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 유연성을 제공합니다.  ## 단 `하나`의 인스턴스를 생성해 사용하는 디자인 패턴(`유일한` 객체를 생성하는 방법)  - 애플리케이션이 시작될 때 어떤 클래스가 `최초 한번만` 메모리를 할당하고(static) 그 메모리에 인스턴스를 만들어 사용하는 디자인패턴입니다.   - 전역 변수를 사용하지 않고 `객체를 하나만 생성` 하도록 하며, 생성된 객체를 `어디에서든지 참조`할 수 있습니다.   - 생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 `하나`고 최초 생성 이후에 호출된 생성자는 `최초에 생성한 객체를 반환`합니다. - 유일한 인스턴스가 서브클래싱으로 확장되어야 하며, 사용자는 코드의 수정없이 확장된 서브클래스의 인스턴스를 사용할 수"},{"slug":"/design-pattern/state-pattern","frontmatter":{"title":"state pattern","date":"2021-03-21T13:03:24.000Z","category":"design pattern","tags":["design pattern"],"draft":false},"excerpt":"## 디자인 패턴이란?  - 반복적으로 나타난 문제에 대해 그것을 해결한 경험 및 노하우를 축적하여 `재사용하기 좋은 형태로` 이름을 붙여 `해법을 제시하는 패턴`양식 입니다. - 디자인 패턴은 크게 3가지 분류가 있습니다.   - 생성 패턴 : 객체 생성과 관련된 패턴   - 구조 패턴 : 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴   - 행위 패턴 : 객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴  ## 행위 소프트웨어 디자인 패턴  - 상태 패턴(state pattern)은 객체 지향 방식으로 상태 기계를 구현하는 `행위` 소프트웨어 디자인 패턴입니다.  ## 변하는 것은 잘 변하지 않는 것과 분리해라. 즉, 변하는 녀석들을 캡슐화해라!  - 스테이트 패턴은 객체가 `특정 상태에 따라 행위를 달리하는 상황`에서 `자신이 직접 상태를 체크하여 상태에 따라 행위를 호출하지 않고` 상태를 `객체화`하여 `상태가 행동을 할 수 있도록 위임하는 패턴`입니다. - 객","searchableText":"state pattern design pattern design pattern ## 디자인 패턴이란?  - 반복적으로 나타난 문제에 대해 그것을 해결한 경험 및 노하우를 축적하여 `재사용하기 좋은 형태로` 이름을 붙여 `해법을 제시하는 패턴`양식 입니다. - 디자인 패턴은 크게 3가지 분류가 있습니다.   - 생성 패턴 : 객체 생성과 관련된 패턴   - 구조 패턴 : 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴   - 행위 패턴 : 객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴  ## 행위 소프트웨어 디자인 패턴  - 상태 패턴(state pattern)은 객체 지향 방식으로 상태 기계를 구현하는 `행위` 소프트웨어 디자인 패턴입니다.  ## 변하는 것은 잘 변하지 않는 것과 분리해라. 즉, 변하는 녀석들을 캡슐화해라!  - 스테이트 패턴은 객체가 `특정 상태에 따라 행위를 달리하는 상황`에서 `자신이 직접 상태를 체크하여 상태에 따라 행위를 호출하지 않고` 상태를 `객체화`하여 `상태가 행동을 할 수 있도록 위임하는 패턴`입니다. - 객"},{"slug":"/design-pattern/strategy-pattern","frontmatter":{"title":"strategy pattern","date":"2021-03-21T09:03:48.000Z","category":"design pattern","tags":["design pattern"],"draft":false},"excerpt":"## 전략 패턴(strategy pattern) 또는 정책 패턴(policy pattern)에 대해 알아 보겠습니다.  ## 행위 소프트웨어 디자인 패턴  - 실행 중에 알고리즘을 선택할 수 있게 하는 `행위` 소프트웨어 디자인 패턴입니다.  ## 동일 계열의 알고리즘을 정의하고 상호교환이 가능하게 합니다.  - 객체들이 할 수 있는 행위 각각에 대해 전략 클래스를 생성하고, 유사한 행위들을 `캡슐화` 하는 인터페이스를 정의하여, 객체의 행위를 동적으로 바꾸고 싶은 경우 직접 행위를 수정하지 않고 전략을 바꿔주기만 함으로써 행위를 유연하게 확장하는 방법을 말합니다.   - 클라이언트는 다향한 전략 중에 현재 상황에 적합한 전략을 생성해 컨텍스트에게 전략 객체를 `주입`합니다.   - 프로젝트 전체에서 변경이 일어나지 않는 부분에서 변경이 일어나는 부분을 찾아서 따로 `캡슐화` 합니다. - 간단히 말해서 객체가 할 수 있는 행위들 각각을 전략으로 만들어 놓고, 동적으로 행위의 수정이","searchableText":"strategy pattern design pattern design pattern ## 전략 패턴(strategy pattern) 또는 정책 패턴(policy pattern)에 대해 알아 보겠습니다.  ## 행위 소프트웨어 디자인 패턴  - 실행 중에 알고리즘을 선택할 수 있게 하는 `행위` 소프트웨어 디자인 패턴입니다.  ## 동일 계열의 알고리즘을 정의하고 상호교환이 가능하게 합니다.  - 객체들이 할 수 있는 행위 각각에 대해 전략 클래스를 생성하고, 유사한 행위들을 `캡슐화` 하는 인터페이스를 정의하여, 객체의 행위를 동적으로 바꾸고 싶은 경우 직접 행위를 수정하지 않고 전략을 바꿔주기만 함으로써 행위를 유연하게 확장하는 방법을 말합니다.   - 클라이언트는 다향한 전략 중에 현재 상황에 적합한 전략을 생성해 컨텍스트에게 전략 객체를 `주입`합니다.   - 프로젝트 전체에서 변경이 일어나지 않는 부분에서 변경이 일어나는 부분을 찾아서 따로 `캡슐화` 합니다. - 간단히 말해서 객체가 할 수 있는 행위들 각각을 전략으로 만들어 놓고, 동적으로 행위의 수정이"},{"slug":"/design-pattern/visitor-pattern","frontmatter":{"title":"visitor pattern","date":"2021-03-13T11:03:33.000Z","category":"design pattern","tags":[],"draft":false},"excerpt":"## 알고리즘을 객체 구조에서 분리시키는 디자인 패턴  - `기존 클래스 필드 정보를 유지하면서 새로운 연산을 추가하는 방식`입니다. - 실제 로직을 가지고 있는 객체(Visitor)가 로직을 적용할 객체(Element)를 방문하면서 실행하는 패턴입니다. 즉, `로직과 구조를 분리하는 패턴`이라고 볼 수 있습니다. 로직과 구조가 분리되면 `구조를 수정하지 않고도 새로운 동작을 기존 객체 구조에 추가` 할 수 있습니다.   - 개방-폐쇄 원칙을 적용하는 방법의 하나입니다. - 비지터 패턴은 `방문자와 방문 공간을 분리`하여, 방문 공간이 방문자를 맞이할 때, 이후에 대한 `행동을 방문자에게 위임`하는 패턴입니다.   - 보통 OOP에서, 객체는 그 객체가 하는 행동을 메쏘드로 가지고 있습니다. 그리고 행동의 대상이 되는 객체가 있을 경우, 메쏘드의 파라미터로 입력받습니다. 그런데, 비지터 패턴은 행동의 대상이 되는 객체가 행동을 일으키는 객체를 입력으로 받습니다. - 런타임 중에 하","searchableText":"visitor pattern design pattern ## 알고리즘을 객체 구조에서 분리시키는 디자인 패턴  - `기존 클래스 필드 정보를 유지하면서 새로운 연산을 추가하는 방식`입니다. - 실제 로직을 가지고 있는 객체(visitor)가 로직을 적용할 객체(element)를 방문하면서 실행하는 패턴입니다. 즉, `로직과 구조를 분리하는 패턴`이라고 볼 수 있습니다. 로직과 구조가 분리되면 `구조를 수정하지 않고도 새로운 동작을 기존 객체 구조에 추가` 할 수 있습니다.   - 개방-폐쇄 원칙을 적용하는 방법의 하나입니다. - 비지터 패턴은 `방문자와 방문 공간을 분리`하여, 방문 공간이 방문자를 맞이할 때, 이후에 대한 `행동을 방문자에게 위임`하는 패턴입니다.   - 보통 oop에서, 객체는 그 객체가 하는 행동을 메쏘드로 가지고 있습니다. 그리고 행동의 대상이 되는 객체가 있을 경우, 메쏘드의 파라미터로 입력받습니다. 그런데, 비지터 패턴은 행동의 대상이 되는 객체가 행동을 일으키는 객체를 입력으로 받습니다. - 런타임 중에 하"},{"slug":"/backend/typeorm-톺아보기","frontmatter":{"title":"typeorm 톺아보기","date":"2021-03-09T09:03:06.000Z","category":"backend","tags":["node","sql","db","rdb","typeorm","orm"],"draft":false},"excerpt":"- Node와 RDB의 ORM 서비스는 sequelize, typeorm, prisma 등 많은 라이브러리들이 있습니다. - 가장 먼저 사용한 ORM 서비스는 sequelize 였지만 typeorm이 typescript 지원이나 시장의 흐름에 따라 조금 더 많이 사용된다고 생각되어 공부하게 되었습니다.    - prisma도 고려해 보았으나 아직은 시기상조인 것 같았습니다.  ## typeorm에 대해 알아보기 전에 ORM이 무엇인지 알아보겠습니다.  - ORM(Object-relational mapping)은 객체지향 프로그래밍(Object-Oriented-Programming)과 관계형 데이터베이스(Relational-Database)사이의 호환되지 않는 `데이터를 변환하는 시스템`입니다.   - 객체와 테이블 시스템(RDBMS)을 변형 및 연결해주는 작업입니다. - ORM을 이용한 개발은 객체와 데이터베이스의 변형에 유연하게 대처할 수 있습니다. - ORM을 객체 지향 프로그","searchableText":"typeorm 톺아보기 backend node sql db rdb typeorm orm - node와 rdb의 orm 서비스는 sequelize, typeorm, prisma 등 많은 라이브러리들이 있습니다. - 가장 먼저 사용한 orm 서비스는 sequelize 였지만 typeorm이 typescript 지원이나 시장의 흐름에 따라 조금 더 많이 사용된다고 생각되어 공부하게 되었습니다.    - prisma도 고려해 보았으나 아직은 시기상조인 것 같았습니다.  ## typeorm에 대해 알아보기 전에 orm이 무엇인지 알아보겠습니다.  - orm(object-relational mapping)은 객체지향 프로그래밍(object-oriented-programming)과 관계형 데이터베이스(relational-database)사이의 호환되지 않는 `데이터를 변환하는 시스템`입니다.   - 객체와 테이블 시스템(rdbms)을 변형 및 연결해주는 작업입니다. - orm을 이용한 개발은 객체와 데이터베이스의 변형에 유연하게 대처할 수 있습니다. - orm을 객체 지향 프로그"},{"slug":"/design-pattern/builder-pattern","frontmatter":{"title":"builder pattern","date":"2021-03-07T12:03:46.000Z","category":"design pattern","tags":["design pattern"],"draft":false},"excerpt":"## 빌더는 객체 패턴입니다.  - 객체 패턴(Object patterns)에서는 객체 사이의 관계를 다루며, 객체 상이의 관계는 보통 구성을 통해서 정의 됩니다. 객체 패턴에서는 일반적으로 실행 중에 관계가 생성되기 때문에 더 동적이고 유연 합니다.  ## 빌더 패턴은 생성 패턴(Creational Pattern) 중 하나이다.  - 빌더 패턴은 싱글톤 패턴, 팩토리 패턴, 추상 팩토리 패턴과 마찬가지로 생성 패턴에 속합니다. - 생성 패턴은 `인스턴스를 만드는 절차를 추상화`하는 패턴입니다. - 생성 패턴에 속하는 패턴들은 `객체를 생성, 합성하는 방법이나 객체의 표현 방법`을 `시스템과 분리`해줍니다. - 생성 패턴은 시스템이 상속(inheritance) 보다 `복합(composite)` 방법을 사용하는 방향으로 진화되어 가면서 더 중요해지고 있습니다. - 구체 클래스에서 인스턴스를 생성하도록 하고 있습니다. 객체 생성의 과정을 추상화함으로써 인스턴스화할 때 인터페이스와 구현","searchableText":"builder pattern design pattern design pattern ## 빌더는 객체 패턴입니다.  - 객체 패턴(object patterns)에서는 객체 사이의 관계를 다루며, 객체 상이의 관계는 보통 구성을 통해서 정의 됩니다. 객체 패턴에서는 일반적으로 실행 중에 관계가 생성되기 때문에 더 동적이고 유연 합니다.  ## 빌더 패턴은 생성 패턴(creational pattern) 중 하나이다.  - 빌더 패턴은 싱글톤 패턴, 팩토리 패턴, 추상 팩토리 패턴과 마찬가지로 생성 패턴에 속합니다. - 생성 패턴은 `인스턴스를 만드는 절차를 추상화`하는 패턴입니다. - 생성 패턴에 속하는 패턴들은 `객체를 생성, 합성하는 방법이나 객체의 표현 방법`을 `시스템과 분리`해줍니다. - 생성 패턴은 시스템이 상속(inheritance) 보다 `복합(composite)` 방법을 사용하는 방향으로 진화되어 가면서 더 중요해지고 있습니다. - 구체 클래스에서 인스턴스를 생성하도록 하고 있습니다. 객체 생성의 과정을 추상화함으로써 인스턴스화할 때 인터페이스와 구현"},{"slug":"/design-pattern/adapter-pattern","frontmatter":{"title":"adapter pattern","date":"2021-02-28T17:02:34.000Z","category":"design pattern","tags":["design pattern"],"draft":false},"excerpt":"## 적응자 패턴  ## adapter란?  - adapter는 다른 전기나 기계 장치를 서로 연결해서 작동할 수 있도록 만들어 주는 결합 도구를 뜻합니다.  ## 디자인 패턴 분류  - 디자인 패턴에는 생성, 구조, 행위, 3가지 분류가 있습니다. - 어댑터 패턴은 `구조`에 대한 패턴입니다.  ### 구조 패턴  - 구조 패턴이란 작은 클래스들을 `상속`과 `합성`을 이용하여 더 큰 클래스를 생성하는 방법을 제공하는 패턴입니다. - 서로 독립적으로 개발한 클래스 라이브러리를 마치 `하나인 것`처럼 사용할 수 있습니다. 또, 여러 인터페이스를 합성(Composite)하여 서로 다른 인터페이스들의 통일된 추상을 제공합니다. - 구조 패턴의 중요한 포인트는 인터페이스나 구현을 복합하는 것이 아니라 객체를 `합성`하는 방법을 제공한다는 것입니다. 이는 컴파일 단계에서가 아닌 `런타임 단계`에서 복합 방법이나 대상을 변경할 수 있다는 점에서 유연성을 갖습니다.  ## `호환성`을 위한","searchableText":"adapter pattern design pattern design pattern ## 적응자 패턴  ## adapter란?  - adapter는 다른 전기나 기계 장치를 서로 연결해서 작동할 수 있도록 만들어 주는 결합 도구를 뜻합니다.  ## 디자인 패턴 분류  - 디자인 패턴에는 생성, 구조, 행위, 3가지 분류가 있습니다. - 어댑터 패턴은 `구조`에 대한 패턴입니다.  ### 구조 패턴  - 구조 패턴이란 작은 클래스들을 `상속`과 `합성`을 이용하여 더 큰 클래스를 생성하는 방법을 제공하는 패턴입니다. - 서로 독립적으로 개발한 클래스 라이브러리를 마치 `하나인 것`처럼 사용할 수 있습니다. 또, 여러 인터페이스를 합성(composite)하여 서로 다른 인터페이스들의 통일된 추상을 제공합니다. - 구조 패턴의 중요한 포인트는 인터페이스나 구현을 복합하는 것이 아니라 객체를 `합성`하는 방법을 제공한다는 것입니다. 이는 컴파일 단계에서가 아닌 `런타임 단계`에서 복합 방법이나 대상을 변경할 수 있다는 점에서 유연성을 갖습니다.  ## `호환성`을 위한"},{"slug":"/design-pattern/memento","frontmatter":{"title":"memento","date":"2021-02-21T21:02:16.000Z","category":"design pattern","tags":["design pattern"],"draft":false},"excerpt":"## 캡슐화를 위배하지 않은 채 내부 상태의 스냅샷을 찍는 패턴  - `캡슐화를 위배하지 않는 채` 어떤 객체의 내부 상태를 잡아내고 신체화시켜, 이후에 해당 객체가 그 상태로 다시 되돌아올 수 있도록 하는 패턴입니다.   - 메멘토 패턴은 객체의 상태 정보를 저장하고 사용자의 필요에 의하여 원하는 시점의 데이터를 복원(Rollback) 할 수 있는 패턴을 의미합니다.   - 객체를 이전의 상태로 복구시켜야 하는 경우에는 메멘토 패턴을 쓰면 됩니다. 예를 들어 사용자가 '직업 취소'를 요청하는 경우를 생각하면 됩니다. - 커맨드 패턴의 undo 기능을 메멘토 패턴으로 구현하는 경우도 있습니다.  ## 행위 패턴  - 디자인 패턴에는 생성, 구조, 행위, 3가지 분류가 있습니다. - 메멘토\u001d 패턴은 `행위`에 대한 패턴입니다.  ## 객체 패턴(Object patterns)  - 객체 패턴(Object patterns)에서는 객체 사이의 관계를 다루며, 객체 상이의 관계는 보통 구성","searchableText":"memento design pattern design pattern ## 캡슐화를 위배하지 않은 채 내부 상태의 스냅샷을 찍는 패턴  - `캡슐화를 위배하지 않는 채` 어떤 객체의 내부 상태를 잡아내고 신체화시켜, 이후에 해당 객체가 그 상태로 다시 되돌아올 수 있도록 하는 패턴입니다.   - 메멘토 패턴은 객체의 상태 정보를 저장하고 사용자의 필요에 의하여 원하는 시점의 데이터를 복원(rollback) 할 수 있는 패턴을 의미합니다.   - 객체를 이전의 상태로 복구시켜야 하는 경우에는 메멘토 패턴을 쓰면 됩니다. 예를 들어 사용자가 '직업 취소'를 요청하는 경우를 생각하면 됩니다. - 커맨드 패턴의 undo 기능을 메멘토 패턴으로 구현하는 경우도 있습니다.  ## 행위 패턴  - 디자인 패턴에는 생성, 구조, 행위, 3가지 분류가 있습니다. - 메멘토\u001d 패턴은 `행위`에 대한 패턴입니다.  ## 객체 패턴(object patterns)  - 객체 패턴(object patterns)에서는 객체 사이의 관계를 다루며, 객체 상이의 관계는 보통 구성"},{"slug":"/design-pattern/observer-pattern","frontmatter":{"title":"observer pattern","date":"2021-02-08T00:03:10.000Z","category":"design pattern","tags":["design pattern"],"draft":false,"marp":true},"excerpt":"## 상태 변화를 감시자에게 통지합니다.  - 옵저버 객체들은 주체 주제 객체에 등록되어 있으며 주체의 데이터가 바뀌면 갱신 내용을 전달 받습니다. - 옵저버 패턴은 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다(one-to-many) 의존성을 정의합니다.  ---  ## 다른 다른 명칭들은 무엇이 있을까요?  - 관찰자 패턴 - 종속자 패턴(dependent pattern) - 게시-구독 패턴(publish-subscribe pattern) - Pub/Sub(발행/구독) 모델  ---  ## 디자인패턴 분류는 행위(Behavioral) 패턴입니다.  - 디자인 패턴 분류인 생성, 구조, 행위 중 프로그램의 실행 행위를 변경할 수 있기 때문에 `행동 패턴`으로 간주됩니다. - 객체나 클래스 사이의 알고리즘이나 `책임 분배`에 관련된 패턴입니다. - 한 객체가 혼자 수행할 수 없는 작업을 여러 개의 객체로 어떻게 `","searchableText":"observer pattern design pattern design pattern ## 상태 변화를 감시자에게 통지합니다.  - 옵저버 객체들은 주체 주제 객체에 등록되어 있으며 주체의 데이터가 바뀌면 갱신 내용을 전달 받습니다. - 옵저버 패턴은 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다(one-to-many) 의존성을 정의합니다.  ---  ## 다른 다른 명칭들은 무엇이 있을까요?  - 관찰자 패턴 - 종속자 패턴(dependent pattern) - 게시-구독 패턴(publish-subscribe pattern) - pub/sub(발행/구독) 모델  ---  ## 디자인패턴 분류는 행위(behavioral) 패턴입니다.  - 디자인 패턴 분류인 생성, 구조, 행위 중 프로그램의 실행 행위를 변경할 수 있기 때문에 `행동 패턴`으로 간주됩니다. - 객체나 클래스 사이의 알고리즘이나 `책임 분배`에 관련된 패턴입니다. - 한 객체가 혼자 수행할 수 없는 작업을 여러 개의 객체로 어떻게 `"},{"slug":"/design-pattern/factory-pattern","frontmatter":{"title":"factory pattern","date":"2021-01-30T23:01:25.000Z","category":"design pattern","tags":["design pattern"],"draft":false,"marp":true},"excerpt":"## 바뀔 수 있는 부분을 찾아내서 바뀌지 않는 부분하고 분리시켜야 한다  ---  ## 팩토리 패턴은 생성과 관련된 디자인 패턴입니다.  - 생성 패턴을 이용하면 `무엇이 생성`되고, `누가 이것을 생성`하며, 이것이 `어떻게 생성`되는지, `언제 생성`할 것인지 결정하는데 `유연성`을 확보할 수 있게 됩니다.   - 생성 패턴은 인스턴스를 만드는 절차를 `추상화`하는 패턴입니다.   - 생성 패턴은 시스템이 어떤 Concrete Class를 사용하는지에 대한 정보를 `캡슐화`합니다. - 생성 패턴은 시스템이 상속(inheritance) 보다 `복합(composite)` 방법을 사용하는 방향으로 진화되어 가면서 더 중요해지고 있습니다.  ---  ## 팩토리 패턴이 생성 카테고리의 다른 패턴과 다른 점  - `명시적으로 생성자를 사용할 필요가 없다`는 것입니다. 대신 팩토리는 객체를 생성하기 위한 일반 인터페이스를 제공 할 수 있으며, 여기서 생성하려는 팩토리 객체의 유형을 지정","searchableText":"factory pattern design pattern design pattern ## 바뀔 수 있는 부분을 찾아내서 바뀌지 않는 부분하고 분리시켜야 한다  ---  ## 팩토리 패턴은 생성과 관련된 디자인 패턴입니다.  - 생성 패턴을 이용하면 `무엇이 생성`되고, `누가 이것을 생성`하며, 이것이 `어떻게 생성`되는지, `언제 생성`할 것인지 결정하는데 `유연성`을 확보할 수 있게 됩니다.   - 생성 패턴은 인스턴스를 만드는 절차를 `추상화`하는 패턴입니다.   - 생성 패턴은 시스템이 어떤 concrete class를 사용하는지에 대한 정보를 `캡슐화`합니다. - 생성 패턴은 시스템이 상속(inheritance) 보다 `복합(composite)` 방법을 사용하는 방향으로 진화되어 가면서 더 중요해지고 있습니다.  ---  ## 팩토리 패턴이 생성 카테고리의 다른 패턴과 다른 점  - `명시적으로 생성자를 사용할 필요가 없다`는 것입니다. 대신 팩토리는 객체를 생성하기 위한 일반 인터페이스를 제공 할 수 있으며, 여기서 생성하려는 팩토리 객체의 유형을 지정"},{"slug":"/design-pattern/command-pattern","frontmatter":{"title":"command pattern","date":"2021-01-26T01:01:10.000Z","category":"design pattern","tags":["design pattern"],"draft":false,"marp":true},"excerpt":"## 객체의 행위를 클래스로 만들어 캡슐화 하는 패턴  ---  ## 커맨드 패턴은 행위에 대한 패턴입니다.  - 클래스와 객체들이 상호작용하는 방법 및 역할을 분담하는 방법과 관련된 패턴입니다. - 한 객체가 혼자 수행할 수 없는 작업을 여러 개의 객체로 어떻게 `분배`하는지, 또 그렇게 하면서도 객체 사이의 `결합도를 최소화`하는 것에 중점을 둡니다. - 템플릿 메소드, 인터프리터, 역할 변경, 비지터, `커맨드`, 스트래티지, 미디에이터, 이터레이터, 메멘토, 옵저버, 스테이트 등이 있습니다.  ---  ## 커맨드 패턴을 부르는 다양한 명칭  - 커맨드 패턴 - 명령 패턴 - 작동(Action) 패턴 - 트랜잭션(Transaction) 패턴  ---  ## 커맨드 패턴이란?  - 커맨드 패턴(Command pattern)이란 `요청을 객체의 형태로 캡슐화`하여 사용자가 보낸 요청을 나중에 이용할 수 있도록 매서드 이름, `매개변수` 등 요청에 필요한 정보를 저장 또는 로깅,","searchableText":"command pattern design pattern design pattern ## 객체의 행위를 클래스로 만들어 캡슐화 하는 패턴  ---  ## 커맨드 패턴은 행위에 대한 패턴입니다.  - 클래스와 객체들이 상호작용하는 방법 및 역할을 분담하는 방법과 관련된 패턴입니다. - 한 객체가 혼자 수행할 수 없는 작업을 여러 개의 객체로 어떻게 `분배`하는지, 또 그렇게 하면서도 객체 사이의 `결합도를 최소화`하는 것에 중점을 둡니다. - 템플릿 메소드, 인터프리터, 역할 변경, 비지터, `커맨드`, 스트래티지, 미디에이터, 이터레이터, 메멘토, 옵저버, 스테이트 등이 있습니다.  ---  ## 커맨드 패턴을 부르는 다양한 명칭  - 커맨드 패턴 - 명령 패턴 - 작동(action) 패턴 - 트랜잭션(transaction) 패턴  ---  ## 커맨드 패턴이란?  - 커맨드 패턴(command pattern)이란 `요청을 객체의 형태로 캡슐화`하여 사용자가 보낸 요청을 나중에 이용할 수 있도록 매서드 이름, `매개변수` 등 요청에 필요한 정보를 저장 또는 로깅,"},{"slug":"/design-pattern/mediator-pattern","frontmatter":{"title":"mediator-pattern","date":"2021-01-25T17:01:37.000Z","category":"design pattern","tags":["design pattern"],"draft":false,"marp":true},"excerpt":"## 중재자 패턴  ---  ## 중재자 패턴은 `행위 패턴`으로 분류 됩니다.  - 디자인 패턴 분류인 생성, 구조, 행위 중 프로그램의 실행 행위를 변경할 수 있기 때문에 `행위 패턴`으로 간주됩니다. - 중재자 디자인 패턴은 유연하고 재사용 가능한 객체 지향 소프트웨어를 설계하기 위해 반복되는 디자인 문제를 해결하는 방법 23가지 `GoF 디자인 패턴들 중 하나`입니다.   - GoF 디자인 패턴 : 객체는 구현, 변경, 테스트, 재사용이 쉬워야 합니다.  ---  ## 키워드  - 캡슐화 - 느슨한 결합 - 독립적인 상호작용  ---  ## 중재자 패턴 혹은 조정자 패턴 이란 무엇일까요?  - 모든 클래스간의 복잡한 로직(상호작용)을 `캡슐화`하여 하나의 클래스에 위임하여 처리하는 패턴입니다. - 중재자 패턴을 사용하면 `객체 간 통신은 중재자 객체 안에 함축`됩니다. - 객체들간의 상호작용을 캡슐화하여 다른 독립된 객체가 `느슨하게 결합`되어 쉽게 관리 할 수 있게 하는","searchableText":"mediator-pattern design pattern design pattern ## 중재자 패턴  ---  ## 중재자 패턴은 `행위 패턴`으로 분류 됩니다.  - 디자인 패턴 분류인 생성, 구조, 행위 중 프로그램의 실행 행위를 변경할 수 있기 때문에 `행위 패턴`으로 간주됩니다. - 중재자 디자인 패턴은 유연하고 재사용 가능한 객체 지향 소프트웨어를 설계하기 위해 반복되는 디자인 문제를 해결하는 방법 23가지 `gof 디자인 패턴들 중 하나`입니다.   - gof 디자인 패턴 : 객체는 구현, 변경, 테스트, 재사용이 쉬워야 합니다.  ---  ## 키워드  - 캡슐화 - 느슨한 결합 - 독립적인 상호작용  ---  ## 중재자 패턴 혹은 조정자 패턴 이란 무엇일까요?  - 모든 클래스간의 복잡한 로직(상호작용)을 `캡슐화`하여 하나의 클래스에 위임하여 처리하는 패턴입니다. - 중재자 패턴을 사용하면 `객체 간 통신은 중재자 객체 안에 함축`됩니다. - 객체들간의 상호작용을 캡슐화하여 다른 독립된 객체가 `느슨하게 결합`되어 쉽게 관리 할 수 있게 하는"},{"slug":"/design-pattern/facade-pattern","frontmatter":{"title":"facade-pattern","date":"2021-01-23T21:02:34.000Z","category":"design pattern","tags":["design pattern"],"draft":false,"marp":true},"excerpt":"# 복잡한 과장을 간단하게 표현하는 퍼사드 패턴  <!-- 제목은 복잡한 과정을 간단하게 표현하는 퍼사드 패턴입니다. -->  ---  ## 디자인 패턴  <!-- 우선 디자인 패턴이란 무엇인지 생각해 보겠습니다. -->  - `만약 이 클래스가 바뀐다면 얼마나 많은 코드를 고쳐야 하는가?`와 같은 확장성(Extensibility) 문제는 많은 디자인 패턴들이 해결하고자 하는 문제 중 하나입니다.   <!-- 이러한 관점에서 퍼사드 패턴에 대해 알아 보겠습니다. --> - 디자인 패턴에는 생성, 구조, 행위, 3가지 분류가 있습니다. - 구조패턴은 적응자, 브리지, 복합체, 장식자, 퍼사드, 플라이급, 프록시로 분류가 됩니다.   - 이중 가장 많이 사용하는 패턴은 적응자, 장식자, 퍼사드, 프로시입니다.   - 문서 프로그램의 경우 플라이웨이트을 사용합니다.   - 게임의 경우에는 프록시와 복합체, 장식자 등이 사용됩니다.  ---  ## 퍼사드 패턴은 구조에 대한 패턴입니다.","searchableText":"facade-pattern design pattern design pattern # 복잡한 과장을 간단하게 표현하는 퍼사드 패턴  <!-- 제목은 복잡한 과정을 간단하게 표현하는 퍼사드 패턴입니다. -->  ---  ## 디자인 패턴  <!-- 우선 디자인 패턴이란 무엇인지 생각해 보겠습니다. -->  - `만약 이 클래스가 바뀐다면 얼마나 많은 코드를 고쳐야 하는가?`와 같은 확장성(extensibility) 문제는 많은 디자인 패턴들이 해결하고자 하는 문제 중 하나입니다.   <!-- 이러한 관점에서 퍼사드 패턴에 대해 알아 보겠습니다. --> - 디자인 패턴에는 생성, 구조, 행위, 3가지 분류가 있습니다. - 구조패턴은 적응자, 브리지, 복합체, 장식자, 퍼사드, 플라이급, 프록시로 분류가 됩니다.   - 이중 가장 많이 사용하는 패턴은 적응자, 장식자, 퍼사드, 프로시입니다.   - 문서 프로그램의 경우 플라이웨이트을 사용합니다.   - 게임의 경우에는 프록시와 복합체, 장식자 등이 사용됩니다.  ---  ## 퍼사드 패턴은 구조에 대한 패턴입니다."},{"slug":"/c/c-base","frontmatter":{"title":"c base","date":"2020-11-28T01:11:26.000Z","category":"c","tags":[],"draft":false},"excerpt":"## 프로그래밍 언어란?  - 기계어   - 0과 1로 이루어진 언어입니다.   - 기계가 이해할 수 있습니다. - 프로그래밍 언어   - 비교적 사람이 이해할 수 있는 언어입니다.   - 기계가 이해할 수 없습니다. - 컴파일러   - 프로그래밍 언어를 기계어로 바꾸어 기계가 이해할 수 있도록 합니다. 이러한 작업을 `컴파일`이라고 합니다.  ### Low-level  - 기계어, 어셈블리 언어입니다. - 기계는 이해할 수 있지만 사람은 이해하기 어려운 언어입니다.  ### High-level  - C, Python, Java 같은 언어입니다. - 기계는 이해할 수 없지만 사람이 이해하기 쉬운 언어입니다.  ## C 언어의 역사  - 1971년 UNIX라는 운영체제의 개발을 위해 만들어졌습니다.   - 기존의 언어는 Assembly 언어로 만들어져 있었습니다.   - 기존 언어는 하드웨어에 대한 의존도가 높았습니다.   - Dennis Ritchie, Ken Thompson","searchableText":"c base c ## 프로그래밍 언어란?  - 기계어   - 0과 1로 이루어진 언어입니다.   - 기계가 이해할 수 있습니다. - 프로그래밍 언어   - 비교적 사람이 이해할 수 있는 언어입니다.   - 기계가 이해할 수 없습니다. - 컴파일러   - 프로그래밍 언어를 기계어로 바꾸어 기계가 이해할 수 있도록 합니다. 이러한 작업을 `컴파일`이라고 합니다.  ### low-level  - 기계어, 어셈블리 언어입니다. - 기계는 이해할 수 있지만 사람은 이해하기 어려운 언어입니다.  ### high-level  - c, python, java 같은 언어입니다. - 기계는 이해할 수 없지만 사람이 이해하기 쉬운 언어입니다.  ## c 언어의 역사  - 1971년 unix라는 운영체제의 개발을 위해 만들어졌습니다.   - 기존의 언어는 assembly 언어로 만들어져 있었습니다.   - 기존 언어는 하드웨어에 대한 의존도가 높았습니다.   - dennis ritchie, ken thompson"},{"slug":"/javascript/lambda","frontmatter":{"title":"lambda","date":"2020-11-24T13:11:04.000Z","category":"javascript","tags":[],"draft":false},"excerpt":"## TL;DR  - 아래 내용은 javascript 중심의 `개인적 견해`입니다. - 람다는 익명함수를 정의 하는 편리한 방법입니다. 하지만 자바스크립트에서는 별도의 방법 없이도 익명함수를 선언할 수 있기 때문에 람다라는 표현을 쓰이는 경우가 어색한거 같습니다.  ## -  - 람다식은 수학자 알론조(Alonzo Church)가 발표한 람다 계산법에서 사용된 식으로, 이를 제자 존 매카시(John Macarthy)가 프로그래밍 언어에 도입했습니다. - 필자는 람다를 자바에서 처음 알게 되었지만 자바는 나중에 수용한 것입니다. 자바는 나중(자바 8)에야 이 표현을 받아들이게 되었습니다. - 현재 사용되고 있는 람다의 근간은 수학과 기초 컴퓨터과학 분야에서의 `람다 대수`입니다. - 람다함수를 알아보기 전에 람다 대수에 대해 먼저 알아보겠습니다.  ## 람다대수 란?  - 람다 대수는 수학에서 사용하는 함수를 보다 단순하게 표현하는 방법입니다.  ### 1. 람다 대수는 이름을 가질","searchableText":"lambda javascript ## tl;dr  - 아래 내용은 javascript 중심의 `개인적 견해`입니다. - 람다는 익명함수를 정의 하는 편리한 방법입니다. 하지만 자바스크립트에서는 별도의 방법 없이도 익명함수를 선언할 수 있기 때문에 람다라는 표현을 쓰이는 경우가 어색한거 같습니다.  ## -  - 람다식은 수학자 알론조(alonzo church)가 발표한 람다 계산법에서 사용된 식으로, 이를 제자 존 매카시(john macarthy)가 프로그래밍 언어에 도입했습니다. - 필자는 람다를 자바에서 처음 알게 되었지만 자바는 나중에 수용한 것입니다. 자바는 나중(자바 8)에야 이 표현을 받아들이게 되었습니다. - 현재 사용되고 있는 람다의 근간은 수학과 기초 컴퓨터과학 분야에서의 `람다 대수`입니다. - 람다함수를 알아보기 전에 람다 대수에 대해 먼저 알아보겠습니다.  ## 람다대수 란?  - 람다 대수는 수학에서 사용하는 함수를 보다 단순하게 표현하는 방법입니다.  ### 1. 람다 대수는 이름을 가질"},{"slug":"/frontend/method-binding","frontmatter":{"title":"method binding","date":"2020-11-17T17:12:31.000Z","category":"frontend","tags":[],"draft":false},"excerpt":"## Method binding 방법  ### case 0  ```jsx import react from 'React';  class Component extends React.Component {   method1() {     console.log('method1');   }    render() {     return <button onClick={this.method1}>button</button>;   } } ```  - this가 제대로 bind 되지 않아서 method1 안에서 this를 사용할 수 없습니다. - map 같은 함수를 써서 parameter를 넘길 경우 사용하기에 모호해집니다.  ### case 1  ```jsx import react from 'React';  class Component extends React.Component {   method1() {     console.log('method1');   }    render() {     ret","searchableText":"method binding frontend ## method binding 방법  ### case 0  ```jsx import react from 'react';  class component extends react.component {   method1() {     console.log('method1');   }    render() {     return <button onclick={this.method1}>button</button>;   } } ```  - this가 제대로 bind 되지 않아서 method1 안에서 this를 사용할 수 없습니다. - map 같은 함수를 써서 parameter를 넘길 경우 사용하기에 모호해집니다.  ### case 1  ```jsx import react from 'react';  class component extends react.component {   method1() {     console.log('method1');   }    render() {     ret"},{"slug":"/git/git-branching","frontmatter":{"title":"git branching","date":"2020-11-10T08:11:52.000Z","category":"git","tags":[],"draft":false},"excerpt":"## 대표적인 브랜칭(branching) 전략  - Git-flow - GitHub-flow  ## Git-flow  - Git-flow는 브랜치를 크게 4가지로 나누어 개발하는 전략입니다.   - 메인 브랜치(Main branch)   - 피처 브랜치(Feature branch) 또는 토픽 브랜치(Topic branch)   - 릴리스 브랜치(Release branch)   - 핫픽스 브랜치(Hotfix branch) - 가장 중심이 되는 브랜치는 master와 develop 브랜치이며, merge된 feature, release, hotfix 브랜치는 삭제하도록합니다. - Git-flow 전략은 주기적으로 배포를 해야하는 프로젝트에는 적합하지만, 브랜치가 많아 복잡하고 어떤 프로젝트에 따라서는 몇몇 브랜치가 애매한 포지션을 가질 수 있습니다.  ### 메인 브랜치(Main branch)  - master 브랜치와 develop 브랜치, 이 두 종류의 브랜치를 보통 메인 브랜치로","searchableText":"git branching git ## 대표적인 브랜칭(branching) 전략  - git-flow - github-flow  ## git-flow  - git-flow는 브랜치를 크게 4가지로 나누어 개발하는 전략입니다.   - 메인 브랜치(main branch)   - 피처 브랜치(feature branch) 또는 토픽 브랜치(topic branch)   - 릴리스 브랜치(release branch)   - 핫픽스 브랜치(hotfix branch) - 가장 중심이 되는 브랜치는 master와 develop 브랜치이며, merge된 feature, release, hotfix 브랜치는 삭제하도록합니다. - git-flow 전략은 주기적으로 배포를 해야하는 프로젝트에는 적합하지만, 브랜치가 많아 복잡하고 어떤 프로젝트에 따라서는 몇몇 브랜치가 애매한 포지션을 가질 수 있습니다.  ### 메인 브랜치(main branch)  - master 브랜치와 develop 브랜치, 이 두 종류의 브랜치를 보통 메인 브랜치로"},{"slug":"/design/svg","frontmatter":{"title":"svg","date":"2020-10-19T13:10:27.000Z","category":"design","tags":[],"draft":false,"marp":true},"excerpt":"# 이미지 압축방식 이해하기  ---  # Lossy vs Lossless  - 압축 방법에는 크게 손실압축(Lossy compression)과 비손실 압축(Lossless compression) 방법이 있습니다. - 각각에 방법에는 용도에 따라, 속도 측면에 따라 장단점이 존재합니다.  ---  # Lossy  - Lossy는 이미지를 압축하여 크기를 줄이지만 이미지의 Quaility는 손상되는 것을 말합니다. - 만약 이미지를 손실 압축 포맷으로 변환하여 계속해서 저장하게 되면 이미지의 퀄리티는 점점 나빠지게 됩니다. - 예를 들어 동영상의 경우 사람이 듣지못하는 부분의 소리 등을 버리고, 용량을 줄이기위해 화질을 포기하는 경우가 있습니다.  ---  # 손실 압축 코덱  - MPEG-1 Part.2: H.261 - MPEG-2 Part.2: H.262 - MPEG-4 Part.2: H.263 - MPEG-4 Part.10: H.264 (AVC) - MPEG-H Part.2:","searchableText":"svg design # 이미지 압축방식 이해하기  ---  # lossy vs lossless  - 압축 방법에는 크게 손실압축(lossy compression)과 비손실 압축(lossless compression) 방법이 있습니다. - 각각에 방법에는 용도에 따라, 속도 측면에 따라 장단점이 존재합니다.  ---  # lossy  - lossy는 이미지를 압축하여 크기를 줄이지만 이미지의 quaility는 손상되는 것을 말합니다. - 만약 이미지를 손실 압축 포맷으로 변환하여 계속해서 저장하게 되면 이미지의 퀄리티는 점점 나빠지게 됩니다. - 예를 들어 동영상의 경우 사람이 듣지못하는 부분의 소리 등을 버리고, 용량을 줄이기위해 화질을 포기하는 경우가 있습니다.  ---  # 손실 압축 코덱  - mpeg-1 part.2: h.261 - mpeg-2 part.2: h.262 - mpeg-4 part.2: h.263 - mpeg-4 part.10: h.264 (avc) - mpeg-h part.2:"},{"slug":"/develop/zsh","frontmatter":{"title":"zsh","date":"2020-09-09T14:10:27.000Z","category":"develop","tags":["zsh","iterm"],"draft":false},"excerpt":"## zsh version 확인  ```bash zsh --version ```  > zsh 5.5.1 (x86_64-apple-darwin17.5.0)  ## zsh이 없다면 설치  ```bash /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" brew update brew install zsh ```  ## bash를 zsh로 변경  ```bash chsh -s `which zsh`     #위 두 개의 명령을 하나로 줄일 수도 있다. ```  > 문제가 있다면 chsh -s /bin/zsh로 시도해 보자<br> > 10.10 버전부터 무언가 바뀐 듯 하다.  ## 재로그인하거나 터미널을 종료하고 재시작한 후 기본 쉘이 zsh인 것을 확인한다.  > 일부 시스템 특히 OS X에서는 /etc/shells 파일에 설치한 쉘을 등록한 후에 재시작해야 한다.","searchableText":"zsh develop zsh iterm ## zsh version 확인  ```bash zsh --version ```  > zsh 5.5.1 (x86_64-apple-darwin17.5.0)  ## zsh이 없다면 설치  ```bash /usr/bin/ruby -e \"$(curl -fssl https://raw.githubusercontent.com/homebrew/install/master/install)\" brew update brew install zsh ```  ## bash를 zsh로 변경  ```bash chsh -s `which zsh`     #위 두 개의 명령을 하나로 줄일 수도 있다. ```  > 문제가 있다면 chsh -s /bin/zsh로 시도해 보자<br> > 10.10 버전부터 무언가 바뀐 듯 하다.  ## 재로그인하거나 터미널을 종료하고 재시작한 후 기본 쉘이 zsh인 것을 확인한다.  > 일부 시스템 특히 os x에서는 /etc/shells 파일에 설치한 쉘을 등록한 후에 재시작해야 한다."},{"slug":"/develop/lru-cache","frontmatter":{"title":"LRU Cache","date":"2020-08-27T09:09:27.000Z","category":"develop","tags":["LRU Cache"],"draft":false},"excerpt":"# Least Recently Used Cache  ## 1. Cache 기본 개념  - 캐시는 데이터나 값을 미리 복사해 놓는 임시 장소를 가리킵니다. - 캐시는 접근 시간에 비해 원래 데이터를 접근하는 시간이 오래 걸리는 경우나 값을 다시 계산하는 시간을 절약하고 싶은 경우 사용합니다. - 캐시에 데이터를 미리 복사해 놓으면 계산이나 접근 시간 없이 더 빠른 속도로 데이터에 접근할 수 있습니다.  ## 2. LRU Cache 기본 개념  - LRU는 OS의 페이지 교체 알고리즘의 하나로 최근에 가장 오랫동안 사용하지 않은 페이지를 교체하는 기법입니다. - 캐시에 공간이 부족하면 가장 최근에 사용하지 않은 항목을 제거합니다.  ## 3. LRU Cache 구현  - LRU Cache 구현은 Doubly Linked List를 통해 구현합니다. head에 가까운 데이터일수록 최근에 사용한 데이터이고, tail에 가까울수록 가장 오랫동안 사용하지 않은 데이터로 간주하여 새로운 데이터","searchableText":"lru cache develop lru cache # least recently used cache  ## 1. cache 기본 개념  - 캐시는 데이터나 값을 미리 복사해 놓는 임시 장소를 가리킵니다. - 캐시는 접근 시간에 비해 원래 데이터를 접근하는 시간이 오래 걸리는 경우나 값을 다시 계산하는 시간을 절약하고 싶은 경우 사용합니다. - 캐시에 데이터를 미리 복사해 놓으면 계산이나 접근 시간 없이 더 빠른 속도로 데이터에 접근할 수 있습니다.  ## 2. lru cache 기본 개념  - lru는 os의 페이지 교체 알고리즘의 하나로 최근에 가장 오랫동안 사용하지 않은 페이지를 교체하는 기법입니다. - 캐시에 공간이 부족하면 가장 최근에 사용하지 않은 항목을 제거합니다.  ## 3. lru cache 구현  - lru cache 구현은 doubly linked list를 통해 구현합니다. head에 가까운 데이터일수록 최근에 사용한 데이터이고, tail에 가까울수록 가장 오랫동안 사용하지 않은 데이터로 간주하여 새로운 데이터"},{"slug":"/javascript/event-loop","frontmatter":{"title":"event loop","date":"2020-08-25T22:09:18.000Z","category":"javascript","tags":["javascript","event loop"],"draft":false,"marp":true,"theme":"gaia"},"excerpt":"## 자바스크립트 이벤트 루프에 대해 알아보겠습니다.  ---  ## 자바스크립트는 싱글 스레드 프로그래밍 언어<br />(Single threaded programming language) 입니다.  - 자바스크립트는 기본적으로 싱글 스레드 프로그래밍 언어입니다. 여기서 싱글 스레드라는 것은 한 번에 하나의 작업만 할 수 있다는 뜻입니다.   - 유저가 컨트롤 할 수 있는 스레드가 하나라는 뜻에서 싱글 스레드 프로그래밍 언어라고 부릅니다. 실제로는 백드라운드(C++로 구현되어 있는)가 존재합니다. 또한 web worker나 worker thread(node v14에서 나왔습니다)도 컨트롤 할 수 있게 되었습니다.  ---  ## 우선 call stack에 대해 알아보겠습니다.  - call stack은 프로그램 상에서 우리가 어떤 순서로 작업을 수행하는지 기록하는 작업 `스케쥴링과 관련된 자료 구조`입니다. 우리가 어떤 함수를 실행하게 되면 우리는 그 함수를 스택의 맨 위에 놓는","searchableText":"event loop javascript javascript event loop ## 자바스크립트 이벤트 루프에 대해 알아보겠습니다.  ---  ## 자바스크립트는 싱글 스레드 프로그래밍 언어<br />(single threaded programming language) 입니다.  - 자바스크립트는 기본적으로 싱글 스레드 프로그래밍 언어입니다. 여기서 싱글 스레드라는 것은 한 번에 하나의 작업만 할 수 있다는 뜻입니다.   - 유저가 컨트롤 할 수 있는 스레드가 하나라는 뜻에서 싱글 스레드 프로그래밍 언어라고 부릅니다. 실제로는 백드라운드(c++로 구현되어 있는)가 존재합니다. 또한 web worker나 worker thread(node v14에서 나왔습니다)도 컨트롤 할 수 있게 되었습니다.  ---  ## 우선 call stack에 대해 알아보겠습니다.  - call stack은 프로그램 상에서 우리가 어떤 순서로 작업을 수행하는지 기록하는 작업 `스케쥴링과 관련된 자료 구조`입니다. 우리가 어떤 함수를 실행하게 되면 우리는 그 함수를 스택의 맨 위에 놓는"},{"slug":"/javascript/hoisting","frontmatter":{"title":"hoisting","date":"2020-08-21T08:09:10.000Z","category":"javascript","tags":["javascript","hoisting"],"draft":false},"excerpt":"## 호이스팅(Hoisting)의 개념  - 함수 안에 있는 선언들을 모두 끌어올려서 해당 함수 유효 범위의 최상단에 선언하는 것을 말합니다.  ### 호이스팅이란  - 자바스크립트 함수는 실행되기 전에 함수 안에 필요한 변수값들을 모두 모아서 유효 범위의 최상단에 선언합니다.   - 자바스크립트 Parser가 함수 실행 전 해당 함수를 한 번 훑습니다.   - 함수 안에 존재하는 변수 / 함수선언에 대한 정보를 기억하고 있다가 실행시킵니다.   - 유효 범위 : 함수 블록({}) 안에서 유효합니다. - 함수 내에서 아래쪽에 존재하는 내용 중 필요한 값들을 끌어올리는 것입니다.   - 실제로 코드가 끌어올려지는 건 아니며, 자바스크립트 Parser 내부적으로 끌어올려서 처리하는 것입니다.   - 실제 메모리에서는 변화가 없습니다.  ### 호이스팅의 대상  - var / let / const 변수 선언과 함수선언문에서 호이스팅이 일어납니다. - var 변수 / 함수의 선언만 위로","searchableText":"hoisting javascript javascript hoisting ## 호이스팅(hoisting)의 개념  - 함수 안에 있는 선언들을 모두 끌어올려서 해당 함수 유효 범위의 최상단에 선언하는 것을 말합니다.  ### 호이스팅이란  - 자바스크립트 함수는 실행되기 전에 함수 안에 필요한 변수값들을 모두 모아서 유효 범위의 최상단에 선언합니다.   - 자바스크립트 parser가 함수 실행 전 해당 함수를 한 번 훑습니다.   - 함수 안에 존재하는 변수 / 함수선언에 대한 정보를 기억하고 있다가 실행시킵니다.   - 유효 범위 : 함수 블록({}) 안에서 유효합니다. - 함수 내에서 아래쪽에 존재하는 내용 중 필요한 값들을 끌어올리는 것입니다.   - 실제로 코드가 끌어올려지는 건 아니며, 자바스크립트 parser 내부적으로 끌어올려서 처리하는 것입니다.   - 실제 메모리에서는 변화가 없습니다.  ### 호이스팅의 대상  - var / let / const 변수 선언과 함수선언문에서 호이스팅이 일어납니다. - var 변수 / 함수의 선언만 위로"},{"slug":"/frontend/html-content-숨기기","frontmatter":{"title":"html content 숨기기","date":"2020-08-13T09:08:52.000Z","category":"frontend","tags":["display","visibility","hidden","aria-describedby","a11y-hidden"],"draft":false},"excerpt":"## 비권장방식  - display: none; - visibility: hidden; - width: 0; hight: 0; overflow: hidden;  ## 권장방식  - hidden 클래스와 aria-describedby를 활용하여 읽게 할 수 있습니다. - a11y-hidden  ```css{   .a11y-hidden {     width: 1px;     height: 1px;     overflow : hidden;     margin: -1px     clip : rect(0,0,0,0);     position: absolute;   } } ```","searchableText":"html content 숨기기 frontend display visibility hidden aria-describedby a11y-hidden ## 비권장방식  - display: none; - visibility: hidden; - width: 0; hight: 0; overflow: hidden;  ## 권장방식  - hidden 클래스와 aria-describedby를 활용하여 읽게 할 수 있습니다. - a11y-hidden  ```css{   .a11y-hidden {     width: 1px;     height: 1px;     overflow : hidden;     margin: -1px     clip : rect(0,0,0,0);     position: absolute;   } } ```"},{"slug":"/javascript/env","frontmatter":{"title":"env","date":"2020-08-10T12:08:53.000Z","category":"javascript","tags":["env","cross-env","port","javascript"],"draft":false},"excerpt":"- 환경 변수를 사용하고 싶은 경우 스크립트에 미리 넣어서 사용합니다.  ```javascript {   \"scripts\": { \t\t\"dev\": \"npx dev -p 8000\", \t} } ```  - 변수를 이용해 실행 시 받을 수도 있습니다. - 실행 시 `PORT=8000 npm run dev`로 실행합니다.  ```javascript {   \"scripts\": { \t\t\"dev\": \"npx dev -p ${PORT}\", \t} } ```  - 환경변수를 동적으로 사용하면서 기본값을 주고 싶다면 대쉬(-)를 사용합니다.  ```javascript {   \"scripts\": { \t\t\"dev\": \"npx dev -p ${PORT-8000}\", \t} } ```  - 윈도우에서도 같은 방식으로 실행하고 싶다면 cross-env를 사용합니다.  ```bash npm i -D cross-env ```  ```javascript {   \"scripts\": { \t\t\"dev\": \"cross-env","searchableText":"env javascript env cross-env port javascript - 환경 변수를 사용하고 싶은 경우 스크립트에 미리 넣어서 사용합니다.  ```javascript {   \"scripts\": { \t\t\"dev\": \"npx dev -p 8000\", \t} } ```  - 변수를 이용해 실행 시 받을 수도 있습니다. - 실행 시 `port=8000 npm run dev`로 실행합니다.  ```javascript {   \"scripts\": { \t\t\"dev\": \"npx dev -p ${port}\", \t} } ```  - 환경변수를 동적으로 사용하면서 기본값을 주고 싶다면 대쉬(-)를 사용합니다.  ```javascript {   \"scripts\": { \t\t\"dev\": \"npx dev -p ${port-8000}\", \t} } ```  - 윈도우에서도 같은 방식으로 실행하고 싶다면 cross-env를 사용합니다.  ```bash npm i -d cross-env ```  ```javascript {   \"scripts\": { \t\t\"dev\": \"cross-env"},{"slug":"/frontend/html-base","frontmatter":{"title":"html base","date":"2020-08-03T17:08:31.000Z","category":"frontend","tags":["html"],"draft":false},"excerpt":"## HTML Living Standard  - HTML, HyperText Markup Language로 대변되는 이 언어는 단순히 Markup Language라는 이유로 많은 개발자들에게 'HTML은 프로그래밍 언어가 아니다'라는 식으로 조롱받고는 합니다. - HTML 4.01이 1999년 12월 표준이 되었고, HTML 5가 2008년 1월 22일 처음 시작되어 2014년 10월 W3C 권고안이 되었습니다. - 2020년 기준, 최신 HTML 표준안은 WHATWG(Web Hypertext Application Technology Working Group)에서 [HTML Living Standard](https://html.spec.whatwg.org/) 라는 이름으로 관리하고 있으며, WHATWG에 참여 중인 기업체는 Apple, Google, Mozilla, Microsoft 등입니다.  ## 태그란?  - HTML문서를 구성하고 있는 요소 입니다. - 태그는 이름과 속성이","searchableText":"html base frontend html ## html living standard  - html, hypertext markup language로 대변되는 이 언어는 단순히 markup language라는 이유로 많은 개발자들에게 'html은 프로그래밍 언어가 아니다'라는 식으로 조롱받고는 합니다. - html 4.01이 1999년 12월 표준이 되었고, html 5가 2008년 1월 22일 처음 시작되어 2014년 10월 w3c 권고안이 되었습니다. - 2020년 기준, 최신 html 표준안은 whatwg(web hypertext application technology working group)에서 [html living standard](https://html.spec.whatwg.org/) 라는 이름으로 관리하고 있으며, whatwg에 참여 중인 기업체는 apple, google, mozilla, microsoft 등입니다.  ## 태그란?  - html문서를 구성하고 있는 요소 입니다. - 태그는 이름과 속성이"},{"slug":"/javascript/javascript-base","frontmatter":{"title":"javascript base","date":"2020-07-29T09:07:57.000Z","category":"javascript","draft":false},"excerpt":"## 자바스크립트 특징  - 자바스크립트는 인터프리터 언어입니다.   - 최근 웹 브라우저 대부분에는 싱핼 시간에 자바스크립트를 컴파일하는 JIT 컴파일러(Just In Time Compiler)가 내장되어 있어 실행 속도가 매우 빨라졌습니다. - 동적 프로토타입 기반 객체 지향 언어입니다.   - 객체를 생성한 후에도 프로퍼티와 메서드를 동적으로 추가하거나 삭제할 수 있습니다. - 동적 타입 언어입니다.   - 변수 타입이 없습니다. 따라서 프로그램을 샐항하는 도중에 변수에 저장되는 데이터 타입이 동적으로 바뀔 수 있습니다. - 함수가 일급 객체입니다.   - 함수는 객체이며, 함수에 함수를 인수로 넘길 수 있습니다. 이 특성을 활용하면 고차 함수를 구현할 수 있어 함수형 프로그래밍이 가능해집니다. - 함수가 클로저를 정의합니다.   - 클로저로 변수를 은닉하거나 영속성을 보장하는 등 다양한 기능을 구현할 수 있습니다.  ## 탄생  - 1995년 넷스케이프 커뮤니케이션스(Net","searchableText":"javascript base javascript ## 자바스크립트 특징  - 자바스크립트는 인터프리터 언어입니다.   - 최근 웹 브라우저 대부분에는 싱핼 시간에 자바스크립트를 컴파일하는 jit 컴파일러(just in time compiler)가 내장되어 있어 실행 속도가 매우 빨라졌습니다. - 동적 프로토타입 기반 객체 지향 언어입니다.   - 객체를 생성한 후에도 프로퍼티와 메서드를 동적으로 추가하거나 삭제할 수 있습니다. - 동적 타입 언어입니다.   - 변수 타입이 없습니다. 따라서 프로그램을 샐항하는 도중에 변수에 저장되는 데이터 타입이 동적으로 바뀔 수 있습니다. - 함수가 일급 객체입니다.   - 함수는 객체이며, 함수에 함수를 인수로 넘길 수 있습니다. 이 특성을 활용하면 고차 함수를 구현할 수 있어 함수형 프로그래밍이 가능해집니다. - 함수가 클로저를 정의합니다.   - 클로저로 변수를 은닉하거나 영속성을 보장하는 등 다양한 기능을 구현할 수 있습니다.  ## 탄생  - 1995년 넷스케이프 커뮤니케이션스(net"},{"slug":"/tool/visual-studio-code","frontmatter":{"title":"Visual Studio Code","date":"2020-07-29T09:07:35.000Z","category":"tool","draft":false},"excerpt":"## 단축키  | 단축키                 | 설명                             | | ---------------------- | -------------------------------- | | ctrl + shift + 좌/우   | 선택 영역 확장/축소              | | option + 위/아래       | 블록간 이동                      | | command + shift + \\    | 마지막 블록으로 이동             | | F2                     | rename                           | | F12                    | 정의부로 이동                    | | option + shift + F12   | 사용하는 코드 탐색               | | command + 0            | 파일 탐색기 포커싱","searchableText":"visual studio code tool ## 단축키  | 단축키                 | 설명                             | | ---------------------- | -------------------------------- | | ctrl + shift + 좌/우   | 선택 영역 확장/축소              | | option + 위/아래       | 블록간 이동                      | | command + shift + \\    | 마지막 블록으로 이동             | | f2                     | rename                           | | f12                    | 정의부로 이동                    | | option + shift + f12   | 사용하는 코드 탐색               | | command + 0            | 파일 탐색기 포커싱"},{"slug":"/infra/heroku/gatsby-배포","frontmatter":{"title":"gatsby 배포","date":"2020-07-27T17:08:21.000Z","category":"heroku","draft":false},"excerpt":"- gatsby 배포 시 gatsby develop 옵션은 구동하는데 많이 시간이 필요하기 때문에 적절하지 않습니다. - gatsby serve 역시 포트 조정이 불가능하여서 마땅치 않습니다.  ## 해결책  ### 애플리케이션에서 heroku/node.js및 heroku-buildpack-static 빌드 팩을 설정합니다.  ```bash heroku buildpacks:set heroku/nodejs heroku buildpacks:add https://github.com/heroku/heroku-buildpack-static.git ```  ### heroku 플랫폼 API를 app.json 활용하려면 빌드 팩을 선택적으로 추가 할 수 있습니다.  ```json // app.json { \t\"buildpacks\": [ \t\t{ \t\t\t\"url\": \"heroku/nodejs\" \t\t}, \t\t{ \t\t\t\"url\": \"https://github.com/heroku/heroku-buildpa","searchableText":"gatsby 배포 heroku - gatsby 배포 시 gatsby develop 옵션은 구동하는데 많이 시간이 필요하기 때문에 적절하지 않습니다. - gatsby serve 역시 포트 조정이 불가능하여서 마땅치 않습니다.  ## 해결책  ### 애플리케이션에서 heroku/node.js및 heroku-buildpack-static 빌드 팩을 설정합니다.  ```bash heroku buildpacks:set heroku/nodejs heroku buildpacks:add https://github.com/heroku/heroku-buildpack-static.git ```  ### heroku 플랫폼 api를 app.json 활용하려면 빌드 팩을 선택적으로 추가 할 수 있습니다.  ```json // app.json { \t\"buildpacks\": [ \t\t{ \t\t\t\"url\": \"heroku/nodejs\" \t\t}, \t\t{ \t\t\t\"url\": \"https://github.com/heroku/heroku-buildpa"},{"slug":"/develop/prototype-based-OOP","frontmatter":{"title":"prototype based OOP","date":"2020-07-21T12:08:11.000Z","category":"develop","draft":false},"excerpt":"## 특징  - 개별 객체(instance) 수준에서 메소드와 변수를 추가 - 객체 생성은 일반적으로 복사를 통해 이루어짐 - 확장(extends)은 클래스가 아니라 위임(delegation) - 개별 객체 수준에서 객체를 수정하고 발전시키는 능력은 선험적 분류의 필요성을 줄이고 반복적인 프로그래밍 및 디자인 스타일을 장려 - 프로토타입 프로그래밍은 일반적으로 분류하지 않고 유사성을 활용하도록 선택 - 결과적으로 설계는 맥락에 의해 평가  ## 프로토 타입 기반 프로그래밍  - 프로토타입 언어에서는 `분류`를 우선하지 않습니다. 생성된 객체 위주로 유사성을 정의합니다. - 프로토타입기반 프로그래밍은 클래스리스(class-less), 프로토타입 지향(prototype-oriented) 혹은 인스턴스 기반(instance-based) 프로그래밍이라고도 합니다. - 프로토타입 기반 프로그래밍은 객체지향 프로그래밍의 한 형태의 갈래로 클래스가 없고, 클래스 기반 언어에서 상속을 사용하는","searchableText":"prototype based oop develop ## 특징  - 개별 객체(instance) 수준에서 메소드와 변수를 추가 - 객체 생성은 일반적으로 복사를 통해 이루어짐 - 확장(extends)은 클래스가 아니라 위임(delegation) - 개별 객체 수준에서 객체를 수정하고 발전시키는 능력은 선험적 분류의 필요성을 줄이고 반복적인 프로그래밍 및 디자인 스타일을 장려 - 프로토타입 프로그래밍은 일반적으로 분류하지 않고 유사성을 활용하도록 선택 - 결과적으로 설계는 맥락에 의해 평가  ## 프로토 타입 기반 프로그래밍  - 프로토타입 언어에서는 `분류`를 우선하지 않습니다. 생성된 객체 위주로 유사성을 정의합니다. - 프로토타입기반 프로그래밍은 클래스리스(class-less), 프로토타입 지향(prototype-oriented) 혹은 인스턴스 기반(instance-based) 프로그래밍이라고도 합니다. - 프로토타입 기반 프로그래밍은 객체지향 프로그래밍의 한 형태의 갈래로 클래스가 없고, 클래스 기반 언어에서 상속을 사용하는"},{"slug":"/develop/객체지향-프로그래밍(oop)","frontmatter":{"title":"객체지향 프로그래밍(OOP)","date":"2020-07-21T12:08:11.000Z","category":"develop","draft":false},"excerpt":"- 객체지향 프로그래밍은 컴퓨터 프로그래밍 패러다임(견해, 사고법)의 하나로, 프로그래밍에서 필요한 데이터를 추상화 시켜서 상태(속성, 어트리뷰트)와 행위(메서드)를 가진 객체로 만들고, 그 객체간의 상호작용을 통해 로직을 구성하는 방법입니다. - 객체지향 애플리케이션의 중심 사상은 연쇄적으로 메시지를 전송하고 수신하는 객체들 사이의 협력 관계를 기반으로 사용자에게 유용한 기능을 제공하는 것입니다. 객체지향의 강력함은 객체들이 주고받는 메시지로부터 나옵니다. 객체지향의 애플리케이션은 클래스를 이용해 만들어지지만 메시지를 통해 정의됩니다. - 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 부과되는 규율입니다.  ## 자율적인 책임  - 객체지향 공동체를 구성하는 기본 단위는 `자율적인 객체`입니다. - 자율적인 객체란 스스로 정한 원칙에 따라 판단하고 스스로의 의지를 기반으로 행동하는 객체입니다. 객체가 어떤 행동을 하는 유일한 이유는 다른 객체로부터 요청을 수신했기 때문입니다.","searchableText":"객체지향 프로그래밍(oop) develop - 객체지향 프로그래밍은 컴퓨터 프로그래밍 패러다임(견해, 사고법)의 하나로, 프로그래밍에서 필요한 데이터를 추상화 시켜서 상태(속성, 어트리뷰트)와 행위(메서드)를 가진 객체로 만들고, 그 객체간의 상호작용을 통해 로직을 구성하는 방법입니다. - 객체지향 애플리케이션의 중심 사상은 연쇄적으로 메시지를 전송하고 수신하는 객체들 사이의 협력 관계를 기반으로 사용자에게 유용한 기능을 제공하는 것입니다. 객체지향의 강력함은 객체들이 주고받는 메시지로부터 나옵니다. 객체지향의 애플리케이션은 클래스를 이용해 만들어지지만 메시지를 통해 정의됩니다. - 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 부과되는 규율입니다.  ## 자율적인 책임  - 객체지향 공동체를 구성하는 기본 단위는 `자율적인 객체`입니다. - 자율적인 객체란 스스로 정한 원칙에 따라 판단하고 스스로의 의지를 기반으로 행동하는 객체입니다. 객체가 어떤 행동을 하는 유일한 이유는 다른 객체로부터 요청을 수신했기 때문입니다."},{"slug":"/javascript/freeze","frontmatter":{"title":"freeze","date":"2020-07-19T21:07:26.000Z","category":"javascript","draft":false},"excerpt":"- javascript에서 Object.freeze를 활용해여 배열의 값을 변경 못하게 할 수 있습니다.  ## freeze  ```javascript const o1 = { name: 'kim', score: [1, 2] }; Object.freeze(o1); Object.freeze(o1.score); o1.name = 'lee'; o1.city = 'seoul'; o1.score.push(3); // Uncaught TypeError: Cannot add property 2, object is not extensible ```","searchableText":"freeze javascript - javascript에서 object.freeze를 활용해여 배열의 값을 변경 못하게 할 수 있습니다.  ## freeze  ```javascript const o1 = { name: 'kim', score: [1, 2] }; object.freeze(o1); object.freeze(o1.score); o1.name = 'lee'; o1.city = 'seoul'; o1.score.push(3); // uncaught typeerror: cannot add property 2, object is not extensible ```"},{"slug":"/Java/build-파일의-위치","frontmatter":{"title":"build 파일의 위치","date":"2020-07-15T17:07:01.000Z","category":"java","draft":false},"excerpt":"- spring backend로 된 프로젝트 진행 중 누군가는 out 파일이 생기고 누군가는 생기지 않아 문제를 겪에 되었습니다.  ## 해결책  - IntelliJ IDEA 2에서 command + , 을 통해 설정창 실행합니다. - 검색창에 gradle 검색합니다. - Build and run using을 IntelliJ IDEA로 설정합니다. - 서버 재실행 시 super2/baemin-super2-api 아래에 out 폴더 생겼는지 확인합니다.","searchableText":"build 파일의 위치 java - spring backend로 된 프로젝트 진행 중 누군가는 out 파일이 생기고 누군가는 생기지 않아 문제를 겪에 되었습니다.  ## 해결책  - intellij idea 2에서 command + , 을 통해 설정창 실행합니다. - 검색창에 gradle 검색합니다. - build and run using을 intellij idea로 설정합니다. - 서버 재실행 시 super2/baemin-super2-api 아래에 out 폴더 생겼는지 확인합니다."},{"slug":"/studyFront/day5","frontmatter":{"title":"day5","date":"2020-07-14T23:07:19.000Z","category":"studyFront","draft":false},"excerpt":"## 캔버스를 활용한 눈알 굴리기  ```html <!DOCTYPE html> <html lang=\"ko-KO\"> \t<head> \t\t<meta charset=\"UTF-8\" /> \t\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /> \t\t<title>Snow</title> \t</head>  \t<body style=\"width: 100vw;height: 100vh;\"> \t\t<canvas id=\"canvas\" width=\"1550\" height=\"1306\"></canvas> \t\t<script src=\"./index.js\"></script> \t</body> </html> ```  - Canvas API는 JavaScript와 HTML canvas 엘리먼트를 통해 그래픽을 그리기위한 수단을 제공합니다. 무엇보다도 애니메이션, 게임 그래픽, 데이터 시각화, 사진 조작 및 실시간 비디오 처리를 위해 사용됩니다. -","searchableText":"day5 studyfront ## 캔버스를 활용한 눈알 굴리기  ```html <!doctype html> <html lang=\"ko-ko\"> \t<head> \t\t<meta charset=\"utf-8\" /> \t\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /> \t\t<title>snow</title> \t</head>  \t<body style=\"width: 100vw;height: 100vh;\"> \t\t<canvas id=\"canvas\" width=\"1550\" height=\"1306\"></canvas> \t\t<script src=\"./index.js\"></script> \t</body> </html> ```  - canvas api는 javascript와 html canvas 엘리먼트를 통해 그래픽을 그리기위한 수단을 제공합니다. 무엇보다도 애니메이션, 게임 그래픽, 데이터 시각화, 사진 조작 및 실시간 비디오 처리를 위해 사용됩니다. -"},{"slug":"/studyFront/day4","frontmatter":{"title":"day4","date":"2020-07-14T05:07:36.000Z","category":"studyFront","draft":false},"excerpt":"## 자바스크립트 사용하기  - index.html에 script 태그를 연결 합니다.  ```html <!DOCTYPE html> <html lang=\"ko-KO\">   <head>     <meta charset=\"UTF-8\" />     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />     <title>javascript</title>   </head>    <body>     <script src=\"./index.js\"></script>   </body> </html> ```  - 자바스크립트에서 특정 html의 element를 사용할 때 그 element보다 자바스크립트 코드가 상위에 있을 경우 에러를 발생할 수 있습니다. 또한 스크립트가 element보다 상단에 위치할 경우 사용자에게 초기에 보여지는 속도가 느려질 수 있기 때문에 body 끝에 작성합니다. - 자바스크립트 파일을 작성합니","searchableText":"day4 studyfront ## 자바스크립트 사용하기  - index.html에 script 태그를 연결 합니다.  ```html <!doctype html> <html lang=\"ko-ko\">   <head>     <meta charset=\"utf-8\" />     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />     <title>javascript</title>   </head>    <body>     <script src=\"./index.js\"></script>   </body> </html> ```  - 자바스크립트에서 특정 html의 element를 사용할 때 그 element보다 자바스크립트 코드가 상위에 있을 경우 에러를 발생할 수 있습니다. 또한 스크립트가 element보다 상단에 위치할 경우 사용자에게 초기에 보여지는 속도가 느려질 수 있기 때문에 body 끝에 작성합니다. - 자바스크립트 파일을 작성합니"},{"slug":"/react/타이머-만들기","frontmatter":{"title":"타이머 만들기","date":"2020-07-12T13:08:32.000Z","category":"react","draft":false},"excerpt":"- 휴대폰 인증 같은 경우 3분 안에 입력해야 하는데 사용자들의 편의를 위해서 03:00에서 0:00으로 1초마다 초가 줄어드는 UI를 많이 사용합니다. - requestAnimationFrame을 이용해 이를 구현합니다.  ```tsx import moment from 'moment'; import { Component } from 'react';  interface Props {}  interface State { \ttimeDiff?: number; }  const TIME_LIMIT = 180;  class App extends Component { \tinitTime: number;  \tstartTimer() { \t\tconst updateTime = () => { \t\t\tconst currentTime = Date.now(); \t\t\tlet timeDiff = TIME_LIMIT; \t\t\tif (currentTime - this.initTime >= 1000) { \t\t\t\ttimeD","searchableText":"타이머 만들기 react - 휴대폰 인증 같은 경우 3분 안에 입력해야 하는데 사용자들의 편의를 위해서 03:00에서 0:00으로 1초마다 초가 줄어드는 ui를 많이 사용합니다. - requestanimationframe을 이용해 이를 구현합니다.  ```tsx import moment from 'moment'; import { component } from 'react';  interface props {}  interface state { \ttimediff?: number; }  const time_limit = 180;  class app extends component { \tinittime: number;  \tstarttimer() { \t\tconst updatetime = () => { \t\t\tconst currenttime = date.now(); \t\t\tlet timediff = time_limit; \t\t\tif (currenttime - this.inittime >= 1000) { \t\t\t\ttimed"},{"slug":"/studyFront/day3","frontmatter":{"title":"day3","date":"2020-07-12T13:07:30.000Z","category":"studyFront","draft":false},"excerpt":"## 이미지 가운데 정렬  - 이미지도 inline 요소이기 때문에 `text-align: center`를 통해 가운데 정렬을 합니다.  ## plugin 사용하기  - vscode 좌측 active bar에 있는 Extenstions에서 각종 plugin을 사용합니다.   - ![](./images/extenstions.png) - [Auto Rename Tag](https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-rename-tag)   - 페어링 태그의 이름을 자동으로 바꿔줍니다. - [htmltagwrap](https://marketplace.visualstudio.com/items?itemName=bradgashler.htmltagwrap)   - option + w 를 이용하여 선택한 내용을 HTML(p) 태그로 래핑 합니다. - [HTML CSS Support](https://marketplac","searchableText":"day3 studyfront ## 이미지 가운데 정렬  - 이미지도 inline 요소이기 때문에 `text-align: center`를 통해 가운데 정렬을 합니다.  ## plugin 사용하기  - vscode 좌측 active bar에 있는 extenstions에서 각종 plugin을 사용합니다.   - ![](./images/extenstions.png) - [auto rename tag](https://marketplace.visualstudio.com/items?itemname=formulahendry.auto-rename-tag)   - 페어링 태그의 이름을 자동으로 바꿔줍니다. - [htmltagwrap](https://marketplace.visualstudio.com/items?itemname=bradgashler.htmltagwrap)   - option + w 를 이용하여 선택한 내용을 html(p) 태그로 래핑 합니다. - [html css support](https://marketplac"},{"slug":"/javascript/nullish-coalescing-operator","frontmatter":{"title":"nullish coalescing operator","date":"2020-07-09T09:08:24.000Z","category":"javascript","draft":false},"excerpt":"- 자바스크립트에서는 0, '', false, undefined, null을 모두 falsy값으로 처리합니다. if나 삼항 연산자에 falsy값을 넣을 경우 false로 처리합니다. - 0, '', false와 null, undefined를 구분하고 싶다면 nullish coalescing operator를 사용합니다.  ```javascript let a = 0; let b = a || 2; console.log(b); // 2  a = ''; b = a || 2; console.log(b); // 2  a = false; b = a || 2; console.log(b); // 2  a = undefined; b = a || 2; console.log(b); // 2  a = null; b = a || 2; console.log(b); // 2 ```  ```javascript let a = 0; let b = a ?? 2; console.log(b); // 0  a = '';","searchableText":"nullish coalescing operator javascript - 자바스크립트에서는 0, '', false, undefined, null을 모두 falsy값으로 처리합니다. if나 삼항 연산자에 falsy값을 넣을 경우 false로 처리합니다. - 0, '', false와 null, undefined를 구분하고 싶다면 nullish coalescing operator를 사용합니다.  ```javascript let a = 0; let b = a || 2; console.log(b); // 2  a = ''; b = a || 2; console.log(b); // 2  a = false; b = a || 2; console.log(b); // 2  a = undefined; b = a || 2; console.log(b); // 2  a = null; b = a || 2; console.log(b); // 2 ```  ```javascript let a = 0; let b = a ?? 2; console.log(b); // 0  a = '';"},{"slug":"/studyFront/day2","frontmatter":{"title":"day2","date":"2020-07-08T17:07:31.000Z","category":"studyFront","draft":false},"excerpt":"## github 활용하기  ### github 가입  - [github](https://github.com/)에 가입합니다. - 우측 상단에 동그라미를 눌러 Your repositories - 우측 상단에 New라는 녹색 버튼을 클릭합니다. - Repository name에 자신의 계정이름 + github.io로 repository를 생성합니다. - 저는 Yuni-Q.github.io 입니다. - 이곳에 파일을 넣으면 github애서 정적 파일을 호스팅해 줍니다.  ### git 사용하기  - vscode에서 control + `을 통해 터미널을 열어줍니다.   - `(백티)은 영어 일 때만 입력이 되고 한글 일 경우 ₩이 입력이 됩니다. - git을 사용하고자 하는 폴더에서 'git init'을 합니다. 그러면 .git 폴더가 만들어집니다. - 'git remote add \\[별칭] \\[repository 주소]'을 통해 원격 저장소를 연결합니다.   - 별칭은 origin을","searchableText":"day2 studyfront ## github 활용하기  ### github 가입  - [github](https://github.com/)에 가입합니다. - 우측 상단에 동그라미를 눌러 your repositories - 우측 상단에 new라는 녹색 버튼을 클릭합니다. - repository name에 자신의 계정이름 + github.io로 repository를 생성합니다. - 저는 yuni-q.github.io 입니다. - 이곳에 파일을 넣으면 github애서 정적 파일을 호스팅해 줍니다.  ### git 사용하기  - vscode에서 control + `을 통해 터미널을 열어줍니다.   - `(백티)은 영어 일 때만 입력이 되고 한글 일 경우 ₩이 입력이 됩니다. - git을 사용하고자 하는 폴더에서 'git init'을 합니다. 그러면 .git 폴더가 만들어집니다. - 'git remote add \\[별칭] \\[repository 주소]'을 통해 원격 저장소를 연결합니다.   - 별칭은 origin을"},{"slug":"/studyFront/day1","frontmatter":{"title":"day1","date":"2020-07-08T15:08:00.000Z","category":"studyFront","draft":false},"excerpt":"## 1. vscode 설치  - Terminal.app을 실행 시킵니다. - brew를 통해 vscode를 설치하기 위해 brew를 설치 합니다.  ```bash   /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\" ```  - brew update를 진행합니다.  ```bash   brew update ```  - brew를 통해 vscode를 설치합니다.  ```bash   brew cask install visual-studio-code ```  ## 2. 터미널로 vscode 열기  - Visual Studio Code 실행합니다. - commend + shift + p를 입력합니다. - Shell command 'code' successfully installed in PATH.를 선택합니다. - 터미널에서 code 명령어를 사용합니다.  ## 3","searchableText":"day1 studyfront ## 1. vscode 설치  - terminal.app을 실행 시킵니다. - brew를 통해 vscode를 설치하기 위해 brew를 설치 합니다.  ```bash   /bin/bash -c \"$(curl -fssl https://raw.githubusercontent.com/homebrew/install/master/install.sh)\" ```  - brew update를 진행합니다.  ```bash   brew update ```  - brew를 통해 vscode를 설치합니다.  ```bash   brew cask install visual-studio-code ```  ## 2. 터미널로 vscode 열기  - visual studio code 실행합니다. - commend + shift + p를 입력합니다. - shell command 'code' successfully installed in path.를 선택합니다. - 터미널에서 code 명령어를 사용합니다.  ## 3"},{"slug":"/book/객체지향의 사실과 오해/04.-역할,-책임,-협력","frontmatter":{"title":"04. 역할, 책임, 협력","date":"2020-07-03T12:08:02.000Z","category":"객체지향의 사실과 오해","draft":false},"excerpt":"- 중요한 것은 개별 객체가 아니라 객체들 사이에 이뤄지는 협력입니다.  ## 책임  - 객체지향 개발에서 가장 중요힌 능력은 능숙하게 소프트웨어 객체에 할당하는 것입니다. ### 책임의 분류  - 객체의 책임은 객체가 무엇을 알고 있는가(knowing)와 무엇을 할 수 있는가(doing)로 구성됩니다.  #### 하는 것(doing)  - 객체를 생성하거나 계산하는 등의 스스로 하는 것 - 다른 객체의 행동을 시작시키는 것 - 다른 객체의 활동을 제어하고 조절하는 것  #### 아는 것(knowing)  - 개인적인 정보에 관해 아는 것 - 관련된 객체에 관해 아는 것 - 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것  #### 공용 인터페이스(public interface)  - 책임은 객체의 공용 인터페이스를 구성합니다.  ### 책임과 메시지  - 객체지향 설꼐는 협력에 참여하기 위해 어떤 객체가 어떤 책임을 수행해야 하고 어떤 객체로부터 메시지를 수신할 것인지를 결","searchableText":"04. 역할, 책임, 협력 객체지향의 사실과 오해 - 중요한 것은 개별 객체가 아니라 객체들 사이에 이뤄지는 협력입니다.  ## 책임  - 객체지향 개발에서 가장 중요힌 능력은 능숙하게 소프트웨어 객체에 할당하는 것입니다. ### 책임의 분류  - 객체의 책임은 객체가 무엇을 알고 있는가(knowing)와 무엇을 할 수 있는가(doing)로 구성됩니다.  #### 하는 것(doing)  - 객체를 생성하거나 계산하는 등의 스스로 하는 것 - 다른 객체의 행동을 시작시키는 것 - 다른 객체의 활동을 제어하고 조절하는 것  #### 아는 것(knowing)  - 개인적인 정보에 관해 아는 것 - 관련된 객체에 관해 아는 것 - 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것  #### 공용 인터페이스(public interface)  - 책임은 객체의 공용 인터페이스를 구성합니다.  ### 책임과 메시지  - 객체지향 설꼐는 협력에 참여하기 위해 어떤 객체가 어떤 책임을 수행해야 하고 어떤 객체로부터 메시지를 수신할 것인지를 결"},{"slug":"/book/객체지향의 사실과 오해/05.-책임과-메시지","frontmatter":{"title":"05. 책임과 메시지","date":"2020-07-03T12:07:54.000Z","category":"객체지향의 사실과 오해","draft":false},"excerpt":"- 의도는 `메시징`입니다. 훌륭하고 성장 가능한 시스템을 만들기 위한 핵심은 모듈 내부의 속성과 행동이 어떤가보다는 모듈이 어떻게 커뮤니케이션하는가에 달려 있습니다.  ## 설계의 품질을 좌우하는 책임  - 객체지향 공통체를 구성하는 기본 단위는 자율적인 객체입니다. 객체들은 애플리케이션의 기능을 구현하기 위해 협력하고, 협력 과정에서 각자 맡은 바 책임을 다하기 위해 자율적으로 판단하고 행동합니다. - 여기서 키워드는 자율성입니다. 자율성의 사전적 의미는 `자기 스스로의 원칙에 따라 어떤 일을 하거나 자신을 통제해서 절제하는 성질이나 특성`입니다. 자율성의 반대말은 타율성으로, 자신의 의지와 관계없이 정해진 규율이나 원칙에 따라서만 움직이는 성질을 의미합니다. 따라서 자율적인 객체란 스스로 정한 원칙에 따라 판단하고 스스로의 의지를 기반으로 행동하는 객체입니다. 타인이 정한 규칙이나 명령에 따라 판단하고 행동하는 객체는 자율적인 객체라고 부르기 어렵습니다. - 객체가 어떤 행동","searchableText":"05. 책임과 메시지 객체지향의 사실과 오해 - 의도는 `메시징`입니다. 훌륭하고 성장 가능한 시스템을 만들기 위한 핵심은 모듈 내부의 속성과 행동이 어떤가보다는 모듈이 어떻게 커뮤니케이션하는가에 달려 있습니다.  ## 설계의 품질을 좌우하는 책임  - 객체지향 공통체를 구성하는 기본 단위는 자율적인 객체입니다. 객체들은 애플리케이션의 기능을 구현하기 위해 협력하고, 협력 과정에서 각자 맡은 바 책임을 다하기 위해 자율적으로 판단하고 행동합니다. - 여기서 키워드는 자율성입니다. 자율성의 사전적 의미는 `자기 스스로의 원칙에 따라 어떤 일을 하거나 자신을 통제해서 절제하는 성질이나 특성`입니다. 자율성의 반대말은 타율성으로, 자신의 의지와 관계없이 정해진 규율이나 원칙에 따라서만 움직이는 성질을 의미합니다. 따라서 자율적인 객체란 스스로 정한 원칙에 따라 판단하고 스스로의 의지를 기반으로 행동하는 객체입니다. 타인이 정한 규칙이나 명령에 따라 판단하고 행동하는 객체는 자율적인 객체라고 부르기 어렵습니다. - 객체가 어떤 행동"},{"slug":"/book/객체지향의 사실과 오해/03.-타입과-추상화","frontmatter":{"title":"03. 타입과 추상화","date":"2020-07-03T11:07:49.000Z","category":"객체지향의 사실과 오해","draft":false},"excerpt":"## 추상화  - 어떤 양상, 세부 사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법입니다. 복잡성을 다루기 위해 추상화는 두 차원에서 이뤄집니다.   - 첫 번째 차원은 구체적인 사물들 간의 공통점은 취하고 차이점은 버리는 일반화를 통해 단순하게 만드는 것입니다.   - 두 번째 차원은 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함으로써 단순하게 만드는 것입니다. - 모든 경우에 `추상화의 목적`은 복잡성을 `이해하기 쉬운 수준으로 단순화하는` 것입니다.  ## 객체  - 객체란 특정한 개념을 적용 할 수 있는 구체적인 사물을 의미합니다. 개념이 객체에 적용됐을 때 객체를 개념의 인스턴스라고 합니다.  ## 개념의 세 가지 관점  - 심볼(Symbol) : 개념을 가리키는 간략한 이름이나 명칭입니다. - 내연(Intension) : 개념의 완전한 정의를 나타내며 내연의 의미를 이용해 객체가 개념에 속","searchableText":"03. 타입과 추상화 객체지향의 사실과 오해 ## 추상화  - 어떤 양상, 세부 사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법입니다. 복잡성을 다루기 위해 추상화는 두 차원에서 이뤄집니다.   - 첫 번째 차원은 구체적인 사물들 간의 공통점은 취하고 차이점은 버리는 일반화를 통해 단순하게 만드는 것입니다.   - 두 번째 차원은 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함으로써 단순하게 만드는 것입니다. - 모든 경우에 `추상화의 목적`은 복잡성을 `이해하기 쉬운 수준으로 단순화하는` 것입니다.  ## 객체  - 객체란 특정한 개념을 적용 할 수 있는 구체적인 사물을 의미합니다. 개념이 객체에 적용됐을 때 객체를 개념의 인스턴스라고 합니다.  ## 개념의 세 가지 관점  - 심볼(symbol) : 개념을 가리키는 간략한 이름이나 명칭입니다. - 내연(intension) : 개념의 완전한 정의를 나타내며 내연의 의미를 이용해 객체가 개념에 속"},{"slug":"/book/객체지향의 사실과 오해/02.-이상한-나라의-객체","frontmatter":{"title":"02. 이상한 나라의 객체","date":"2020-07-03T11:07:10.000Z","category":"객체지향의 사실과 오해","draft":false},"excerpt":"- `객체`란 식별 가능한 개체 또는 사물입니다. 객체는 자동차처럼 만질 수 있는 구체적인 사물일 수도 있고, 시간처럼 추상적인 개념일 수도 있습니다. 객체는 구별 가능한 식별자, 특징적인 행동, 변경 가능한 상태를 가집니다. 소프트웨어 안에서 객체는 저장된 상태와 실행 가능한 코드를 통해 구현됩니다.  ## 객체의 상태  - 상태는 특정 시점에 객체가 가지고 있는 정보의 집합으로 객체의 구조적 특징을 표현합니다. 객체의 상태는 객체에 존재하는 `정적인 프로퍼티`와 `동적인 프로퍼티 값`으로 구성됩니다.  - 프로퍼티는 속성과 연관관계의 두 가지 종류로 구분됩니다.   - `속성(attribute)`은 단순한 값입니다.   - 연관관계는 정적인 관계를 의미하며 링크는 연관관계의 인스턴스입니다. - 객체지향 세계에서 객체는 다른 객체의 상태에 직접적으로 접근할 수도, 상태를 변경할 수도 없습니다. 객체는 스스로의 행동에 의해서만 상태가 변경되는 것을 보장함으로써 객체의 자율성을 유지","searchableText":"02. 이상한 나라의 객체 객체지향의 사실과 오해 - `객체`란 식별 가능한 개체 또는 사물입니다. 객체는 자동차처럼 만질 수 있는 구체적인 사물일 수도 있고, 시간처럼 추상적인 개념일 수도 있습니다. 객체는 구별 가능한 식별자, 특징적인 행동, 변경 가능한 상태를 가집니다. 소프트웨어 안에서 객체는 저장된 상태와 실행 가능한 코드를 통해 구현됩니다.  ## 객체의 상태  - 상태는 특정 시점에 객체가 가지고 있는 정보의 집합으로 객체의 구조적 특징을 표현합니다. 객체의 상태는 객체에 존재하는 `정적인 프로퍼티`와 `동적인 프로퍼티 값`으로 구성됩니다.  - 프로퍼티는 속성과 연관관계의 두 가지 종류로 구분됩니다.   - `속성(attribute)`은 단순한 값입니다.   - 연관관계는 정적인 관계를 의미하며 링크는 연관관계의 인스턴스입니다. - 객체지향 세계에서 객체는 다른 객체의 상태에 직접적으로 접근할 수도, 상태를 변경할 수도 없습니다. 객체는 스스로의 행동에 의해서만 상태가 변경되는 것을 보장함으로써 객체의 자율성을 유지"},{"slug":"/book/객체지향의 사실과 오해/01.-협력하는-객체들의-공동체","frontmatter":{"title":"01. 협력하는 객체들의 공동체","date":"2020-07-03T08:08:39.000Z","category":"객체지향의 사실과 오해","draft":false},"excerpt":"- 객체를 상태와 행동을 함께 지닌 실체라고 정의합니다. 이 말은 객체가 협력에 참여하기 위해 어떤 행동을 해야 한다면 그 행동을 하는 데 필요한 상태도 함께 지니고 있어야 한다는 것을 의미합니다. 객체가 협력에 참여하는 과정 속에서 스스로 판단하고 스스로 결정하는 자율적인 존재로 남기 위해서는 필요한 행동과 상태를 함께 지니고 있어야 합니다.  ## 객체의 역할  - 여러 객체가 동일한 역할을 수행할 수 있습니다. - 역할은 대체 가능성을 의미합니다. - 각 객체는 책임을 수행하는 방법을 자율적으로 선택할 수 있습니다. - 하나의 객체가 동시에 여러 역할을 수행할 수 있습니다.  ## 객체지향의 본질  - 객체지향이란 시스템을 상호작용하는 `자율적인 객체들의 공동체`로 바라보고 객체를 이용해 시스템을 분할하는 방법입니다. - 자율적인 객체란 `상태`와 `행위`를 함께 지니며 스스로 자기 자신을 책임지는 객체를 의미입니다. - 객체는 시스템의 행위를 구현하기 위해 다른 객체와 `협","searchableText":"01. 협력하는 객체들의 공동체 객체지향의 사실과 오해 - 객체를 상태와 행동을 함께 지닌 실체라고 정의합니다. 이 말은 객체가 협력에 참여하기 위해 어떤 행동을 해야 한다면 그 행동을 하는 데 필요한 상태도 함께 지니고 있어야 한다는 것을 의미합니다. 객체가 협력에 참여하는 과정 속에서 스스로 판단하고 스스로 결정하는 자율적인 존재로 남기 위해서는 필요한 행동과 상태를 함께 지니고 있어야 합니다.  ## 객체의 역할  - 여러 객체가 동일한 역할을 수행할 수 있습니다. - 역할은 대체 가능성을 의미합니다. - 각 객체는 책임을 수행하는 방법을 자율적으로 선택할 수 있습니다. - 하나의 객체가 동시에 여러 역할을 수행할 수 있습니다.  ## 객체지향의 본질  - 객체지향이란 시스템을 상호작용하는 `자율적인 객체들의 공동체`로 바라보고 객체를 이용해 시스템을 분할하는 방법입니다. - 자율적인 객체란 `상태`와 `행위`를 함께 지니며 스스로 자기 자신을 책임지는 객체를 의미입니다. - 객체는 시스템의 행위를 구현하기 위해 다른 객체와 `협"},{"slug":"/frontend/blur-처리","frontmatter":{"title":"blur 처리","date":"2020-06-29T14:07:29.000Z","category":"frontend","draft":false},"excerpt":"- 현재 포커스 되어 있는 element의 포커스를 해제 합니다.  ```javascript document.activeElement.blur(); ```","searchableText":"blur 처리 frontend - 현재 포커스 되어 있는 element의 포커스를 해제 합니다.  ```javascript document.activeelement.blur(); ```"},{"slug":"/frontend/close-event","frontmatter":{"title":"close event","date":"2020-06-29T14:06:45.000Z","category":"frontend","draft":false},"excerpt":"```javascript window.addEventListener('beforeunload', () => document.activeElement.blur()); ```  - 창을 닫을 때 현재 활성화 되어 있는 포커스 제거합니다. - alert 사용 시 chrom에서는 정상 작동하지 않습니다.","searchableText":"close event frontend ```javascript window.addeventlistener('beforeunload', () => document.activeelement.blur()); ```  - 창을 닫을 때 현재 활성화 되어 있는 포커스 제거합니다. - alert 사용 시 chrom에서는 정상 작동하지 않습니다."},{"slug":"/frontend/ie11","frontmatter":{"title":"ie11","date":"2020-06-26T12:06:51.000Z","category":"frontend","draft":false},"excerpt":"## ie11 max-width  - ie11에서 max-width가 동작하지 않습니다. - position: absolute; left: 0;으로 해결했습니다.  ## ie11 text-align  - start와 end 값이 동작하지 않아서 left와 right를 사용합니다.  ## ie11에서 web font 로딩되지 않음  - web font를 캐싱 하지 않을 경우 새로 고침 시에 나타나지 않아 캐시 하지 않는 것에서 이미지와 폰트를 제외 하였습니다.  ## ie11 flex 축약형  ### 일반적인 축양형  ```css # 아무것도 안쓰면; flex: 0 1 auto;  # flex: 1; flex: 1 1 0%;  # flex: auto; flex: 1 1 auto;  # flex: initial; flex: 0 1 auto ```  ### ie11에서 축약형  ```css # 아무것도 안쓰면; flex: 0 0 auto;  # flex: 1; flex: 1 0 0px;","searchableText":"ie11 frontend ## ie11 max-width  - ie11에서 max-width가 동작하지 않습니다. - position: absolute; left: 0;으로 해결했습니다.  ## ie11 text-align  - start와 end 값이 동작하지 않아서 left와 right를 사용합니다.  ## ie11에서 web font 로딩되지 않음  - web font를 캐싱 하지 않을 경우 새로 고침 시에 나타나지 않아 캐시 하지 않는 것에서 이미지와 폰트를 제외 하였습니다.  ## ie11 flex 축약형  ### 일반적인 축양형  ```css # 아무것도 안쓰면; flex: 0 1 auto;  # flex: 1; flex: 1 1 0%;  # flex: auto; flex: 1 1 auto;  # flex: initial; flex: 0 1 auto ```  ### ie11에서 축약형  ```css # 아무것도 안쓰면; flex: 0 0 auto;  # flex: 1; flex: 1 0 0px;"},{"slug":"/javascript/class","frontmatter":{"title":"Class","date":"2020-05-27T09:05:09.000Z","category":"javascript","draft":false},"excerpt":"## 자바스크립트에서 클래스란?  - ES2015부터 class 키워드를 지원하기 시작했으나, 문법적인 양념일 뿐이며 자바스크립트는 여전히 프로토타입 기반의 언어다.   - https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain - JavaScript class는 ECMAScript 2015을 통해 소개되었으며, 기존 prototype 기반의 상속 보다 명료하게 사용할 수 있습니다. Class 문법은 새로운 객체지향 상속 모델을 제공하는 것은 아닙니다. JavaScript class는 객체를 생성하고 상속을 다루는데 있어 훨씬 더 단순하고 명확한 문법을 제공합니다.   - https://wiki.developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Classes  ## 객체지향 프로그래밍  - 객체 지향 프로그래밍(영어: O","searchableText":"class javascript ## 자바스크립트에서 클래스란?  - es2015부터 class 키워드를 지원하기 시작했으나, 문법적인 양념일 뿐이며 자바스크립트는 여전히 프로토타입 기반의 언어다.   - https://developer.mozilla.org/ko/docs/web/javascript/guide/inheritance_and_the_prototype_chain - javascript class는 ecmascript 2015을 통해 소개되었으며, 기존 prototype 기반의 상속 보다 명료하게 사용할 수 있습니다. class 문법은 새로운 객체지향 상속 모델을 제공하는 것은 아닙니다. javascript class는 객체를 생성하고 상속을 다루는데 있어 훨씬 더 단순하고 명확한 문법을 제공합니다.   - https://wiki.developer.mozilla.org/ko/docs/web/javascript/reference/classes  ## 객체지향 프로그래밍  - 객체 지향 프로그래밍(영어: o"},{"slug":"/develop/terminer-setting","frontmatter":{"title":"Terminer Setting","date":"2020-05-25T22:06:28.000Z","category":"develop","draft":false},"excerpt":"## zsh  ### 버전 확인  ```bash zsh --version # zsh 5.5.1 (x86_64-apple-darwin17.5.0) ```  ### zsh가 없다면 설치  ```bash brew update brew install zsh ```  ### bash를 zsh로 변경  ```bash chsh -s `which zsh` ```  ### 재로그인하거나 터미널을 종료하고 재시작한 후 기본 쉘이 zsh인 것을 확인한다.  - 일부 시스템 특히 OS X에서는 /etc/shells 파일에 설치한 쉘을 등록한 후에 재시작해야 합니다.  ```bash echo $SHELL # /usr/bin/zsh ```  ### oh-my-zsh 설치  ```bash curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh ```  ## iTerm2  ### iTerm2 에서 다운로드 하거나, H","searchableText":"terminer setting develop ## zsh  ### 버전 확인  ```bash zsh --version # zsh 5.5.1 (x86_64-apple-darwin17.5.0) ```  ### zsh가 없다면 설치  ```bash brew update brew install zsh ```  ### bash를 zsh로 변경  ```bash chsh -s `which zsh` ```  ### 재로그인하거나 터미널을 종료하고 재시작한 후 기본 쉘이 zsh인 것을 확인한다.  - 일부 시스템 특히 os x에서는 /etc/shells 파일에 설치한 쉘을 등록한 후에 재시작해야 합니다.  ```bash echo $shell # /usr/bin/zsh ```  ### oh-my-zsh 설치  ```bash curl -l https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh ```  ## iterm2  ### iterm2 에서 다운로드 하거나, h"},{"slug":"/backend/nosql","frontmatter":{"title":"NoSQL","date":"2020-05-13T09:05:41.000Z","category":"backend","tag":["NoSQL"],"draft":false},"excerpt":"- MySQL 같은 SQL 데이터베이스와는 다른 유형의 데이터   - NoSQL의 대표주자인 mongoDB(몽고디비) 사용  ## SQL  - 규칙에 맞는 데이터 입력합니다. - 테이브 간 JOIN 지원합니다. - 트랜잭션 지원합니다. - 안정성, 일관성을 가집니다. - 용어(테이블, 로우, 칼럼)  ## NoSQL  - 자유로운 데이터 입력합니다. - 컬랙션 간 JOIN 지원하지 않습니다.   - JOIN : 관계가 있는 테이블끼리 데이터를 합치는 기능(몽고디비 aggregate)로 흉내 가능 - 트랜잭션 지원하지 않습니다. - 확장성, 가용성을 가집니다. - 용어 (컬렉션, 다큐먼트, 필드) - 빅데이터, 메시징, 세션 관리 등(비정형 데이터)에는 몽고디비 사용하면 좋습니다.  ## 설치  ```bash brew tap mongodb/brew brew install mongodb-community ```  ## 실행  ```bash brew services start mongo","searchableText":"nosql backend - mysql 같은 sql 데이터베이스와는 다른 유형의 데이터   - nosql의 대표주자인 mongodb(몽고디비) 사용  ## sql  - 규칙에 맞는 데이터 입력합니다. - 테이브 간 join 지원합니다. - 트랜잭션 지원합니다. - 안정성, 일관성을 가집니다. - 용어(테이블, 로우, 칼럼)  ## nosql  - 자유로운 데이터 입력합니다. - 컬랙션 간 join 지원하지 않습니다.   - join : 관계가 있는 테이블끼리 데이터를 합치는 기능(몽고디비 aggregate)로 흉내 가능 - 트랜잭션 지원하지 않습니다. - 확장성, 가용성을 가집니다. - 용어 (컬렉션, 다큐먼트, 필드) - 빅데이터, 메시징, 세션 관리 등(비정형 데이터)에는 몽고디비 사용하면 좋습니다.  ## 설치  ```bash brew tap mongodb/brew brew install mongodb-community ```  ## 실행  ```bash brew services start mongo"},{"slug":"/frontend/lh-and-rlh","frontmatter":{"title":"lh and rlh","date":"2020-05-08T09:06:27.000Z","category":"frontend","draft":false},"excerpt":"- CSS 값에 대한 레벨 4 사양에서 완전히 인식하지 못한 몇 가지 새로운 단위가 있습니다. - lh은 계산 된 값과 동일한 line-height, rlh는 루트 요소 (아마도의 동일 html요소)가 아닌 현재의 구성 요소의 line-height 입니다.  ```css .inline-icon { \tdisplay: inline-block; \twidth: 1lh; \theight: 1lh; } ```","searchableText":"lh and rlh frontend - css 값에 대한 레벨 4 사양에서 완전히 인식하지 못한 몇 가지 새로운 단위가 있습니다. - lh은 계산 된 값과 동일한 line-height, rlh는 루트 요소 (아마도의 동일 html요소)가 아닌 현재의 구성 요소의 line-height 입니다.  ```css .inline-icon { \tdisplay: inline-block; \twidth: 1lh; \theight: 1lh; } ```"},{"slug":"/aws/data-transfer","frontmatter":{"title":"data transfer","date":"2020-05-07T23:05:09.000Z","category":"aws","draft":false},"excerpt":"- AWS EC2를 이용해 사이드 프로젝트를 진행하는 중 \\$273.11 달러의 요금 청구서가 날아왔습니다. - Free Tier를 사용하고 있었기 때문에 과금 될 요소가 있지 않다고 생각했습니다.   - EC2, MYSQL, S3를 사용하고 있었습니다. - 비용 발생 요인은 `Data Transfer` 입니다.   - $0.126 per GB - first 10 TB / month data transfer out beyond the global free tier / 1,961.881 GB / $247.20   - $0.01 per GB - regional data transfer - in/out/between EC2 AZs or using elastic IPs or ELB / 107.630 GB / $1.08   - VAT / \\$24.83 - AWS EC2와 S3, MYSQL 간에 데이터 전송은 Data Transfer가 발생하지 않지만 앱에서의 호출 때문에 Data Trans","searchableText":"data transfer aws - aws ec2를 이용해 사이드 프로젝트를 진행하는 중 \\$273.11 달러의 요금 청구서가 날아왔습니다. - free tier를 사용하고 있었기 때문에 과금 될 요소가 있지 않다고 생각했습니다.   - ec2, mysql, s3를 사용하고 있었습니다. - 비용 발생 요인은 `data transfer` 입니다.   - $0.126 per gb - first 10 tb / month data transfer out beyond the global free tier / 1,961.881 gb / $247.20   - $0.01 per gb - regional data transfer - in/out/between ec2 azs or using elastic ips or elb / 107.630 gb / $1.08   - vat / \\$24.83 - aws ec2와 s3, mysql 간에 데이터 전송은 data transfer가 발생하지 않지만 앱에서의 호출 때문에 data trans"},{"slug":"/frontend/ellipsis","frontmatter":{"title":"ellipsis","date":"2020-04-28T09:04:01.000Z","category":"frontend","draft":false},"excerpt":"## 1줄  ```css div {   overflow: hidden;   display: block;   text-overflow: ellipsis;   white-space: nowrap;   width: 100px; /* width 값 반드시 필요 */ } ```  ## 2줄  ```css div {   overflow: hidden;   display: -webkit-box;   -webkit-line-clamp: 3; /* 원하는 라인 수 */   width: 100px; /* width 값 반드시 필요 */   height: 66px; /* 높이는 원하는 줄 수와 width에 따라서 맞게 조정해야 합니다. */   -webkit-box-orient: vertical;   text-overflow: ellipsis; } ```  - line-clamp : 몇줄뒤에 콘텐츠를 자를지를 설정 합니다. - box-orient : 박스의 흐름 방향을 지정합니다.  ## 한줄에 여러","searchableText":"ellipsis frontend ## 1줄  ```css div {   overflow: hidden;   display: block;   text-overflow: ellipsis;   white-space: nowrap;   width: 100px; /* width 값 반드시 필요 */ } ```  ## 2줄  ```css div {   overflow: hidden;   display: -webkit-box;   -webkit-line-clamp: 3; /* 원하는 라인 수 */   width: 100px; /* width 값 반드시 필요 */   height: 66px; /* 높이는 원하는 줄 수와 width에 따라서 맞게 조정해야 합니다. */   -webkit-box-orient: vertical;   text-overflow: ellipsis; } ```  - line-clamp : 몇줄뒤에 콘텐츠를 자를지를 설정 합니다. - box-orient : 박스의 흐름 방향을 지정합니다.  ## 한줄에 여러"},{"slug":"/object/object-chapter-09-유연한-설계","frontmatter":{"title":"object chapter 09 유연한 설계","date":"2020-04-25T10:04:20.000Z","category":"object","draft":false},"excerpt":"- 이번 장에서는 유연하고 재사용 가능할 설계를 만들기 위해 적용할 수 있는 다양한 의존성 관리 기법들을 `원칙`이라는 관점에서 정리 합니다.  ## 01. 개방-폐쇄 원칙  - 개방-폐쇄 원칙(Open-CLosed Principle, OCP) : 소프트웨어 개체(클래스, 모듈, 함수 등등)는 `확장에 열려 있어야 하고`, `수정에 대해서는 닫허 있어야 합니다`.   - 확장에 대해 열려 있다는 것은 애플리케이션의 요구사항이 변경될 때 이 변경에 맞게 새로운 `동작`을 추가해서 애플리케이션의 기능을 확장할 수 있습니다.   - 수정에 대해 닫혀 있다는 것은 기존의 `코드`를 수정하지 않고도 애플리케이션의 `동작을 추가하거나 변경`할 수 있습니다. - 개방-폐쇄 원칙은 유연한 설계란 `기존의 코드를 수정하지 않고도 애플리케이션의 동작을 확장할 수 있는 설계`입니다. - 처음에는 동작을 확장하는 것과 코드를 수정하지 않는 것이 서로 대립되는 개념으로 보일 수도 있습니다.  ### 컴파","searchableText":"object chapter 09 유연한 설계 object - 이번 장에서는 유연하고 재사용 가능할 설계를 만들기 위해 적용할 수 있는 다양한 의존성 관리 기법들을 `원칙`이라는 관점에서 정리 합니다.  ## 01. 개방-폐쇄 원칙  - 개방-폐쇄 원칙(open-closed principle, ocp) : 소프트웨어 개체(클래스, 모듈, 함수 등등)는 `확장에 열려 있어야 하고`, `수정에 대해서는 닫허 있어야 합니다`.   - 확장에 대해 열려 있다는 것은 애플리케이션의 요구사항이 변경될 때 이 변경에 맞게 새로운 `동작`을 추가해서 애플리케이션의 기능을 확장할 수 있습니다.   - 수정에 대해 닫혀 있다는 것은 기존의 `코드`를 수정하지 않고도 애플리케이션의 `동작을 추가하거나 변경`할 수 있습니다. - 개방-폐쇄 원칙은 유연한 설계란 `기존의 코드를 수정하지 않고도 애플리케이션의 동작을 확장할 수 있는 설계`입니다. - 처음에는 동작을 확장하는 것과 코드를 수정하지 않는 것이 서로 대립되는 개념으로 보일 수도 있습니다.  ### 컴파"},{"slug":"/object/object-chapter-08-의존성-관리하기","frontmatter":{"title":"object chapter 08 의존성 관리하기","date":"2020-04-20T12:05:07.000Z","category":"object","draft":false},"excerpt":"- 잘 설계된 객체지향 애플리케이션은 `작고 응집도 높은 객체`들로 구성됩니다. - 이런 작은 객체들이 단독으로 수행할 수 있는 작업은 거의 없기 때문에 객체 사이의 `협력`을 낳습니다. - 협력을 위해서는 의존성이 필요하지만 과도한 의존성은 애플리케이션을 수정하기 어렵게 만듭니다. - 객체지향 설계의 핵심은 협력을 위해 필요한 의존성은 유지하면서도 변경을 방해하는 의존성을 제거하는 데 있습니다.   - 이런 관점에서 `객체지향 설계란 의존성을 관리하는 것이고 객체가 변화를 받아 들일 수 있게 의존성을 정리하는 기술이라고 할 수 있습니다`. - 8장에서는 충분히 협력적이면서도 유연한 객체를 만들기 위해 의존성을 관리하는 방법을 살펴봅니다.  ## 01. 의존성 이해하기  ### 변경과 의존성  - 어떤 객체가 협력하기 위해 다른 객체를 필요로 할 때 두 객체 사이에 의존성이 존재하게 됩니다. - 의존성은 실행 시점과 구현 시점에 서로 다른 의미를 가집니다.   - 실행 시점 : 의","searchableText":"object chapter 08 의존성 관리하기 object - 잘 설계된 객체지향 애플리케이션은 `작고 응집도 높은 객체`들로 구성됩니다. - 이런 작은 객체들이 단독으로 수행할 수 있는 작업은 거의 없기 때문에 객체 사이의 `협력`을 낳습니다. - 협력을 위해서는 의존성이 필요하지만 과도한 의존성은 애플리케이션을 수정하기 어렵게 만듭니다. - 객체지향 설계의 핵심은 협력을 위해 필요한 의존성은 유지하면서도 변경을 방해하는 의존성을 제거하는 데 있습니다.   - 이런 관점에서 `객체지향 설계란 의존성을 관리하는 것이고 객체가 변화를 받아 들일 수 있게 의존성을 정리하는 기술이라고 할 수 있습니다`. - 8장에서는 충분히 협력적이면서도 유연한 객체를 만들기 위해 의존성을 관리하는 방법을 살펴봅니다.  ## 01. 의존성 이해하기  ### 변경과 의존성  - 어떤 객체가 협력하기 위해 다른 객체를 필요로 할 때 두 객체 사이에 의존성이 존재하게 됩니다. - 의존성은 실행 시점과 구현 시점에 서로 다른 의미를 가집니다.   - 실행 시점 : 의"},{"slug":"/develop/oop,-aop,-fp","frontmatter":{"title":"OOP, AOP, FP","date":"2020-04-16T10:05:11.000Z","category":"develop","draft":false},"excerpt":"## OOP (객체지향 프로그래밍)  <a href='/develop/객체지향-프로그래밍(oop)/' target='_blank' rel=\"noopener noreferrer\">자세히보기</a>  ## AOP (관점지향 프로그래밍)  - 스프링 프레임워크의 핵심 요소 중 하나 입니다. - 비즈니스 로직과 공통 모듈로 분리하고, 핵심 로직 사이사이에 공통 모듈을 잘 끼워 넣는 것입니다. 이때 공통 모듈을 코드 밖에서 설정된다는 것이 핵심입니다. - 인증, 로깅, 트랜잭션 처리에 용이합니다.  ## FP (함수형 프로그래밍)  - 함수형 프로그래밍은 선언형 프로그래밍으로, 어떻게(How)가 아닌 `무엇(What)`을 정의한다. - C, Java등의 언어는 명령형 프로그래밍이며, 알고리즘을 기술하고 목적은 기술하지 않습니다. - 선언형은 반대로 알고리즘은 기술하지 않고 목적 위주로 기술하며, 데이터의 입력이 주어지고 데이터의 흐름을 추상적을 정의하는 방식입니다. - 함수형 프로그래밍은","searchableText":"oop, aop, fp develop ## oop (객체지향 프로그래밍)  <a href='/develop/객체지향-프로그래밍(oop)/' target='_blank' rel=\"noopener noreferrer\">자세히보기</a>  ## aop (관점지향 프로그래밍)  - 스프링 프레임워크의 핵심 요소 중 하나 입니다. - 비즈니스 로직과 공통 모듈로 분리하고, 핵심 로직 사이사이에 공통 모듈을 잘 끼워 넣는 것입니다. 이때 공통 모듈을 코드 밖에서 설정된다는 것이 핵심입니다. - 인증, 로깅, 트랜잭션 처리에 용이합니다.  ## fp (함수형 프로그래밍)  - 함수형 프로그래밍은 선언형 프로그래밍으로, 어떻게(how)가 아닌 `무엇(what)`을 정의한다. - c, java등의 언어는 명령형 프로그래밍이며, 알고리즘을 기술하고 목적은 기술하지 않습니다. - 선언형은 반대로 알고리즘은 기술하지 않고 목적 위주로 기술하며, 데이터의 입력이 주어지고 데이터의 흐름을 추상적을 정의하는 방식입니다. - 함수형 프로그래밍은"},{"slug":"/javascript/async-await","frontmatter":{"title":"Async Await","date":"2020-04-12T01:05:06.000Z","category":"javascript","draft":false},"excerpt":"## Async/await  - 더 편안한 환경에서 Promise를 다루기 위해 태어난 특별한 문법입니다. 비동기 프로그래밍을 동기 방식처럼 직관적으로 표현할 수 있어서, Callback을 많이 사용하는 프론트엔드 개발자들에게 많은 사랑을 받고 있습니다.   - async-await는 ECMA-262에서 초안으로 처음 등장했으며, ECMAScript 2017에서 표준으로 정의 되었습니다.     ## Async 함수  - 함수 전에 `async`라는 단어가 의미하는 것은 간단합니다. promise를 반환하는 함수라는 뜻입니다. 심지어 만일함수가 실제로 promise가 아닌 값을 반환해도, `async` 키워드로 정의된 함수는 자바스크립트에서 자동으로 그 값을 resolve promise로 감싸라고 지시합니다. - async는 함수가 promise를 리턴하는 것을 보장해줍니다. 그리고 promise가 아닌 것을 리턴했을 때는 promise로 감싸서 resolve promise를 반환","searchableText":"async await javascript ## async/await  - 더 편안한 환경에서 promise를 다루기 위해 태어난 특별한 문법입니다. 비동기 프로그래밍을 동기 방식처럼 직관적으로 표현할 수 있어서, callback을 많이 사용하는 프론트엔드 개발자들에게 많은 사랑을 받고 있습니다.   - async-await는 ecma-262에서 초안으로 처음 등장했으며, ecmascript 2017에서 표준으로 정의 되었습니다.     ## async 함수  - 함수 전에 `async`라는 단어가 의미하는 것은 간단합니다. promise를 반환하는 함수라는 뜻입니다. 심지어 만일함수가 실제로 promise가 아닌 값을 반환해도, `async` 키워드로 정의된 함수는 자바스크립트에서 자동으로 그 값을 resolve promise로 감싸라고 지시합니다. - async는 함수가 promise를 리턴하는 것을 보장해줍니다. 그리고 promise가 아닌 것을 리턴했을 때는 promise로 감싸서 resolve promise를 반환"},{"slug":"/javascript/iterator","frontmatter":{"title":"Iterator","date":"2020-04-12T00:04:35.000Z","category":"javascript","draft":false},"excerpt":"- Iterator는 자바스크립트의 collection을 반복하는 새로운 방법입니다. ES6에서 소개된 개념이고 매우 유용하고 많은 곳에서 사용되고 있기 때문에 인기가 많습니다.  ## 반복 가능한 것(Iterable)과 Iterator  - `메소드의 이름과 반환 타입이 고정되어 있고 변하지 않는다는 규칙`을 적용한 메소드가 iteratorMethod 입니다. - 이와 비슷하게 사용자 정의 오브젝트를 반복하는 프로세스의 표준화가 `ECMA`에 의해 진행되었습니다. 하지만, iteratorMethod라는 이름을 사용하는 대신에, ECMA는 Symbol.iterator라는 이름을 사용했습니다. `Symbol`은 유일(unique)한 이름을 제공합니다. 그리고 다른 프로퍼티 이름과 충돌이 발생하지 않습니다. 또한, `Symbol.iterator`는 `iterator라 불리는 오브젝트를 반환합니다`. 이 iterator는 next라 불리는 메소드를 가질 것입니다. iterator는 또한","searchableText":"iterator javascript - iterator는 자바스크립트의 collection을 반복하는 새로운 방법입니다. es6에서 소개된 개념이고 매우 유용하고 많은 곳에서 사용되고 있기 때문에 인기가 많습니다.  ## 반복 가능한 것(iterable)과 iterator  - `메소드의 이름과 반환 타입이 고정되어 있고 변하지 않는다는 규칙`을 적용한 메소드가 iteratormethod 입니다. - 이와 비슷하게 사용자 정의 오브젝트를 반복하는 프로세스의 표준화가 `ecma`에 의해 진행되었습니다. 하지만, iteratormethod라는 이름을 사용하는 대신에, ecma는 symbol.iterator라는 이름을 사용했습니다. `symbol`은 유일(unique)한 이름을 제공합니다. 그리고 다른 프로퍼티 이름과 충돌이 발생하지 않습니다. 또한, `symbol.iterator`는 `iterator라 불리는 오브젝트를 반환합니다`. 이 iterator는 next라 불리는 메소드를 가질 것입니다. iterator는 또한"},{"slug":"/javascript/generator","frontmatter":{"title":"generator","date":"2020-04-12T00:04:09.000Z","category":"javascript","draft":false},"excerpt":"- ES6는 제너레이터(Generator) 또는 Generator 함수 형태에서 함수와 Iterator를 다루는 방법을 새롭게 소개했습니다. 제너레이터는 함수를 중간에서 멈추고, 다시 멈췄던 부분부터 실행할 수 있게 합니다. 요약하면, Generator는 함수의 형태를 띄지만, Iterator처럼 동작합니다. - 재미있는 사실은 async/await이 Generator를 기반으로 한 것이라는 겁니다.  ## 제너레이터란 무엇인가?  - 제너레이터는 <b>함수</b>이지만 일반 함수와는 다른 독특한 동작을 합니다. - 일반적인 함수들은 작업이 끝나기 전엔 끝낼 수 없습니다. 이러한 형태의 함수를 run-to-complete 모델이라고 합니다. 반대로, 제너레이터는 `중간에 멈출 수 있는 함수`입니다. 그리고 `멈춘 부분부터 다시 실행`을 시작할 수 있습니다. - 제너레이터의 일반적인 정의는 다음과 같습니다.   - 제너레이터는 Iterator 작성 작업을 간단하게 해줄 수 있는 함수","searchableText":"generator javascript - es6는 제너레이터(generator) 또는 generator 함수 형태에서 함수와 iterator를 다루는 방법을 새롭게 소개했습니다. 제너레이터는 함수를 중간에서 멈추고, 다시 멈췄던 부분부터 실행할 수 있게 합니다. 요약하면, generator는 함수의 형태를 띄지만, iterator처럼 동작합니다. - 재미있는 사실은 async/await이 generator를 기반으로 한 것이라는 겁니다.  ## 제너레이터란 무엇인가?  - 제너레이터는 <b>함수</b>이지만 일반 함수와는 다른 독특한 동작을 합니다. - 일반적인 함수들은 작업이 끝나기 전엔 끝낼 수 없습니다. 이러한 형태의 함수를 run-to-complete 모델이라고 합니다. 반대로, 제너레이터는 `중간에 멈출 수 있는 함수`입니다. 그리고 `멈춘 부분부터 다시 실행`을 시작할 수 있습니다. - 제너레이터의 일반적인 정의는 다음과 같습니다.   - 제너레이터는 iterator 작성 작업을 간단하게 해줄 수 있는 함수"},{"slug":"/javascript/this","frontmatter":{"title":"this","date":"2020-04-10T18:04:24.000Z","category":"javascript","tags":["this","call","apply","bind","함수 호출","메소드 호출","생성자 함수 호출","명시적바인딩","묵시적바인딩"],"draft":false},"excerpt":"## this  - 자바스크립트의 함수는 호출될 때, 매개변수로 전달되는 인자값 이외에, arguments 객체와 this를 암묵적으로 전달 받습니다.   - 자바스크립트의 this keyword는 Java와 같은 익숙한 언어의 개념과 달라 개발자에게 혼란을 줍니다.   - Java에서의 this는 인스턴스 자신(self)을 가리키는 참조변수입니다. this가 객체 자신에 대한 참조 값을 가지고 있다는 뜻입니다. 주로 매개변수와 객체 자신이 가지고 있는 멤버변수명이 같을 경우 이를 구분하기 위해서 사용됩니다.   - 자바스크립트의 경우 Java와 같이 this에 바인딩되는 객체는 한가지가 아니라 해당 함수 호출 방식에 따라 this에 바인딩되는 객체가 달라집니다. - this는 함수가 동작하는 곳에 있는 오브젝트와 연결해줍니다. - 자바스크립트의 경우 함수 호출 방식에 의해 this에 바인딩할 어떤 객체가 동적으로 결정됩니다. 다시 말해, 함수를 선언할 때 this에 바인딩할 객체","searchableText":"this javascript this call apply bind 함수 호출 메소드 호출 생성자 함수 호출 명시적바인딩 묵시적바인딩 ## this  - 자바스크립트의 함수는 호출될 때, 매개변수로 전달되는 인자값 이외에, arguments 객체와 this를 암묵적으로 전달 받습니다.   - 자바스크립트의 this keyword는 java와 같은 익숙한 언어의 개념과 달라 개발자에게 혼란을 줍니다.   - java에서의 this는 인스턴스 자신(self)을 가리키는 참조변수입니다. this가 객체 자신에 대한 참조 값을 가지고 있다는 뜻입니다. 주로 매개변수와 객체 자신이 가지고 있는 멤버변수명이 같을 경우 이를 구분하기 위해서 사용됩니다.   - 자바스크립트의 경우 java와 같이 this에 바인딩되는 객체는 한가지가 아니라 해당 함수 호출 방식에 따라 this에 바인딩되는 객체가 달라집니다. - this는 함수가 동작하는 곳에 있는 오브젝트와 연결해줍니다. - 자바스크립트의 경우 함수 호출 방식에 의해 this에 바인딩할 어떤 객체가 동적으로 결정됩니다. 다시 말해, 함수를 선언할 때 this에 바인딩할 객체"},{"slug":"/object/object-chapter-05-책임-할당하기","frontmatter":{"title":"object chapter 05 책임 할당하기","date":"2020-04-07T15:05:11.000Z","category":"object","draft":false},"excerpt":"- 5장에서는 2장에서 소개한 코드의 설계 과정을 한 걸음씩 따라가 보면서 객체에 책임을 할당하는 기본적인 원리를 살펴 봅니다.  - 데이터 중심의 설계는 `행동보다 데이터를 먼저 결정`하고 협력이라는 문맥을 벗어나 고립된 객체의 상태에 초점을 맞추기 때문에 캡슐화를 위반하기 쉽고, 요소들 사이의 결합도가 높아지며, 코드를 변경하기 어려워집니다. - 데이터 중심 설계로 인해 발생하는 문제점을 해결할 수 있는 가장 기본적인 방법은 데이터가 아닌 `책임`에 초점을 맞추는 것입니다. - 책임에 초점을 맞춰서 설계할 때 직면하는 가장 큰 어려움은 `어떤 객체에게 어떤 책임을 할당할지는 결정하기가 쉽지 않다`는 것입니다. 책임 할당 과정은 일종의 트레이드오프 활동입니다. 동일한 문제를 해결할 수 있는 다양한 책임 할당 방법이 존재하며, 어떤 방법이 최선인지는 상황과 문맥에 따라 달라집니다. 따라서 올바른 책임을 할당하기 위해서는 다양한 관점에서 설계를 평가할 수 있어야 합니다. - GRAS","searchableText":"object chapter 05 책임 할당하기 object - 5장에서는 2장에서 소개한 코드의 설계 과정을 한 걸음씩 따라가 보면서 객체에 책임을 할당하는 기본적인 원리를 살펴 봅니다.  - 데이터 중심의 설계는 `행동보다 데이터를 먼저 결정`하고 협력이라는 문맥을 벗어나 고립된 객체의 상태에 초점을 맞추기 때문에 캡슐화를 위반하기 쉽고, 요소들 사이의 결합도가 높아지며, 코드를 변경하기 어려워집니다. - 데이터 중심 설계로 인해 발생하는 문제점을 해결할 수 있는 가장 기본적인 방법은 데이터가 아닌 `책임`에 초점을 맞추는 것입니다. - 책임에 초점을 맞춰서 설계할 때 직면하는 가장 큰 어려움은 `어떤 객체에게 어떤 책임을 할당할지는 결정하기가 쉽지 않다`는 것입니다. 책임 할당 과정은 일종의 트레이드오프 활동입니다. 동일한 문제를 해결할 수 있는 다양한 책임 할당 방법이 존재하며, 어떤 방법이 최선인지는 상황과 문맥에 따라 달라집니다. 따라서 올바른 책임을 할당하기 위해서는 다양한 관점에서 설계를 평가할 수 있어야 합니다. - gras"},{"slug":"/frontend/크롤링","frontmatter":{"title":"크롤링","date":"2020-04-03T01:04:48.000Z","category":"frontend","draft":false},"excerpt":"- javascript를 활용해서 웹사이트를 크롤링 합니다.  ```javascript const axios = require('axios'); const cheerio = require('cheerio');  export const getHtml = async () => { \ttry { \t\treturn await axios.get('https://naver.com'); \t} catch (error) { \t\tconsole.error(error); \t} }; export const get = async () => { \tconst html = await getHtml(); \tlet ulList = []; \tconst $ = cheerio.load(html.data); \tconst $bodyList = $('tbody').children('tr');  \t$bodyList.each(function(i, elem) { \t\tulList[i] = { \t\t\ttitle: $(this) \t\t\t\t.f","searchableText":"크롤링 frontend - javascript를 활용해서 웹사이트를 크롤링 합니다.  ```javascript const axios = require('axios'); const cheerio = require('cheerio');  export const gethtml = async () => { \ttry { \t\treturn await axios.get('https://naver.com'); \t} catch (error) { \t\tconsole.error(error); \t} }; export const get = async () => { \tconst html = await gethtml(); \tlet ullist = []; \tconst $ = cheerio.load(html.data); \tconst $bodylist = $('tbody').children('tr');  \t$bodylist.each(function(i, elem) { \t\tullist[i] = { \t\t\ttitle: $(this) \t\t\t\t.f"},{"slug":"/typescript/커스텀-타입-선언-파일","frontmatter":{"title":"커스텀 타입 선언 파일","date":"2020-03-26T20:03:31.000Z","category":"typescript","draft":false},"excerpt":"## npm 모듈의 타입 선언 파일(.d.ts)을 커스텀 타입 선언 파일로 대체하는 법  ### 원본 .d.ts 파일이 node_modules 아래에 있을 경우  ```json // tsconfig.json { \t\"compilerOptions\": { \t\t\"baseUrl\": \".\", \t\t\"paths\": [{ \"moduleA\": \"./src/@types/myDeclaration.d.ts\" }] \t} } ```  1. 컴파일러는 src/index.ts에서 non-relative module import구문을 발견하여 moduleA모듈에 대한 타입 선언 파일을 탐색하기 시작합니다. 2. compilerOptions.path에 moduleA에 대한 경로 설정이 존재하므로 해당 경로를 우선 탐색합니다. 3. 경로에서 .d.ts파일을 찾았으므로 탐색을 종료하고, myDeclaration.d.ts파일 내의 모듈 타입 선언을 앰비언트 모듈 선언 목록에 추가합니다.  #### 원본 .d.ts 파일이","searchableText":"커스텀 타입 선언 파일 typescript ## npm 모듈의 타입 선언 파일(.d.ts)을 커스텀 타입 선언 파일로 대체하는 법  ### 원본 .d.ts 파일이 node_modules 아래에 있을 경우  ```json // tsconfig.json { \t\"compileroptions\": { \t\t\"baseurl\": \".\", \t\t\"paths\": [{ \"modulea\": \"./src/@types/mydeclaration.d.ts\" }] \t} } ```  1. 컴파일러는 src/index.ts에서 non-relative module import구문을 발견하여 modulea모듈에 대한 타입 선언 파일을 탐색하기 시작합니다. 2. compileroptions.path에 modulea에 대한 경로 설정이 존재하므로 해당 경로를 우선 탐색합니다. 3. 경로에서 .d.ts파일을 찾았으므로 탐색을 종료하고, mydeclaration.d.ts파일 내의 모듈 타입 선언을 앰비언트 모듈 선언 목록에 추가합니다.  #### 원본 .d.ts 파일이"},{"slug":"/develop/github-education-name.com-사용하기","frontmatter":{"title":"github education name.com 사용하기","date":"2020-03-22T22:03:06.000Z","category":"develop","draft":false},"excerpt":"- 도메인 구입 - DNS 세팅   - type : A   - answer : {본인 IP} - SSL 적용   - CSR 생성  ```bash mkdir ~/www.moti.company.ssl/ cd ~/www.moti.company.ssl/ openssl genrsa -out ~/www.moti.company.ssl/www.moti.company.key 2048 openssl req -new -sha256 -key ~/www.moti.company.ssl/www.moti.company.key -out ~/www.moti.company.ssl/www.moti.company.csr ```  > 이메일과 전화번호는 name.com 사이트와 일치하게 작성합니다.   > 도메인과 파일 이름을 같게 세팅 합니다.  - 인증서 설치    - 아래의 정보를 바탕으로 인증서 받기    ```bash     cat ~/www.moti.company.ssl/www.moti.company.csr","searchableText":"github education name.com 사용하기 develop - 도메인 구입 - dns 세팅   - type : a   - answer : {본인 ip} - ssl 적용   - csr 생성  ```bash mkdir ~/www.moti.company.ssl/ cd ~/www.moti.company.ssl/ openssl genrsa -out ~/www.moti.company.ssl/www.moti.company.key 2048 openssl req -new -sha256 -key ~/www.moti.company.ssl/www.moti.company.key -out ~/www.moti.company.ssl/www.moti.company.csr ```  > 이메일과 전화번호는 name.com 사이트와 일치하게 작성합니다.   > 도메인과 파일 이름을 같게 세팅 합니다.  - 인증서 설치    - 아래의 정보를 바탕으로 인증서 받기    ```bash     cat ~/www.moti.company.ssl/www.moti.company.csr"},{"slug":"/develop/스프린트 운영 가이드","frontmatter":{"title":"스프린트 운영 가이드 - 2주 단위 애자일 개발 프로세스","date":"2020-03-06T13:03:55.000Z","category":"develop","tags":["스프린트","애자일","프로젝트관리","지라","스크럼"],"excerpt":"2주 단위 스프린트를 활용한 애자일 개발 프로세스 운영 가이드입니다. 작업 티켓 관리부터 스프린트 플래닝까지 실전 경험을 바탕으로 정리했습니다.","draft":false},"excerpt":"스프린트(Sprint)는 애자일 개발 방법론의 핵심입니다. 2주 단위로 작업을 계획하고 실행하며, 지속적으로 개선하는 사이클을 만듭니다. 이 글에서는 실제 프로젝트에서 사용한 스프린트 운영 가이드를 정리했습니다.  ## 작업 티켓 단위별 발행 담당자  프로젝트 작업을 체계적으로 관리하기 위해 티켓을 계층적으로 구성합니다. 각 티켓 단위별로 담당자가 명확히 정해져 있습니다.  | 구분    | 담당                   | 프로젝트 상세                                                          | | ------- | ---------------------- | ---------------------------------------------------------------------- | | Epic    | PM                     | 프로젝트 에픽 티켓 생성","searchableText":"스프린트 운영 가이드 - 2주 단위 애자일 개발 프로세스 develop 스프린트 애자일 프로젝트관리 지라 스크럼 스프린트(sprint)는 애자일 개발 방법론의 핵심입니다. 2주 단위로 작업을 계획하고 실행하며, 지속적으로 개선하는 사이클을 만듭니다. 이 글에서는 실제 프로젝트에서 사용한 스프린트 운영 가이드를 정리했습니다.  ## 작업 티켓 단위별 발행 담당자  프로젝트 작업을 체계적으로 관리하기 위해 티켓을 계층적으로 구성합니다. 각 티켓 단위별로 담당자가 명확히 정해져 있습니다.  | 구분    | 담당                   | 프로젝트 상세                                                          | | ------- | ---------------------- | ---------------------------------------------------------------------- | | epic    | pm                     | 프로젝트 에픽 티켓 생성"},{"slug":"/develop/repository와-dao","frontmatter":{"title":"repository와 DAO","date":"2020-02-24T18:02:29.000Z","category":"develop","draft":false},"excerpt":"- Repository는 하나의 도메인에 관련 된 것들을 컨트롤 합니다.   - 하나의 도메인에는 여러개의 테이블이 존재할 수 있습니다.   - REPOSITORY는 메모리에 로드된 객체 컬렉션에 대한 집합 처리를 위한 인터페이스를 제공합니다. - DAO(Data Access Object)는 하나의 테이블에 관련 된 것들을 컨트롤 합니다.   - Entity Bean을 대체하기 위한 DAO의 인터페이스는 데이터베이스의 CRUD 쿼리와 1:1 매칭되는 세밀한 단위의 오퍼레이션을 제공합니다.","searchableText":"repository와 dao develop - repository는 하나의 도메인에 관련 된 것들을 컨트롤 합니다.   - 하나의 도메인에는 여러개의 테이블이 존재할 수 있습니다.   - repository는 메모리에 로드된 객체 컬렉션에 대한 집합 처리를 위한 인터페이스를 제공합니다. - dao(data access object)는 하나의 테이블에 관련 된 것들을 컨트롤 합니다.   - entity bean을 대체하기 위한 dao의 인터페이스는 데이터베이스의 crud 쿼리와 1:1 매칭되는 세밀한 단위의 오퍼레이션을 제공합니다."},{"slug":"/develop/동기-비동기","frontmatter":{"title":"동기 비동기","date":"2020-02-24T12:02:21.000Z","category":"develop","draft":false},"excerpt":"## SYNC / ASYNC  - 중요한 포인트는 `순서와 결과(처리)이 관점 `입니다. - `return 한다면 SYNC, callback으로 응답한다면 ASYNC 입니다`. - Synchronous / Asynchronous는 호출되는 함수의 작업 완료 여부를 누가 신경쓰냐가 관심사 입니다. - SYNC : 서브루틴이 즉시 값을 반환 합니다.   - 이벤트를 자신이 직접 처리 합니다.(확인의 주체가 유저 프로세스이며, 다 될때까지 기다리거나 스스로 확인 합니다.)   - Synchronous I/O : 작업을 요청한 후 작업의 결과가 나올 때까지 기다린 후 처리 합니다.(프로세스는 커널에 지속적으로 I/O 준비사항을 체크 합니다.) - ASYNC : 서브루틴이 콜백을 통해 값을 반환 합니다.   - 이벤트 핸들러 (callback)에 의해 처리 합니다.(callback 함수가 호출되기까지 다른 작업 가능 합니다.)   - Asynchronous I/O : 직전 시스템 호출의 종","searchableText":"동기 비동기 develop ## sync / async  - 중요한 포인트는 `순서와 결과(처리)이 관점 `입니다. - `return 한다면 sync, callback으로 응답한다면 async 입니다`. - synchronous / asynchronous는 호출되는 함수의 작업 완료 여부를 누가 신경쓰냐가 관심사 입니다. - sync : 서브루틴이 즉시 값을 반환 합니다.   - 이벤트를 자신이 직접 처리 합니다.(확인의 주체가 유저 프로세스이며, 다 될때까지 기다리거나 스스로 확인 합니다.)   - synchronous i/o : 작업을 요청한 후 작업의 결과가 나올 때까지 기다린 후 처리 합니다.(프로세스는 커널에 지속적으로 i/o 준비사항을 체크 합니다.) - async : 서브루틴이 콜백을 통해 값을 반환 합니다.   - 이벤트 핸들러 (callback)에 의해 처리 합니다.(callback 함수가 호출되기까지 다른 작업 가능 합니다.)   - asynchronous i/o : 직전 시스템 호출의 종"},{"slug":"/typescript/node-javascript에서-typescript로-바꾸기","frontmatter":{"title":"Node javascript에서 typescript로 바꾸기","date":"2020-02-22T11:02:44.000Z","category":"typescript","draft":false},"excerpt":"## tsconfig 파일 작성  ``` {   \"compilerOptions\": {     \"target\": \"es2016\",     \"lib\": [\"es2016\"],     \"outDir\": \"dist\",     \"typeRoots\": [\"./node_modules/@types\"],     \"module\": \"commonjs\",     \"moduleResolution\": \"node\",     \"experimentalDecorators\": true,     \"emitDecoratorMetadata\": true,     \"allowSyntheticDefaultImports\": true,     \"allowJs\": true   },   \"exclude\": [\"node_modules\"] } ```  - esModuleInterop을 설정하지 않고 module.exports와 export default를 다르게 import 한다.   - module.exports `import * as","searchableText":"node javascript에서 typescript로 바꾸기 typescript ## tsconfig 파일 작성  ``` {   \"compileroptions\": {     \"target\": \"es2016\",     \"lib\": [\"es2016\"],     \"outdir\": \"dist\",     \"typeroots\": [\"./node_modules/@types\"],     \"module\": \"commonjs\",     \"moduleresolution\": \"node\",     \"experimentaldecorators\": true,     \"emitdecoratormetadata\": true,     \"allowsyntheticdefaultimports\": true,     \"allowjs\": true   },   \"exclude\": [\"node_modules\"] } ```  - esmoduleinterop을 설정하지 않고 module.exports와 export default를 다르게 import 한다.   - module.exports `import * as"},{"slug":"/frontend/애플리케이션-보안","frontmatter":{"title":"애플리케이션 보안","date":"2020-02-21T17:02:33.000Z","category":"frontend","draft":false},"excerpt":"## 애플리케이션 보안  - 주입(Injection) - 크로스 사이트 스크립트(Cross-site scripting) - 크로스 사이트 요청 위조 토큰 보호(Cross-site request forgery protection) - 오픈 리다이렉션(Open redirects)  ### 주입(Injection)  - SQL 주입은 애플리케이션에 영향을 끼치는 가장 일반적인 주입의 형태입니다.  ```javascript const query = `SELECT * FROM user WHERE username = ${username} AND password = ${password}`; ```  - 위의 경우 username이 `OR 1=1 --` 일 경우 `--` 문자 시퀀스는 라인의 나머지 부분을 주석으로 만들기 때문에 `SELECT * FROM user WHERE username = OR 1=1`가 되어 사용자 전체 리스트를 반환합니다. - SQL 주입을 방지하기 위한 방법은 준비된","searchableText":"애플리케이션 보안 frontend ## 애플리케이션 보안  - 주입(injection) - 크로스 사이트 스크립트(cross-site scripting) - 크로스 사이트 요청 위조 토큰 보호(cross-site request forgery protection) - 오픈 리다이렉션(open redirects)  ### 주입(injection)  - sql 주입은 애플리케이션에 영향을 끼치는 가장 일반적인 주입의 형태입니다.  ```javascript const query = `select * from user where username = ${username} and password = ${password}`; ```  - 위의 경우 username이 `or 1=1 --` 일 경우 `--` 문자 시퀀스는 라인의 나머지 부분을 주석으로 만들기 때문에 `select * from user where username = or 1=1`가 되어 사용자 전체 리스트를 반환합니다. - sql 주입을 방지하기 위한 방법은 준비된"},{"slug":"/frontend/html-edit","frontmatter":{"title":"html edit","date":"2020-02-21T17:02:15.000Z","category":"frontend","draft":false},"excerpt":"- `document.designMode = \"on\"`, `document.getElementById(\"myP\").contentEditable = true` - 두 속성을 이용해서 html 수정을 허용 할 수 있습니다.","searchableText":"html edit frontend - `document.designmode = \"on\"`, `document.getelementbyid(\"myp\").contenteditable = true` - 두 속성을 이용해서 html 수정을 허용 할 수 있습니다."},{"slug":"/frontend/hover","frontmatter":{"title":"hover","date":"2020-02-14T17:02:04.000Z","category":"frontend","draft":false},"excerpt":"- 마우스를 올리면 텍스트 밑에 밑줄을 긋는다거나 배경색을 바꾸는 효과를 줄때가 있습니다. - 하지만 모바일에서는 호버 이벤트가 업습니다. 하지만 이를 위해 action 가상 선택자를 통해 클릭 시 효과를 주는 것으로 통일성을 줄 수 있습니다. - 하지만 호버 이벤트를 모바일 사이즈에서 없애지 않는다면 클릭 후 색이 남는 현상이 발생 했습니다.  ## 이벤트 주기  ```scss &:hover { \tbackground: red; } @media (max-width: 800px) { \t&:active { \t\tbackground: $CG100; \t} } ```  ## 호버 이벤트를 지워 클릭 후 남는 색 없애기  ```scss &:hover { \tbackground: red; } @media (max-width: 800px) { \t&:hover { \t\tbackground-color: transparent; \t} \t&:active { \t\tbackground: $CG100; \t} } ``","searchableText":"hover frontend - 마우스를 올리면 텍스트 밑에 밑줄을 긋는다거나 배경색을 바꾸는 효과를 줄때가 있습니다. - 하지만 모바일에서는 호버 이벤트가 업습니다. 하지만 이를 위해 action 가상 선택자를 통해 클릭 시 효과를 주는 것으로 통일성을 줄 수 있습니다. - 하지만 호버 이벤트를 모바일 사이즈에서 없애지 않는다면 클릭 후 색이 남는 현상이 발생 했습니다.  ## 이벤트 주기  ```scss &:hover { \tbackground: red; } @media (max-width: 800px) { \t&:active { \t\tbackground: $cg100; \t} } ```  ## 호버 이벤트를 지워 클릭 후 남는 색 없애기  ```scss &:hover { \tbackground: red; } @media (max-width: 800px) { \t&:hover { \t\tbackground-color: transparent; \t} \t&:active { \t\tbackground: $cg100; \t} } ``"},{"slug":"/frontend/pointer-events","frontmatter":{"title":"pointer events","date":"2020-02-13T10:02:58.000Z","category":"frontend","draft":false},"excerpt":"- 스크롤 되는 영역에 그라데이션을 넣어야 했습니다. - 아래 영역에서 before과 absolute를 이용해서 스크롤 되는 리스트 하단에 항상 그라데이션을 넣는 것에는 성공했습니다. - 하지만 그 영역에서 스크롤이 되지 않았습니다. - 그냥 보기엔 리스트의 영역처럼 보이지만 실제론 아래 영역 안에 포함된 곳이기 때문에 스크롤이 되지 않는 것이 올바른 동작입니다. - 이를 해결하기 위해 CSS 속성인 `pointer-events: none`을 사용해서 포인터 이벤트를 없앰으로서 리스트의 하단 그라데이션 영역에서도 스크롤이 가능합니다.","searchableText":"pointer events frontend - 스크롤 되는 영역에 그라데이션을 넣어야 했습니다. - 아래 영역에서 before과 absolute를 이용해서 스크롤 되는 리스트 하단에 항상 그라데이션을 넣는 것에는 성공했습니다. - 하지만 그 영역에서 스크롤이 되지 않았습니다. - 그냥 보기엔 리스트의 영역처럼 보이지만 실제론 아래 영역 안에 포함된 곳이기 때문에 스크롤이 되지 않는 것이 올바른 동작입니다. - 이를 해결하기 위해 css 속성인 `pointer-events: none`을 사용해서 포인터 이벤트를 없앰으로서 리스트의 하단 그라데이션 영역에서도 스크롤이 가능합니다."},{"slug":"/backend/413-request-entity-too-large","frontmatter":{"title":"413 Request Entity Too Large","date":"2020-02-13T01:02:27.000Z","category":"backend","draft":false},"excerpt":"- 이미지를 업로드 하는 경우에 로컬에서는 문제가 없었으나 호스팅한 서버에서는 `413 Request Entity Too Large`를 반환했습니다. - 413 Request Entity Too Large는 nginx에서 업로드한 파일의 용량이 제한 수치를 넘겨서 발생 했습니다.   - 로컬에선 nginx를 사용하지 않고 호스팅 된 서버에서는 80포트를 8080포트로 옮겨주기 위해 사용했습니다.  ## 해결 방안  - nginx 서버 업로드 크기(사이즈)를 설정합니다. - 설정되지 않은 경우 1M가 넘는 경우 에러가 발생합니다.  ```bash vi /etc/nginx/nginx.conf ```  ```vi http {   client_max_body_size 0; } ```  ```bash sudo service nginx restart ```","searchableText":"413 request entity too large backend - 이미지를 업로드 하는 경우에 로컬에서는 문제가 없었으나 호스팅한 서버에서는 `413 request entity too large`를 반환했습니다. - 413 request entity too large는 nginx에서 업로드한 파일의 용량이 제한 수치를 넘겨서 발생 했습니다.   - 로컬에선 nginx를 사용하지 않고 호스팅 된 서버에서는 80포트를 8080포트로 옮겨주기 위해 사용했습니다.  ## 해결 방안  - nginx 서버 업로드 크기(사이즈)를 설정합니다. - 설정되지 않은 경우 1m가 넘는 경우 에러가 발생합니다.  ```bash vi /etc/nginx/nginx.conf ```  ```vi http {   client_max_body_size 0; } ```  ```bash sudo service nginx restart ```"},{"slug":"/develop/http","frontmatter":{"title":"http","date":"2020-02-11T09:02:40.000Z","category":"develop","draft":false},"excerpt":"## HTTP란?  - HTTP는 웹상에서 Client (Internet Explorer, Chrome, Firefox) 와 Server (웹서버 eg: httpd, nginx, etc...)간 통신을 위한 Protocol 입니다. - HTTP는 1996년 처음 1.0버전이 release되고 1999년 현재 우리가 공식적으로 가장 많이 사용하고 지원하는 버전인 1.1이 출시된 이후 15년동안 발전없이 사용되고 있습니다.  ## HTTP/0.9  - HTTP/0.9는 GET 메소드만 사용하는 아주 단순한 프로토콜입니다. HTML만 전송이 가능합니다.  ## HTTP/1.0  - HTTP/1.0에서 헤더가 추가되고 핸드쉐이크가 도입되었습니다. - HTTP/1.0은 기본적으로 Connection 당 하나의 요청을 처리 하도록 설계 되어 있습니다. 그래서 위 그림과 같이 동시전송이 불가능하고 요청과 응답이 순차적으로 이루어 지게 됩니다. 그렇다 보니 HTTP 문서안에 포함된 다수의 리소스","searchableText":"http develop ## http란?  - http는 웹상에서 client (internet explorer, chrome, firefox) 와 server (웹서버 eg: httpd, nginx, etc...)간 통신을 위한 protocol 입니다. - http는 1996년 처음 1.0버전이 release되고 1999년 현재 우리가 공식적으로 가장 많이 사용하고 지원하는 버전인 1.1이 출시된 이후 15년동안 발전없이 사용되고 있습니다.  ## http/0.9  - http/0.9는 get 메소드만 사용하는 아주 단순한 프로토콜입니다. html만 전송이 가능합니다.  ## http/1.0  - http/1.0에서 헤더가 추가되고 핸드쉐이크가 도입되었습니다. - http/1.0은 기본적으로 connection 당 하나의 요청을 처리 하도록 설계 되어 있습니다. 그래서 위 그림과 같이 동시전송이 불가능하고 요청과 응답이 순차적으로 이루어 지게 됩니다. 그렇다 보니 http 문서안에 포함된 다수의 리소스"},{"slug":"/react/function-component-type","frontmatter":{"title":"function component type","date":"2020-02-10T12:03:06.000Z","category":"react","draft":false},"excerpt":"- react에서 function으로 만들어진 component에는 4가지 타입이 있었습니다. - FC, SFC, FunctionComponent, StatelessComponent - 하지만 hooks로 인해서 function component에서도 state를 사용할 수 있게 되어 SFC와 StatelessComponent가 deprecated 되었습니다.","searchableText":"function component type react - react에서 function으로 만들어진 component에는 4가지 타입이 있었습니다. - fc, sfc, functioncomponent, statelesscomponent - 하지만 hooks로 인해서 function component에서도 state를 사용할 수 있게 되어 sfc와 statelesscomponent가 deprecated 되었습니다."},{"slug":"/develop/tcp-udp","frontmatter":{"title":"TCP UDP","date":"2020-02-09T21:02:00.000Z","category":"frontend","draft":false},"excerpt":"## TCP  - 연결형 서비스입니다. - 가상 회선 방식입니다. - 전송 순서 보장합니다. - 신뢰성 높습니다. - 전송 속도 느립니다. - http/1과 http/2는 TCP를 사용합니다.  ## UDP  - 비연결형 서비스입니다 - 데이터그램 방식입니다. - 전송 순서 보장 하지 않습니다. - 신뢰성 낮습니다. - 전송 속도 빠릅니다. - http/3는 UDP를 사용합니다. - 커스터마이징이 용이합니다.","searchableText":"tcp udp frontend ## tcp  - 연결형 서비스입니다. - 가상 회선 방식입니다. - 전송 순서 보장합니다. - 신뢰성 높습니다. - 전송 속도 느립니다. - http/1과 http/2는 tcp를 사용합니다.  ## udp  - 비연결형 서비스입니다 - 데이터그램 방식입니다. - 전송 순서 보장 하지 않습니다. - 신뢰성 낮습니다. - 전송 속도 빠릅니다. - http/3는 udp를 사용합니다. - 커스터마이징이 용이합니다."},{"slug":"/frontend/input","frontmatter":{"title":"input","date":"2020-02-08T15:03:14.000Z","category":"frontend","draft":false},"excerpt":"## \\<input type=\" \"> 속성  ### input 태그에서 공통적으로 사용되는 속성들  #### <a href='https://developer.mozilla.org/ko/docs/Web/HTML/Attributes/autocomplete' target=\"\\_blank\">autocomplete</a>  - 양식 자동생성 기능 암시. Boolean 속성이 아니며 공백으로 구분된 문자열을 값으로 갖는다. - 간단하게는 'on', 'off' 값으로 설정하지만 더 복잡한 자동 완성 구문을 사용할 수도 있다.  #### autofocus  - 페이지가 로딩 될 때 자동으로 초점을 맞출 컨트롤을 지정합니다. - boolean 속성이므로 값을 가지지 않는다. - 한 페이지에 하나의 컨트롤만 이 속성을 가질 수 있으며, 여러 컨트롤에 지정될 경우 맨 첫번째 컨트롤에 지정됩니다. - 접근성 측면에서 사용이 권장되지 않습니다.  #### disabled  - 컨트롤의 활성화 여부 지정합","searchableText":"input frontend ## \\<input type=\" \"> 속성  ### input 태그에서 공통적으로 사용되는 속성들  #### <a href='https://developer.mozilla.org/ko/docs/web/html/attributes/autocomplete' target=\"\\_blank\">autocomplete</a>  - 양식 자동생성 기능 암시. boolean 속성이 아니며 공백으로 구분된 문자열을 값으로 갖는다. - 간단하게는 'on', 'off' 값으로 설정하지만 더 복잡한 자동 완성 구문을 사용할 수도 있다.  #### autofocus  - 페이지가 로딩 될 때 자동으로 초점을 맞출 컨트롤을 지정합니다. - boolean 속성이므로 값을 가지지 않는다. - 한 페이지에 하나의 컨트롤만 이 속성을 가질 수 있으며, 여러 컨트롤에 지정될 경우 맨 첫번째 컨트롤에 지정됩니다. - 접근성 측면에서 사용이 권장되지 않습니다.  #### disabled  - 컨트롤의 활성화 여부 지정합"},{"slug":"/Java/jre-jvm","frontmatter":{"title":"JRE JVM","date":"2020-02-06T09:02:27.000Z","category":"java","draft":false},"excerpt":"- JVM은 자바 가상머신(Java Virtual Machine)의 약자입니다. - JRE는 자바 실행환경(Java Runtime Environment)의 약자입니다.  ## JDK  - JDK는 자바 개발도구(Java Development Kit)의 약자입니다. - JDK는 JRE + 개발을 위해 필요한 도구(javac, java등)들을 포함합니다. - v8은 jvm가 아니라 jre랑 비슷한거 같습니다… - jvm이랑 v8이 같냐고 물었다가 전혀 다른거라고 들었던 기억이 스쳐갑니다…","searchableText":"jre jvm java - jvm은 자바 가상머신(java virtual machine)의 약자입니다. - jre는 자바 실행환경(java runtime environment)의 약자입니다.  ## jdk  - jdk는 자바 개발도구(java development kit)의 약자입니다. - jdk는 jre + 개발을 위해 필요한 도구(javac, java등)들을 포함합니다. - v8은 jvm가 아니라 jre랑 비슷한거 같습니다… - jvm이랑 v8이 같냐고 물었다가 전혀 다른거라고 들었던 기억이 스쳐갑니다…"},{"slug":"/Java/java-string","frontmatter":{"title":"Java String","date":"2020-02-05T09:02:29.000Z","category":"java","draft":false},"excerpt":"```java String a = ‘one’; String b = ‘one’; a == b; // true String c = ‘on’; String d = c + ‘e’; // String d = (c + ‘e’).intern(); a == d // false String e = ‘on’ + ‘e’ a == e // true ```  - String a = “”로 생성하는건 String pool을 할당하는거고 내부적으로 intern()이라는 코드를 통해 상수풀에 값을 올립니다. 이미 존재하는 값이라면 값을 주소를 리턴하는 것을 보장합니다. - “hello” + “world”와 같은 동작도 String pool을 할당받은 동작을 하는 것이기 때문에 a==e 는 true 입니다. - “문자열” + 객체를 생성할경우 새로운 주소값을 생성하는거지만 intern() 키워드를 붙여 (“문자열 + 객체).intern() 일경우 상수풀에 올라가는거고 해당 상수풀에는 나중에 참조하는 객체가 사라","searchableText":"java string java ```java string a = ‘one’; string b = ‘one’; a == b; // true string c = ‘on’; string d = c + ‘e’; // string d = (c + ‘e’).intern(); a == d // false string e = ‘on’ + ‘e’ a == e // true ```  - string a = “”로 생성하는건 string pool을 할당하는거고 내부적으로 intern()이라는 코드를 통해 상수풀에 값을 올립니다. 이미 존재하는 값이라면 값을 주소를 리턴하는 것을 보장합니다. - “hello” + “world”와 같은 동작도 string pool을 할당받은 동작을 하는 것이기 때문에 a==e 는 true 입니다. - “문자열” + 객체를 생성할경우 새로운 주소값을 생성하는거지만 intern() 키워드를 붙여 (“문자열 + 객체).intern() 일경우 상수풀에 올라가는거고 해당 상수풀에는 나중에 참조하는 객체가 사라"},{"slug":"/frontend/마진-병합","frontmatter":{"title":"마진 병합","date":"2020-02-04T09:02:07.000Z","category":"frontend","draft":false},"excerpt":"## 마진병합현상의 조건  - 인접해있는 Block요소끼리만 일어납니다. - 상하단만 해당 됩니다. - 레이아웃을 더 보기 좋게 하기 위한 좋은 기능이다. - 하지만 원하는 바와 다르게 적용 될 수도 있다.  ## 마진병합을 방지하는 방법  - 부모에 margin이 0 auto여서 wrapper와 자식의 마진이 사라졌을 경우 - 부모에 padding: 1px을 줍니다. - 부모에 border: 1px solid transperent;를 줍니다. - display: inline-block;로 바꿉니다. Block 요소가 아니기 때문에 마진병합이 사라집니다. 하지만 자식간의 상하단 마진이 커집니다. 자식간의 마진 병합도 방지 되기 때문입니다. - 부모에 overflow: hidden; 속성을 줍니다(가장 좋은 해결책)","searchableText":"마진 병합 frontend ## 마진병합현상의 조건  - 인접해있는 block요소끼리만 일어납니다. - 상하단만 해당 됩니다. - 레이아웃을 더 보기 좋게 하기 위한 좋은 기능이다. - 하지만 원하는 바와 다르게 적용 될 수도 있다.  ## 마진병합을 방지하는 방법  - 부모에 margin이 0 auto여서 wrapper와 자식의 마진이 사라졌을 경우 - 부모에 padding: 1px을 줍니다. - 부모에 border: 1px solid transperent;를 줍니다. - display: inline-block;로 바꿉니다. block 요소가 아니기 때문에 마진병합이 사라집니다. 하지만 자식간의 상하단 마진이 커집니다. 자식간의 마진 병합도 방지 되기 때문입니다. - 부모에 overflow: hidden; 속성을 줍니다(가장 좋은 해결책)"},{"slug":"/javascript/javascript-class","frontmatter":{"title":"JavaScript Class","date":"2020-02-03T12:03:29.000Z","category":"javascript","draft":false},"excerpt":"- ES2015(ES6)에서 자바스크립트에 클래스(Class)가 도입되었습니다. - 자바스크립트는 기본적으로 프로토타입 기반의 언어입니다.  - 프로토타입 기반으로 객체 지향적으로 설계하는 것이 복잡하여 클래스라는 sugar syntax 문법이 도입된 것입니다.   - Java에서의 클래스와 똑같은 기능을 한다고 생각 할 수 있지만 여전히 객체 지향을 흉내내고 있고 그 내부는 여전히 프로토타입으로 구성되어 있는 것입니다.   - 하지만 이전 ES5와는 전혀 다르게 구현되어 있기 때문에 마냥 'sugar syntax로 되어 있다' 혹은 프로토타입으로 모든 것이 구현되어 있다고 보는 것 또한 옳지 않습니다. - 클래스는 선언문 또는 표현식으로 선언할 수 있습니다. - 클래스의 선언부는 let과 const와 마찬가지로 호이스팅은 되지만 temporary dead zone이 형성됩니다. - 클래스의 코드는 ‘use strict’를 선언하지 않아도 strict 모드에서 실행됩니다. - 자바","searchableText":"javascript class javascript - es2015(es6)에서 자바스크립트에 클래스(class)가 도입되었습니다. - 자바스크립트는 기본적으로 프로토타입 기반의 언어입니다.  - 프로토타입 기반으로 객체 지향적으로 설계하는 것이 복잡하여 클래스라는 sugar syntax 문법이 도입된 것입니다.   - java에서의 클래스와 똑같은 기능을 한다고 생각 할 수 있지만 여전히 객체 지향을 흉내내고 있고 그 내부는 여전히 프로토타입으로 구성되어 있는 것입니다.   - 하지만 이전 es5와는 전혀 다르게 구현되어 있기 때문에 마냥 'sugar syntax로 되어 있다' 혹은 프로토타입으로 모든 것이 구현되어 있다고 보는 것 또한 옳지 않습니다. - 클래스는 선언문 또는 표현식으로 선언할 수 있습니다. - 클래스의 선언부는 let과 const와 마찬가지로 호이스팅은 되지만 temporary dead zone이 형성됩니다. - 클래스의 코드는 ‘use strict’를 선언하지 않아도 strict 모드에서 실행됩니다. - 자바"},{"slug":"/react/react-hook","frontmatter":{"title":"React Hook","date":"2020-02-02T23:02:54.000Z","category":"react","draft":false},"excerpt":"## Hook가 React 버전 16.8에 새로 추가되었습니다.  - Hook를 이용하여 Class를 작성할 필요 없이 상태 값과 여러 React의 기능을 사용할 수 있습니다. - 하지만 React에서 Class를 제거할 계획은 없습니다. - Hook은 알고 있는 React 컨셉을 대체하지 않습니다. 대신에, Hook는 props, state, context, refs, 그리고 lifecycle와 같은 React 개념에 좀 더 직관적인 API를 제공합니다. 또한 Hook는 이 개념들을 엮기 위해 새로운 강력한 방법을 제공합니다.  ### [기본 Hook](https://ko.reactjs.org/docs/hooks-reference.html#basic-hooks)  - [useState](https://ko.reactjs.org/docs/hooks-reference.html#usestate) - [useEffect](https://ko.reactjs.org/docs/hooks-re","searchableText":"react hook react ## hook가 react 버전 16.8에 새로 추가되었습니다.  - hook를 이용하여 class를 작성할 필요 없이 상태 값과 여러 react의 기능을 사용할 수 있습니다. - 하지만 react에서 class를 제거할 계획은 없습니다. - hook은 알고 있는 react 컨셉을 대체하지 않습니다. 대신에, hook는 props, state, context, refs, 그리고 lifecycle와 같은 react 개념에 좀 더 직관적인 api를 제공합니다. 또한 hook는 이 개념들을 엮기 위해 새로운 강력한 방법을 제공합니다.  ### [기본 hook](https://ko.reactjs.org/docs/hooks-reference.html#basic-hooks)  - [usestate](https://ko.reactjs.org/docs/hooks-reference.html#usestate) - [useeffect](https://ko.reactjs.org/docs/hooks-re"},{"slug":"/typescript/TypeScript 버전에 따른 변경점","frontmatter":{"title":"TypeScript 버전에 따른 변경점","date":"2020-02-01T13:03:30.000Z","category":"typescript","tags":["typesciprt","version"],"draft":false},"excerpt":"## 3.0  - 새로운 개념의 프로젝트 참조가 도입되었습니다. 프로젝트 참조를 통해 TypeScript 프로젝트는 다른 TypeScript 프로젝트에 의존 할 수 tsconfig.json있습니다. 특히 파일이 다른 tsconfig.json파일 을 참조 할 수 있습니다. 이러한 종속성을 지정하면 TypeScript가 빌드 순서 및 출력 구조를 이해할 수 있는 방법을 제공하므로 코드를 더 작은 프로젝트로 쉽게 분할 할 수 있습니다. - — build 프로젝트 참조와 함께 작동하여 더 빠른 TypeScript 빌드를 가능하게 하는 플래그인 tsc에 대한 새로운 모드가 도입되었습니다. - 여러 새로운 기능에 대한 지원을 추가하여 튜플 유형으로 함수 매개 변수 목록과 상호 작용합니다. - 튜플 유형의 나머지 매개 변수를 이산 매개 변수로 확장합니다. - 튜플 형식의 스프레드 식을 이산 형 인수로 확장 - 일반 휴식 매개 변수 및 해당 튜플 유형의 추론. - 튜플 유형의 선택적 요소 - 튜","searchableText":"typescript 버전에 따른 변경점 typescript typesciprt version ## 3.0  - 새로운 개념의 프로젝트 참조가 도입되었습니다. 프로젝트 참조를 통해 typescript 프로젝트는 다른 typescript 프로젝트에 의존 할 수 tsconfig.json있습니다. 특히 파일이 다른 tsconfig.json파일 을 참조 할 수 있습니다. 이러한 종속성을 지정하면 typescript가 빌드 순서 및 출력 구조를 이해할 수 있는 방법을 제공하므로 코드를 더 작은 프로젝트로 쉽게 분할 할 수 있습니다. - — build 프로젝트 참조와 함께 작동하여 더 빠른 typescript 빌드를 가능하게 하는 플래그인 tsc에 대한 새로운 모드가 도입되었습니다. - 여러 새로운 기능에 대한 지원을 추가하여 튜플 유형으로 함수 매개 변수 목록과 상호 작용합니다. - 튜플 유형의 나머지 매개 변수를 이산 매개 변수로 확장합니다. - 튜플 형식의 스프레드 식을 이산 형 인수로 확장 - 일반 휴식 매개 변수 및 해당 튜플 유형의 추론. - 튜플 유형의 선택적 요소 - 튜"},{"slug":"/typescript/typescript-헬터-타입","frontmatter":{"title":"typescript 헬터 타입","date":"2020-01-27T16:02:01.000Z","category":"typescript","draft":false},"excerpt":"## 유니온(Union)타입  - 유니온 타입은 하나의 프로퍼티에 다양한 변수가 올 수 있는 타입을 말합니다.  ```typescript let args: number | string; let arg: 'a' | 'b' | 'c'; ```  ## keyof 키워드  - keyof 키워드는 타입 값에 존재하는 모든 프로퍼티의 키값을 union 형태로 리턴 받습니다.  ```typescript interface Todo { \tid: number; \ttext: string; \tdue: Date; }  // TodoKeys의 타입 = \"id\" | \"text\" | \"due\" type TodoKeys = keyof Todo; ````  ## never 타입  - never는 에러가 발생했을 때 프로세스를 중단시키지 않고 무시하는 타입입니다. - any를 제외한 다른 모든 타입의 원시 타입으로 사용 가능합니다. - 타입이기는 하지만 실제 never 타입으로 변수를 선언할 수 없고 주로 함수의","searchableText":"typescript 헬터 타입 typescript ## 유니온(union)타입  - 유니온 타입은 하나의 프로퍼티에 다양한 변수가 올 수 있는 타입을 말합니다.  ```typescript let args: number | string; let arg: 'a' | 'b' | 'c'; ```  ## keyof 키워드  - keyof 키워드는 타입 값에 존재하는 모든 프로퍼티의 키값을 union 형태로 리턴 받습니다.  ```typescript interface todo { \tid: number; \ttext: string; \tdue: date; }  // todokeys의 타입 = \"id\" | \"text\" | \"due\" type todokeys = keyof todo; ````  ## never 타입  - never는 에러가 발생했을 때 프로세스를 중단시키지 않고 무시하는 타입입니다. - any를 제외한 다른 모든 타입의 원시 타입으로 사용 가능합니다. - 타입이기는 하지만 실제 never 타입으로 변수를 선언할 수 없고 주로 함수의"},{"slug":"/javascript/javascript에서-클래스를-구현하는-방법,-상속하는-방법","frontmatter":{"title":"ECMA6 이전의 class 가 없을 시절의 JS에서 클래스를 구현하는 방법, 상속하는 방법 정리","date":"2020-01-27T14:01:06.000Z","category":"javascript","draft":false},"excerpt":"## prototype을 사용하여 class를 구현하는 방법입니다.  ```javascript function Animal() {   this.name = \"없어요\"; } Animal.prototype.getName = function() {   console.log(this.name); }; ```  ## 자바스크립트는 상속 또한 존재하지 않습니다. 하지만, 역시 마찬가지로 prototype을 사용하여 상속을 구현할 수 있습니다.  ```javascript function Animal() {   this.name = \"없어요\"; } Animal.prototype.getName = function() {   console.log(this.name); };  function Dog() {} Dog.prototype = new Animal();  var myDog = new Dog(); console.dir(myDog); ```  - 일반적으로 클래스를 만들면 자동으로 prototyp","searchableText":"ecma6 이전의 class 가 없을 시절의 js에서 클래스를 구현하는 방법, 상속하는 방법 정리 javascript ## prototype을 사용하여 class를 구현하는 방법입니다.  ```javascript function animal() {   this.name = \"없어요\"; } animal.prototype.getname = function() {   console.log(this.name); }; ```  ## 자바스크립트는 상속 또한 존재하지 않습니다. 하지만, 역시 마찬가지로 prototype을 사용하여 상속을 구현할 수 있습니다.  ```javascript function animal() {   this.name = \"없어요\"; } animal.prototype.getname = function() {   console.log(this.name); };  function dog() {} dog.prototype = new animal();  var mydog = new dog(); console.dir(mydog); ```  - 일반적으로 클래스를 만들면 자동으로 prototyp"},{"slug":"/frontend/height","frontmatter":{"title":"height","date":"2020-01-26T14:01:28.000Z","category":"frontend","draft":false},"excerpt":"## screen.height  - 화면의 세로 크기를 가져옵니다.  ## screen.availHeight  - 브라우저의 막대를 포함하여 최대화 된 경우 브라우저의 윈도우가 가질 수 있는 높이입니다. - 창이 최대화되면 screen.availHeight === window.outerHeight - 작업 표시줄이 차지하는 부분을 제외한 세로 크기를 가져옵니다. - 화면 아래의 작업 표시줄 높이가 30px이라면 screen.availHeight가 screen.height보다 30 작습니다. - 현재 화면에서 실제로 사용가능한 최대치의 높이를 반환합니다.  ## offsetHeight  - 문서에서 요소가 차지하는 높이입니다. - 스크롤바가 나타나는 부분까지의 길이입니다. - offsetHeight 속성은 여백이 아니라 패딩, 테두리 및 스크롤 막대를 포함하여 요소의 볼 수있는 높이를 픽셀 단위로 반환합니다. - 일반적으로 엘리먼트의 전체 크기를 알고 싶다면, `offsetWidth","searchableText":"height frontend ## screen.height  - 화면의 세로 크기를 가져옵니다.  ## screen.availheight  - 브라우저의 막대를 포함하여 최대화 된 경우 브라우저의 윈도우가 가질 수 있는 높이입니다. - 창이 최대화되면 screen.availheight === window.outerheight - 작업 표시줄이 차지하는 부분을 제외한 세로 크기를 가져옵니다. - 화면 아래의 작업 표시줄 높이가 30px이라면 screen.availheight가 screen.height보다 30 작습니다. - 현재 화면에서 실제로 사용가능한 최대치의 높이를 반환합니다.  ## offsetheight  - 문서에서 요소가 차지하는 높이입니다. - 스크롤바가 나타나는 부분까지의 길이입니다. - offsetheight 속성은 여백이 아니라 패딩, 테두리 및 스크롤 막대를 포함하여 요소의 볼 수있는 높이를 픽셀 단위로 반환합니다. - 일반적으로 엘리먼트의 전체 크기를 알고 싶다면, `offsetwidth"},{"slug":"/frontend/web-frontend","frontmatter":{"title":"WEB FRONTEND","date":"2020-01-24T23:01:46.000Z","category":"frontend","draft":false},"excerpt":"- HTML부터 React까지의 제가 알고 있는 웹 프론트엔드 흐름에 대해 정리를 해보고자 합니다. - 웹은 HTML, CSS, Javascript로 구성되어 있습니다. DART나 KOTLIN.JS, 웹어셈블리 등이 웹을 지원하기는 한다고 합니다.  ## HTML  - 가장 먼저 HTML은 HyperText Markup Language로 웹페이지를 기술하기 위한 마크업 언어입니다. - 웹페이지의 내용과 구조를 담당하는 언어로써 태그를 통해 정보를 구조화하는 것입니다. - 현재 사용 되고 있는 버전은 HTML5입니다.  ## CSS  - CSS는 Cascading Style Sheets로 HTML이나 XML과 같은 구조화 된 문서를 화면에 어떻게 렌더링할 것인지를 정의하기 위한 언어입니다. - HTML5 이전 버전의 HTML에는 style을 컨트롤할 수 있는 태그 font, center 등이 존재하여 CSS가 없이도 어느 정도의 스타일 표현이 가능했지만, 정보와 구조를 담당하는 HT","searchableText":"web frontend frontend - html부터 react까지의 제가 알고 있는 웹 프론트엔드 흐름에 대해 정리를 해보고자 합니다. - 웹은 html, css, javascript로 구성되어 있습니다. dart나 kotlin.js, 웹어셈블리 등이 웹을 지원하기는 한다고 합니다.  ## html  - 가장 먼저 html은 hypertext markup language로 웹페이지를 기술하기 위한 마크업 언어입니다. - 웹페이지의 내용과 구조를 담당하는 언어로써 태그를 통해 정보를 구조화하는 것입니다. - 현재 사용 되고 있는 버전은 html5입니다.  ## css  - css는 cascading style sheets로 html이나 xml과 같은 구조화 된 문서를 화면에 어떻게 렌더링할 것인지를 정의하기 위한 언어입니다. - html5 이전 버전의 html에는 style을 컨트롤할 수 있는 태그 font, center 등이 존재하여 css가 없이도 어느 정도의 스타일 표현이 가능했지만, 정보와 구조를 담당하는 ht"},{"slug":"/javascript/doublylinkedlist","frontmatter":{"title":"doublyLinkedList","date":"2020-01-24T23:01:14.000Z","category":"javascript","draft":false},"excerpt":"- 자바스크립트로 doublyLinkedList 구현하기  ```javascript function Node(data) { \tthis.data = data; \tthis.next = null; }  class DoublyLinkedList { \t// 첫번째 노드를 가리키는 필드 \thead; \ttail; \tsize = 0; \t// 노드의 내용을 쉽게 출력해서 확인해볼 수 있는 기능 \taddFirst(input) { \t\t// 노드를 생성합니다. \t\tconst temp = new Node(input); \t\t// 새로운 노드의 다음 노드로 해드를 지정합니다. \t\ttemp.next = this.head; \t\t// 기존에 노드가 있었다면 현재 헤드의 이전 노드로 새로운 노드를 지정합니다. \t\tif (this.head != null) this.head.prev = temp; \t\t// 헤드로 새로운 노드를 지정합니다. \t\tthis.head = temp; \t\tthis.size++; \t\tif (thi","searchableText":"doublylinkedlist javascript - 자바스크립트로 doublylinkedlist 구현하기  ```javascript function node(data) { \tthis.data = data; \tthis.next = null; }  class doublylinkedlist { \t// 첫번째 노드를 가리키는 필드 \thead; \ttail; \tsize = 0; \t// 노드의 내용을 쉽게 출력해서 확인해볼 수 있는 기능 \taddfirst(input) { \t\t// 노드를 생성합니다. \t\tconst temp = new node(input); \t\t// 새로운 노드의 다음 노드로 해드를 지정합니다. \t\ttemp.next = this.head; \t\t// 기존에 노드가 있었다면 현재 헤드의 이전 노드로 새로운 노드를 지정합니다. \t\tif (this.head != null) this.head.prev = temp; \t\t// 헤드로 새로운 노드를 지정합니다. \t\tthis.head = temp; \t\tthis.size++; \t\tif (thi"},{"slug":"/javascript/linkedlist","frontmatter":{"title":"linkedList","date":"2020-01-24T22:02:31.000Z","category":"javascript","draft":false},"excerpt":"- 자바스크립트로 linkedList 구현하기  ```javascript function Node(data) { \tthis.data = data; \tthis.next = null; }  class LinkedList { \t// 첫번째 노드를 가리키는 필드 \thead; \ttail; \tsize = 0; \tNode(data) { \t\tthis.data = data; \t\tthis.next = null; \t} \taddFirst(input) { \t\t// 노드를 생성합니다. \t\tconst temp = new Node(input); \t\t// 새로운 노드의 다음 노드로 해드를 지정합니다. \t\ttemp.next = this.head; \t\t// 헤드로 새로운 노드를 지정합니다. \t\tthis.head = temp; \t\tthis.size++; \t\tif (this.head.next == null) { \t\t\tthis.tail = this.head; \t\t} \t} \taddLast(input) { \t\t// 노드를","searchableText":"linkedlist javascript - 자바스크립트로 linkedlist 구현하기  ```javascript function node(data) { \tthis.data = data; \tthis.next = null; }  class linkedlist { \t// 첫번째 노드를 가리키는 필드 \thead; \ttail; \tsize = 0; \tnode(data) { \t\tthis.data = data; \t\tthis.next = null; \t} \taddfirst(input) { \t\t// 노드를 생성합니다. \t\tconst temp = new node(input); \t\t// 새로운 노드의 다음 노드로 해드를 지정합니다. \t\ttemp.next = this.head; \t\t// 헤드로 새로운 노드를 지정합니다. \t\tthis.head = temp; \t\tthis.size++; \t\tif (this.head.next == null) { \t\t\tthis.tail = this.head; \t\t} \t} \taddlast(input) { \t\t// 노드를"},{"slug":"/javascript/arraylist","frontmatter":{"title":"arrayList","date":"2020-01-24T20:01:42.000Z","category":"javascript","draft":false},"excerpt":"- 자바스크립트로 arrayList 구현하기  ```javascript class ArrayList { \tsize = 0; \telementData = new Array(100); \tconstructor() {}  \tadd(element) { \t\tthis.elementData[this.size++] = element; \t\treturn true; \t} \taddIndex(index, element) { \t\tfor (let i = this.size - 1; i >= index; i--) { \t\t\tthis.elementData[i + 1] = this.elementData[i]; \t\t} \t\tthis.elementData[index] = element; \t\tthis.size++; \t\treturn true; \t} \tremove(index) { \t\tconst removed = this.elementData[index]; \t\tfor (let i = index + 1; i <= this.size -","searchableText":"arraylist javascript - 자바스크립트로 arraylist 구현하기  ```javascript class arraylist { \tsize = 0; \telementdata = new array(100); \tconstructor() {}  \tadd(element) { \t\tthis.elementdata[this.size++] = element; \t\treturn true; \t} \taddindex(index, element) { \t\tfor (let i = this.size - 1; i >= index; i--) { \t\t\tthis.elementdata[i + 1] = this.elementdata[i]; \t\t} \t\tthis.elementdata[index] = element; \t\tthis.size++; \t\treturn true; \t} \tremove(index) { \t\tconst removed = this.elementdata[index]; \t\tfor (let i = index + 1; i <= this.size -"},{"slug":"/javascript/javascript-패키지-매니저(NPM)","frontmatter":{"title":"javascript 패키지 매니저(NPM)","date":"2020-01-22T09:01:15.000Z","category":"javascript","tag":["javascript","npm","yarn"],"draft":false},"excerpt":"## npm이란?  - npm은 Node Package Manager의 약자이며 대부분의 JavaScript 프로그램은 npm에 패키지로 등록됩니다. - java에 gradle , php의 composer, python의 pip와 같은 역할을 합니다. - npm의 대안으로는 facebook의 yarn이 있습니다. - node.js를 설치하면 내장(built in)되어 있습니다. - npm -v를 통해 버전을 확인할 수 있습니다. - npm install 명령으로 외부 모듈 패키지를 설치합니다. - npm install에서 -g 옵션을 통해 글로벌로 설치할 수 있습니다.   - 글로벌 설치는 권장 되지 않으면 npx를 통해 글로벌로 설치하지 않고 사용하는 방법도 있습니다. npx의 경우 프로젝트 내의 패키지 설치 여부를 확인하고 없으면 글로벌 내의 패키지 여부를 확인하고 없으면 다운로드 받은 후 설치 되고 나서 사라집니다. - npm으로 패키지 설치가 완료된 경우 [프로젝트경로]\\[","searchableText":"javascript 패키지 매니저(npm) javascript ## npm이란?  - npm은 node package manager의 약자이며 대부분의 javascript 프로그램은 npm에 패키지로 등록됩니다. - java에 gradle , php의 composer, python의 pip와 같은 역할을 합니다. - npm의 대안으로는 facebook의 yarn이 있습니다. - node.js를 설치하면 내장(built in)되어 있습니다. - npm -v를 통해 버전을 확인할 수 있습니다. - npm install 명령으로 외부 모듈 패키지를 설치합니다. - npm install에서 -g 옵션을 통해 글로벌로 설치할 수 있습니다.   - 글로벌 설치는 권장 되지 않으면 npx를 통해 글로벌로 설치하지 않고 사용하는 방법도 있습니다. npx의 경우 프로젝트 내의 패키지 설치 여부를 확인하고 없으면 글로벌 내의 패키지 여부를 확인하고 없으면 다운로드 받은 후 설치 되고 나서 사라집니다. - npm으로 패키지 설치가 완료된 경우 [프로젝트경로]\\["},{"slug":"/react/퍼센트-원-그리기","frontmatter":{"title":"퍼센트 원 그리기","date":"2020-01-19T13:01:42.000Z","category":"react","draft":false},"excerpt":"- react와 styled-components를 이용해서 퍼센트에 따라 원을 그리는 컴포넌트를 만들었습니다.  ```javascript import React from 'react'; import styled from 'styled-components';  const GRAY = '#eeeeee'; const BLUE = '#058ef3';  const StyledIndex = styled.div` \tdisplay: flex; \twidth: 100vw; \theight: 100vh; \tjustify-content: center; \talign-items: center; \t.circle { \t\twidth: 320px; \t\theight: 320px; \t\tborder-radius: 50%; \t\tdisplay: flex; \t\tjustify-content: center; \t\talign-items: center; \t\tbackground-color: ${BLUE}; \t\tbackground-ima","searchableText":"퍼센트 원 그리기 react - react와 styled-components를 이용해서 퍼센트에 따라 원을 그리는 컴포넌트를 만들었습니다.  ```javascript import react from 'react'; import styled from 'styled-components';  const gray = '#eeeeee'; const blue = '#058ef3';  const styledindex = styled.div` \tdisplay: flex; \twidth: 100vw; \theight: 100vh; \tjustify-content: center; \talign-items: center; \t.circle { \t\twidth: 320px; \t\theight: 320px; \t\tborder-radius: 50%; \t\tdisplay: flex; \t\tjustify-content: center; \t\talign-items: center; \t\tbackground-color: ${blue}; \t\tbackground-ima"},{"slug":"/react/리액트에서-key를-사용하는-이유","frontmatter":{"title":"리액트에서 key를 사용하는 이유","date":"2020-01-18T17:01:14.000Z","category":"react","draft":false},"excerpt":"- 리액트는 배열을 렌더링 할 때 값을 통하여 업데이트 성능을 최적화 합니다. - 기본적으로 DOM 노드의 자식에 대해 반복 할 때 React는 두 자식 목록을 동시에 반복하고 차이가 있을 때마다 돌연변이를 생성합니다.(virtual dom diff를 써서 확인) - 이 문제를 해결하기 위해 React는 key속성을 지원 합니다. 자식에 키가 있으면 React는이 키를 사용하여 원래 트리의 자식을 후속 트리의 자식과 일치 시킵니다.  ## 키를 사용할 때 주의할 점  - 색인(index)을 키로 사용하면 재정렬로 인해 구성 요소 상태에 문제가 발생할 수도 있습니다. 구성 요소 인스턴스는 해당 키를 기반으로 업데이트 및 재사용됩니다. 키가 색인인 경우 항목을 이동하면 변경됩니다. 결과적으로 제어되지 않은 입력과 같은 구성 요소 상태가 예기치 않게 혼합되고 업데이트 될 수 있습니다. - 그렇기 때문에 key 값은 언제나 고유해야 합니다. - 키를 선택하는 가장 좋은 방법은 형제 중에서","searchableText":"리액트에서 key를 사용하는 이유 react - 리액트는 배열을 렌더링 할 때 값을 통하여 업데이트 성능을 최적화 합니다. - 기본적으로 dom 노드의 자식에 대해 반복 할 때 react는 두 자식 목록을 동시에 반복하고 차이가 있을 때마다 돌연변이를 생성합니다.(virtual dom diff를 써서 확인) - 이 문제를 해결하기 위해 react는 key속성을 지원 합니다. 자식에 키가 있으면 react는이 키를 사용하여 원래 트리의 자식을 후속 트리의 자식과 일치 시킵니다.  ## 키를 사용할 때 주의할 점  - 색인(index)을 키로 사용하면 재정렬로 인해 구성 요소 상태에 문제가 발생할 수도 있습니다. 구성 요소 인스턴스는 해당 키를 기반으로 업데이트 및 재사용됩니다. 키가 색인인 경우 항목을 이동하면 변경됩니다. 결과적으로 제어되지 않은 입력과 같은 구성 요소 상태가 예기치 않게 혼합되고 업데이트 될 수 있습니다. - 그렇기 때문에 key 값은 언제나 고유해야 합니다. - 키를 선택하는 가장 좋은 방법은 형제 중에서"},{"slug":"/frontend/v8-엔진의-동작-원리","frontmatter":{"title":"V8 엔진의 동작 원리","date":"2020-01-14T20:02:39.000Z","category":"frontend","draft":false},"excerpt":"## V8이란?  - 독일 구글 개발 센터에서 만들어진 JavaScript 엔진입니다. - 웹 브라우저 안에서 실행되는 JavaScript의 성능을 높이기 위해 처음 고안되었습니다. - 오픈 소스이고 C++로 작성되었습니다. - 구글 크롬과 Node.js의 런타임에서 사용 중입니다. - 속도를 높이기 위해서 V8은 인터프리터를 이용하는 대신 기계어 코드로 번역합니다.    > JIT(Just-In-Time) 컴파일러를 적용하여 JavaScript 코드를 실행할 때 컴파일하여 기계어 코드로 만듭니다.    > 다른 엔진과의 가장 큰 차이는 바이트코드 또는 다른 중간 코드를 생성하지 않습니다.  ## 컴파일러  - 5.9 버전이 출시 되기 전에는 V8에서 두 개의 엔진을 사용했습니다. - 풀코드젠: 간단하고 매우 빠른 컴파일러로서 단순하고 상대적으로 느린 머신 코드를 생산합니다. - 크랭크샤프트: 좀 더 복잡한 최적화 컴파일러로서 고도로 최적화된 코드를 생산합니다.    > 자바스크립","searchableText":"v8 엔진의 동작 원리 frontend ## v8이란?  - 독일 구글 개발 센터에서 만들어진 javascript 엔진입니다. - 웹 브라우저 안에서 실행되는 javascript의 성능을 높이기 위해 처음 고안되었습니다. - 오픈 소스이고 c++로 작성되었습니다. - 구글 크롬과 node.js의 런타임에서 사용 중입니다. - 속도를 높이기 위해서 v8은 인터프리터를 이용하는 대신 기계어 코드로 번역합니다.    > jit(just-in-time) 컴파일러를 적용하여 javascript 코드를 실행할 때 컴파일하여 기계어 코드로 만듭니다.    > 다른 엔진과의 가장 큰 차이는 바이트코드 또는 다른 중간 코드를 생성하지 않습니다.  ## 컴파일러  - 5.9 버전이 출시 되기 전에는 v8에서 두 개의 엔진을 사용했습니다. - 풀코드젠: 간단하고 매우 빠른 컴파일러로서 단순하고 상대적으로 느린 머신 코드를 생산합니다. - 크랭크샤프트: 좀 더 복잡한 최적화 컴파일러로서 고도로 최적화된 코드를 생산합니다.    > 자바스크립"},{"slug":"/frontend/라이브러리-없이-애니메이션-구현하는-방법","frontmatter":{"title":"라이브러리 없이 애니메이션 구현하는 방법","date":"2020-01-14T20:01:35.000Z","category":"frontend","draft":false},"excerpt":"가장 먼저 CSS transition 속성을 이용해서 아코디언 애니메이션을 구현했습니다.  ```html <!DOCTYPE html> <html lang=\"en\"> \t<head> \t\t<meta charset=\"UTF-8\" /> \t\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /> \t\t<meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /> \t\t<title>Document</title> \t\t<style> \t\t\t.box { \t\t\t\theight: 0; \t\t\t\toverflow: hidden; \t\t\t\ttransition: all 0.3s ease-out; \t\t\t} \t\t</style> \t</head> \t<body> \t\t<button class=\"button\" type=\"button\">클릭</button> \t\t<div class=\"box\"> \t\t\t내용을 만들어 봅시다.<b","searchableText":"라이브러리 없이 애니메이션 구현하는 방법 frontend 가장 먼저 css transition 속성을 이용해서 아코디언 애니메이션을 구현했습니다.  ```html <!doctype html> <html lang=\"en\"> \t<head> \t\t<meta charset=\"utf-8\" /> \t\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /> \t\t<meta http-equiv=\"x-ua-compatible\" content=\"ie=edge\" /> \t\t<title>document</title> \t\t<style> \t\t\t.box { \t\t\t\theight: 0; \t\t\t\toverflow: hidden; \t\t\t\ttransition: all 0.3s ease-out; \t\t\t} \t\t</style> \t</head> \t<body> \t\t<button class=\"button\" type=\"button\">클릭</button> \t\t<div class=\"box\"> \t\t\t내용을 만들어 봅시다.<b"}]}]
7:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"Yuni-Q Blog"}],["$","meta","3",{"name":"description","content":"Personal blog"}]]
1:null
