{"componentChunkName":"component---src-templates-blog-post-js","path":"/javascript/promise/","result":{"data":{"site":{"siteMetadata":{"title":"yuni-q 블로그","author":"yuni-q","siteUrl":"https://yuni-q.github.io","comment":{"disqusShortName":"yuni-q","utterances":"yuni_q"},"sponsor":{"buyMeACoffeeId":"yuniq"}}},"markdownRemark":{"id":"a2550e47-4d40-5724-a08b-fd125e954a00","excerpt":"Promise 이해하기 프로미스는 말 그대로 약속 입니다. Promise는 3가지 상태를 가집니다. Pending(미결) Fulfilled(이행) Rejected(거절) Promise는 비동기(Asynchronous)다. ES5, ES6/2015, ES7에서의 Promise ES5 - 주류 브라우저들 Bluebird Promise 라이브러리만 설치했다면, ES5 환경(모든 주류 브라우저 + 노드JS 환경을 말합니다.)에서 돌아갑니다. ES5는 자체적으로는 Promise…","html":"<h2 id=\"promise-이해하기\" style=\"position:relative;\"><a href=\"#promise-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0\" aria-label=\"promise 이해하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Promise 이해하기</h2>\n<ul>\n<li>\n<p>프로미스는 말 그대로 약속 입니다. Promise는 3가지 상태를 가집니다.</p>\n<ul>\n<li>Pending(미결)</li>\n<li>Fulfilled(이행)</li>\n<li>Rejected(거절)</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"promise는-비동기asynchronous다\" style=\"position:relative;\"><a href=\"#promise%EB%8A%94-%EB%B9%84%EB%8F%99%EA%B8%B0asynchronous%EB%8B%A4\" aria-label=\"promise는 비동기asynchronous다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Promise는 비동기(Asynchronous)다.</h2>\n<h2 id=\"es5-es62015-es7에서의-promise\" style=\"position:relative;\"><a href=\"#es5-es62015-es7%EC%97%90%EC%84%9C%EC%9D%98-promise\" aria-label=\"es5 es62015 es7에서의 promise permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ES5, ES6/2015, ES7에서의 Promise</h2>\n<h3 id=\"es5---주류-브라우저들\" style=\"position:relative;\"><a href=\"#es5---%EC%A3%BC%EB%A5%98-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EB%93%A4\" aria-label=\"es5   주류 브라우저들 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ES5 - 주류 브라우저들</h3>\n<ul>\n<li>Bluebird Promise 라이브러리만 설치했다면, ES5 환경(모든 주류 브라우저 + 노드JS 환경을 말합니다.)에서 돌아갑니다. ES5는 자체적으로는 Promise를 지원하지 않습니다. Bluebird외에도 다른 유명한 Promise 라이브러리인 Q가 있습니다.</li>\n</ul>\n<h3 id=\"es6--es2015---현대-브라우저들과-nodejs-v6\" style=\"position:relative;\"><a href=\"#es6--es2015---%ED%98%84%EB%8C%80-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EB%93%A4%EA%B3%BC-nodejs-v6\" aria-label=\"es6  es2015   현대 브라우저들과 nodejs v6 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ES6 / ES2015 - 현대 브라우저들과 NodeJs v6</h3>\n<ul>\n<li>라이브러리 없이도 작동합니다. 왜냐하면 ES6는 Promise를 네이티브하게 지원하기 때문입니다. 추가로 ES6 함수들과 함께라면, 화살표 함수를 이용하여 코드를 훨씬 더 간단히 만들 수 있습니다. 그리고 const나 let과 같은 선언문으로 변수 선언도 가능합니다.</li>\n</ul>\n<h3 id=\"es7---async-await이-문법을-더-예쁘게-만들어줍니다\" style=\"position:relative;\"><a href=\"#es7---async-await%EC%9D%B4-%EB%AC%B8%EB%B2%95%EC%9D%84-%EB%8D%94-%EC%98%88%EC%81%98%EA%B2%8C-%EB%A7%8C%EB%93%A4%EC%96%B4%EC%A4%8D%EB%8B%88%EB%8B%A4\" aria-label=\"es7   async await이 문법을 더 예쁘게 만들어줍니다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ES7 - Async Await이 문법을 더 예쁘게 만들어줍니다.</h3>\n<ul>\n<li>ES7은 async와 await 문법을 도입했습니다. 두가지 문법은 비동기 문법을 더 예쁘고 이해하기 쉽게 만들어줍니다. 심지어 .then과 .catch도 필요 없습니다.</li>\n</ul>\n<h2 id=\"왜-promise이고-언제-써야-할까요\" style=\"position:relative;\"><a href=\"#%EC%99%9C-promise%EC%9D%B4%EA%B3%A0-%EC%96%B8%EC%A0%9C-%EC%8D%A8%EC%95%BC-%ED%95%A0%EA%B9%8C%EC%9A%94\" aria-label=\"왜 promise이고 언제 써야 할까요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 Promise이고 언제 써야 할까요?</h2>\n<h3 id=\"일반-함수-vs-비동기-함수\" style=\"position:relative;\"><a href=\"#%EC%9D%BC%EB%B0%98-%ED%95%A8%EC%88%98-vs-%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%95%A8%EC%88%98\" aria-label=\"일반 함수 vs 비동기 함수 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>일반 함수 vs 비동기 함수</h3>\n<ul>\n<li>여러분이 만일 일반 함수로 두 숫자를 더한다면, 결과를 즉시 볼 수 있을 것입니다. 하지만, 여러분이 원격 서버를 이용하여 두 숫자 더하기에 대한 결과 값을 구한다면, 여러분은 기다려야 합니다. 즉시 값을 얻진 못합니다.</li>\n<li>여러분은 서버가 다운되거나 응답 지연 때문에 값을 얻을 수 있을지 없을지도 모릅니다. 여러분은 서버가 값을 반환할 때까지 모든 프로세스를 잠시 멈춰두길 원하진 않을 것입니다. 그래서 비동기가 필요합니다.</li>\n<li>API를 호추하는 일, 파일을 다운로드하는 일, 파일을 읽는 일 등은 주로 비동기 함수를 사용하여 코딩합니다.</li>\n</ul>\n<h3 id=\"promise가-있기-전에-코딩하던-방법--callback\" style=\"position:relative;\"><a href=\"#promise%EA%B0%80-%EC%9E%88%EA%B8%B0-%EC%A0%84%EC%97%90-%EC%BD%94%EB%94%A9%ED%95%98%EB%8D%98-%EB%B0%A9%EB%B2%95--callback\" aria-label=\"promise가 있기 전에 코딩하던 방법  callback permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Promise가 있기 전에 코딩하던 방법 : Callback</h3>\n<ul>\n<li>Promise 전에 우리는 callback을 사용했습니다. Callback은 여러분이 결과 값을 받으면 수행할 함수입니다.</li>\n<li>문법은 그럭저럭 괜찮아보입니다. 하지만 만일 여러분이 연속되는 비동기 액션을 수행하려면 문제가 발생 합니다. 문법이 사용자에게 친화적이지 못합니다. 좋은 말로는, 피라미드처럼 보인다고 합니다. 하지만 사람들은 주로 이렇게 된 코드를 “콜백 지옥”이라고 합니다. 왜냐하면 콜백이 다른 콜백 안에 계속 중첩되어 있기 때문입니다. 여러분이 10개의 콜백을 가지고 있다고 가정하면, 10번 중첩을 시켜야 합니다.</li>\n<li>Promise와 .then을 사용하여, 우리는 피라미드 모양의 콜백을 빳빳히 펴낼(Flatten) 수 있습니다. 중첩된 부분이 없어서 훨씬 보기 좋습니다. 물론, ES7의 async 문법을 사용하면, 우리는 예제를 더 더 깔끔히 작성할 수 있습니다.</li>\n</ul>\n<h2 id=\"새로운-친구--observable\" style=\"position:relative;\"><a href=\"#%EC%83%88%EB%A1%9C%EC%9A%B4-%EC%B9%9C%EA%B5%AC--observable\" aria-label=\"새로운 친구  observable permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>새로운 친구 : Observable</h2>\n<ul>\n<li>Observable은 0개 혹은 그 이상의 이벤트를 내보내는 lazy event stream입니다. 그리고 Observable을 끝낼 수도 있고 안 끝낼 수도 있습니다.</li>\n</ul>\n<h2 id=\"참조\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EC%A1%B0\" aria-label=\"참조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참조</h2>\n<ul>\n<li><a href=\"https://velog.io/@jakeseo_me/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%9D%BC%EB%A9%B4-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%A0-33%EA%B0%80%EC%A7%80-%EA%B0%9C%EB%85%90-25-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%B0%94%EB%B3%B4%EB%A5%BC-%EC%9C%84%ED%95%9C-Promise\">자바스크립트 개발자라면 알아야 할 33가지 개념 #25 자바스크립트 : 바보를 위한 Promise</a></li>\n</ul>","frontmatter":{"title":"Promise","date":"April 12, 2020"}}},"pageContext":{"slug":"/javascript/promise/","previous":{"fields":{"slug":"/javascript/iterator/"},"frontmatter":{"title":"Iterator","category":"javascript","draft":false}},"next":{"fields":{"slug":"/javascript/async-await/"},"frontmatter":{"title":"Async Await","category":"javascript","draft":false}}}}}