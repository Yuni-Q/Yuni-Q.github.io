{"componentChunkName":"component---src-pages-index-js","path":"/","result":{"data":{"site":{"siteMetadata":{"title":"yuniq 블로그","configs":{"countOfInitialPost":10}}},"allMarkdownRemark":{"edges":[{"node":{"excerpt":"명령형과 선언형의 차이 명령형 프로그래밍 명령형 프로그래밍이란 프로그래밍의 상태와 상태를 변경시키는 구문의 관점에서 연산을 설명하는 방식입니다. 알고리즘을 명시하고 목표는 명시하지 않습니다. 프로그램은 명령의 수행입니다. 어떻게(how to)에 초점을 맞춥니다. 튜링 머신에 이론적 배경을 둡니다. 선언형 프로그래밍 선언형 프로그래밍은 어떤 방법으로 해야하…","fields":{"slug":"/programming paradigm/프로그래밍-패러다임/"},"frontmatter":{"date":"March 18, 2020","title":"프로그래밍 패러다임","category":"develop","draft":false}}},{"node":{"excerpt":"지은이의 글 객체지향으로 향하는 첫 걸음은 클래스가 아니라 객체를 바라보는 것에서부터 시작합니다. 객체지향으로 향하는 두 번째 걸음은 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 존재로 바라보는 것입니다. 세 번째 걸음을 내디딜 수 있는지 여부는 협력에 참여하는 객체들에게 얼마나 적절한 역할과 책임을 부여할 수 있느냐에 달려 있습…","fields":{"slug":"/object/object-intro/"},"frontmatter":{"date":"March 15, 2020","title":"object intro","category":"object","draft":false}}},{"node":{"excerpt":"intro 대부분 사람들은 이론이 먼저 정립된 후에 실무가 그 뒤를 따라 발전한다고 생각합니다. 로버트 L. 글래스는 그 반대라고 주장합니다. 글래스에 따르면 어떤 분야를 막론하고 이론을 정립할 수 없는 초기에는 실무가 먼저 급속한 발전을 이룬다고 합니다. 실무가 어느 정도 발전하고 난 다음에야 비로소 실무의 실용성을 입증할 수 있는 이론이 서서히 그 모…","fields":{"slug":"/object/object-chapter-01-객체,-설계/"},"frontmatter":{"date":"March 15, 2020","title":"object CHAPTER 01 객체, 설계","category":"object","draft":false}}},{"node":{"excerpt":"참조 [code-lab] CSS Gradient로 투명배경판 만들기 [CSS] linear-gradient를 활용하여 체스판 배경 만들기","fields":{"slug":"/frontend/css로-격자-만들기/"},"frontmatter":{"date":"March 13, 2020","title":"CSS로 격자 만들기","category":"frontend","draft":false}}},{"node":{"excerpt":"Intro 오류 처리는 프로그램에 반드시 필요한 요소 중 하나일 뿐입니다. 입력 이 이상하거나 디바이스가 실패할지도 모르기 때문입니다. 간단히 말해, 뭔가 잘못될 가능성은 늘 존재합니다. 뭔가 잘못되면 바로 잡을 책임은 바로 우리 프로그래머에게 있습니다. 깨끗한 코드와 오류 처리는 확실히 연관성이 있습니다. 상당수 코드 기반은 전적으로 오류 처리 코드에 …","fields":{"slug":"/clean code/clean-code-7장-오류-처리/"},"frontmatter":{"date":"March 10, 2020","title":"clean code 7장 오류 처리","category":"clean code","draft":false}}},{"node":{"excerpt":"Intro 변수를 비공개로 정의하는 이유가 있습니다. 남들이 변수에 의존하지 않게 만들고 싶어서 입니다. 충동이든 변덕이든, 변수 타입이나 구현을 맘대로 바꾸고 싶어합니다. 자료 추상화 변수 사이에 함수라는 계층을 넣는다고 구현이 저절로 감춰지지는 않습니다. 구현을 감추려면 추상화가 필요합니다. 그저 (형식 논리에 치우쳐) 조회 함수와 설정 함수로 변수를…","fields":{"slug":"/clean code/clean-code-6장-객체와-자료-구조/"},"frontmatter":{"date":"March 07, 2020","title":"clean code 6장 객체와 자료 구조","category":"clean code","draft":false}}},{"node":{"excerpt":"공변성 : 타입 T를 확장한 타입에 대해서 허용합니다. 보통 인자는 공변성을 가집니다. 무공변성 : 타입 T만 허용합니다. 반공변성: 타입 T의 상위(부모) 타입에 대해서 허용합니다. 보통 리턴 타입은 반공변성을 가집니다. 참조 공변성과 반공변성, 무공변성","fields":{"slug":"/develop/공변-반공변-무공변/"},"frontmatter":{"date":"March 06, 2020","title":"공변 반공변 무공변","category":"develop","draft":false}}},{"node":{"excerpt":"Intro 질서정연하고 깔끔하며, 일관적인 코드를 본다면 사람들에게 전문가가 짰다는 인상을 심어줄 수 있습니다. 반대로, 코드가 어수선해 보인다면 프로젝트 전반적으로 무성의한 태도로 작성했다고 생각합니다. 프로그래머라면 형식을 깔끔하게 맞춰 코드를 짜야 합니다. 코드 형식을 맞추기 위한 간단한 규칙을 정하고 그 규칙을 착실히 따라야 합니다. 팀으로 일한다…","fields":{"slug":"/clean code/clean-code-5장-형식-맞추기/"},"frontmatter":{"date":"March 06, 2020","title":"clean code 5장 형식 맞추기","category":"clean code","draft":false}}},{"node":{"excerpt":"나쁜 코드에 주석을 달지 말아야 합니다. 새로 짜는 것이 좋습니다. 주석은 필요악 입니다. 코드로 의도를 표현하지 못해, 실패를 만회하기 위해 쓰는 것입니다. 주석은 언제나 실패를 의미합니다. 주석 없이는 자신을 표현할 방법을 찾지 못해 할 수 없이 주석을 사용합니다. 그래서 주석은 반가울수 없습니다. 주석이 오래될수록 코드에서 멀어져서 거짓말을 하게 될…","fields":{"slug":"/clean code/clean-code-4장-주석/"},"frontmatter":{"date":"March 04, 2020","title":"clean code 4장 주석","category":"clean code","draft":false}}},{"node":{"excerpt":"의도를 분명히 밝힙니다. 변수의 존재 이유, 기능, 사용법 등이 변수/함수/클래스명에 드러나야 합니다. 따로 주석이 필요하지 않을 정도로 드러나야 합니다. 의미를 함축하거나 독자(코드를 읽는 사람)가 사전 지식을 가지고 있다고 가정하지 않습니다. 그릇된 정보를 피합니다. 중의적으로 해석될 수 있는 이름 피해야 합니다. 개발자에게는 특수한 의미를 가지는 단…","fields":{"slug":"/clean code/clean-code-2장-의미-있는-이름/"},"frontmatter":{"date":"March 03, 2020","title":"clean code 2장 의미 있는 이름","category":"clean code","draft":false}}},{"node":{"excerpt":"Intro 프로그래밍 초창기에는 시스템을 루틴과 하위 루틴으로 나눴습니다. 포트란과 PL/1 시절에는 시스템을 프로그램, 하위 프로그램, 함수로 나눴습니다. 하지만 지금은 함수만 살아 남았습니다. 어떤 프로그램이든 가장 기본적인 단위가 함수입니다. 작게 만들어라! 함수를 만드는 첫째 규칙은  입니다. 함수를 만드는 둘째 규칙은  입니다. 이 규칙은 근거를…","fields":{"slug":"/clean code/clean-code-3장-함수/"},"frontmatter":{"date":"March 03, 2020","title":"clean code 3장 함수","category":"clean code","draft":false}}},{"node":{"excerpt":"추천사 5S 원칙 정리(Seiri) 또는 조직(정럴(sort)) 적절한 명명법 등과 같은 방법을 사용해 무엇이 어디에 있는지 알아야 합니다. 정돈(Seiton) 또는 단정함(체계화) “물건마다 모두 제자리 가 있다”라는 속담이 있습니다. 코드는 누구나 예상히는 위치에 있어야 합니다. 그렇지 않으면 다시 정돈해 누구나 예상하는 위치로 옮겨야 합니다. 청소(…","fields":{"slug":"/clean code/clean-code-추천사-및-0장/"},"frontmatter":{"date":"March 03, 2020","title":"clean code 추천사 및 0장 들어가면서","category":"clean code","draft":false}}},{"node":{"excerpt":"코드가 존재하리라 코드는 요구사항을 표현하는 언어라는 사실을 명심해야 합니다. 요구사항에 더욱 가까운 언어를 만들 수도 있고, 요구사항에서 정형 구조를 뽑아내는 도구를 만들 수도 있습니다. 하지만 어느 순간에는 정밀한 표현이 필요합니다. 그 필요성을 없앨 방법은 없습니다. 그러므로 코드도 항상 존재 합니다. 코드에 관한 책은 구시대적이고, 곧 명세를 기준…","fields":{"slug":"/clean code/clean-code-1장-깨끗한-코드/"},"frontmatter":{"date":"March 03, 2020","title":"clean code 1장 깨끗한 코드","category":"clean code","draft":false}}},{"node":{"excerpt":"Repository는 하나의 도메인에 관련 된 것들을 컨트롤 합니다. 하나의 도메인에는 여러개의 테이블이 존재할 수 있습니다. REPOSITORY는 메모리에 로드된 객체 컬렉션에 대한 집합 처리를 위한 인터페이스를 제공합니다. DAO(Data Access Object)는 하나의 테이블에 관련 된 것들을 컨트롤 합니다. Entity Bean을 대체하기 위한…","fields":{"slug":"/develop/repository와-dao/"},"frontmatter":{"date":"February 24, 2020","title":"repository와 DAO","category":"develop","draft":false}}},{"node":{"excerpt":"SYNC / ASYNC return 한다면 SYNC, callback으로 응답한다면 ASYNC 입니다. Synchronous / Asynchronous는 호출되는 함수의 작업 완료 여부를 누가 신경쓰냐가 관심사 입니다. SYNC : 서브루틴이 즉시 값을 반환 합니다. 이벤트를 자신이 직접 처리 합니다.(확인의 주체가 유저 프로세스이며, 다 될때까지 기다리…","fields":{"slug":"/develop/동기-비동기/"},"frontmatter":{"date":"February 24, 2020","title":"동기 비동기","category":"develop","draft":false}}},{"node":{"excerpt":"tsconfig 파일 작성 esModuleInterop을 설정하지 않고 module.exports와 export default를 다르게 import 한다. module.exports 를 사용해서 import 해야한다. scripts 작성 webpack 적용 nodeExternals를 사용하지 않으면 웹팩에서 에러가 발생한다. 왜인지는 아직 잘 모르겠다… …","fields":{"slug":"/typescript/node-javascript에서-typescript로-바꾸기/"},"frontmatter":{"date":"February 22, 2020","title":"Node javascript에서 typescript로 바꾸기","category":"typescript","draft":false}}},{"node":{"excerpt":"XSS 란? Cross Site Scripting의 약자로 CSS라고 하는 것이 맞지만 Cascading Style Sheets의 약어로 사용되어 있어 XSS라고 합니다. XSS 게시판이나 웹 메일 등에 자바스크립트 같은 스크립트 코드를 삽입 해 개발자가 고려하지 않은 기능이 작동하게 하는 치명적일 수 있는 공격 입니다. 대부분의 웹 해킹 공격 기법과는 …","fields":{"slug":"/frontend/xss/"},"frontmatter":{"date":"February 21, 2020","title":"XSS","category":"frontend","draft":false}}},{"node":{"excerpt":",  두 속성을 이용해서 html 수정을 허용 할 수 있습니다.","fields":{"slug":"/frontend/html-edit/"},"frontmatter":{"date":"February 21, 2020","title":"html edit","category":"frontend","draft":false}}},{"node":{"excerpt":"Circular dependency 소프트웨어 엔지니어링 하는 순환 종속성은 직접 또는 간접적으로 제대로 작동 서로 의존 두개 또는 그 이상의 모듈들 간의 관계입니다. 이러한 모듈은 상호 재귀 라고도 합니다. 무조건 터지느건 아니고 컨스트럭터 이전에 생성을 하기 위해 참조하던 것이 생성하고 있는 중인 것을 참조해서 터지는 경우가 발생했습니다. 이를 끊어내…","fields":{"slug":"/javascript/순환-의존성/"},"frontmatter":{"date":"February 21, 2020","title":"순환 의존성","category":"javascript","draft":false}}},{"node":{"excerpt":"메타태그의 뷰포트 속성에 을 추가 CSS 추가 하단에 플로팅된 버튼과 아이폰 홈 버튼의 간격이 겹쳐 간격을 주고 싶을때 IOS에서 11.2 업데이트시 constant속성을 없애고 env로 정의하도록 변경이 되었다. 하지만 업데이트 안한 유저들이 있어 두번째, 세번째 라인 모두 추가해야 구, 신기종을 전부 대응할 수 있다. 구버전 대응시 env값을 + 10…","fields":{"slug":"/frontend/아이폰-홈인디케이터/"},"frontmatter":{"date":"February 21, 2020","title":"아이폰 홈인디케이터","category":"frontend","draft":false}}},{"node":{"excerpt":"","fields":{"slug":"/javascript/월의-시작과-끝/"},"frontmatter":{"date":"February 21, 2020","title":"월의 시작과 끝","category":"javascript","draft":false}}},{"node":{"excerpt":"자바스크립트에는 유사배열이라는 것이 존재 합니다. 배열과 유사배열을 구분해야 하는 이유는, 유사배열의 경우 배열의 메서드를 쓸 수 없기 때문입니다. 나 로 확인 할 수 있습니다. 유사배열들 유사배열에서 배열 메서드 사용하기 출처 배열과 유사배열","fields":{"slug":"/frontend/유사배열/"},"frontmatter":{"date":"February 19, 2020","title":"유사배열","category":"frontend","draft":false}}},{"node":{"excerpt":"assign 객체 안에 배열 함수에서 활용 freeze","fields":{"slug":"/javascript/배열-복사/"},"frontmatter":{"date":"February 15, 2020","title":"복사","category":"javascript","draft":false}}},{"node":{"excerpt":"마우스를 올리면 텍스트 밑에 밑줄을 긋는다거나 배경색을 바꾸는 효과를 줄때가 있다. 하지만 모바일에서는 호버 이벤트가 없다 하지만 이를 위해 action 가상 선택자를 통해 클릭 시 효과를 주는 것으로 통일성을 맞춰 나가는거 같다. 하지만 호버 이벤트를 모바일 사이즈에서 없애지 않는다면 클릭 후 색이 남는 현상이 발생 했다. 이벤트 주기 호버 이벤트를 지…","fields":{"slug":"/frontend/hover/"},"frontmatter":{"date":"February 14, 2020","title":"hover","category":"frontend","draft":false}}},{"node":{"excerpt":"스크롤 되는 영역에 그라데이션을 넣어야 했다. 아래 영역에서 before과 absolute를 이용해서 스크롤 되는 리스트 하단에 항상 그라데이션을 넣는 것에는 성공했다. 하지만 그 영역에서 스크롤 되지 않았다. 그냥 보기엔 리스트의 영역처럼 보이지만 실제론 아래 영역 안에 포함된 곳이기 때문에 스크롤이 되지 않는 것이 어찌보면 당연히 맞다. 이를 해결하기…","fields":{"slug":"/frontend/pointer-events/"},"frontmatter":{"date":"February 13, 2020","title":"pointer events","category":"frontend","draft":false}}},{"node":{"excerpt":"이미지를 업로드 하는 경우에 로컬에서는 문제가 없었으나 호스팅한 서버에서는 를 반환했습니다. 413 Request Entity Too Large는 nginx에서 업로드한 파일의 용량이 제한 수치를 넘겨서 발생 했습니다. 로컬에선 nginx를 사용하지 않고 호스팅 된 서버에서는 80포트를 8080포트로 옮겨주기 위해 사용했습니다. 해결 방안 nginx 서버…","fields":{"slug":"/backend/413-request-entity-too-large/"},"frontmatter":{"date":"February 13, 2020","title":"413 Request Entity Too Large","category":"backend","draft":false}}},{"node":{"excerpt":"객체 생성 패턴 네임스페이스 패턴 쉽게 구현할 수 있는 패턴이며 전역변수의 개수를 줄이고, 변수명이 불필요하게 길어짐을 방지한다. 전역 네임스페이스 객체는 흔히 대문자로 선언한다. 이 패턴의 단점은 다음과 같다. 모든 변수와 함수에 접두어를 붙이므로, 전체 코드량이 길어져 다운로드 파일의 크기가 증가 전역 인스턴스가 1개이기 떄문에 부분이 수정되면 다른 …","fields":{"slug":"/javascript/객체-생성-패턴/"},"frontmatter":{"date":"February 12, 2020","title":"객체 생성 패턴","category":"javascript","draft":false}}},{"node":{"excerpt":"HTTP/1은 하나의 TCP 연결에 하나의 요청만 처리하고 연결을 끊어버렸기 때문에 매 요청마다 이 번거로운 핸드쉐이크를 거쳐야 했습니다. HTTP/2에서는 핸드쉐이크를 최소화하기 위해서 단일 TCP 연결을 유지하면서 여러 개의 요청을 처리할 수 있도록 변경 되었습니다. 결국 HTTP/1에서 HTTP/2로 넘어갈 때도 핸드쉐이크 과정 자체는 건드리지 않았…","fields":{"slug":"/frontend/http/"},"frontmatter":{"date":"February 11, 2020","title":"http","category":"frontend","draft":false}}},{"node":{"excerpt":"react에서 function으로 만들어진 component에는 4가지 타입이 있었습니다. FC, SFC, FunctionComponent, StatelessComponent 하지만 hooks로 인해서 function component에서도 state를 사용할 수 있게 되어 SFC와 StatelessComponent가 deprecated 되었습니다.","fields":{"slug":"/react/function-component-type/"},"frontmatter":{"date":"February 10, 2020","title":"function component type","category":"react","draft":false}}},{"node":{"excerpt":"TCP 연결형 서비스 가상 회선 방식 전송 순서 보장 신뢰성 높음 전송 속도 느림 http/1과 http/2는 TCP를 사용 UDP 비연결형 서비스 데이터그램 방식 전송 순서 보장 하지 않음 신뢰성 낮음 전송 속도 빠름 http/3는 UDP를 사용 커스터마이징이 용이하다","fields":{"slug":"/frontend/tcp-udp/"},"frontmatter":{"date":"February 09, 2020","title":"TCP UDP","category":"frontend","draft":false}}},{"node":{"excerpt":"","fields":{"slug":"/frontend/input-number/"},"frontmatter":{"date":"February 08, 2020","title":"input number","category":"frontend","draft":false}}},{"node":{"excerpt":"위와 같이 타입을 바꿀 때 as를 사용 가능 위과 같이 사용할 땐 is를 사용 위의 is와 관련 된 문법엔 오류가 많다(자바랑 섞어 쓰기도 하고)","fields":{"slug":"/kotlin/kotlin-is-and-as/"},"frontmatter":{"date":"February 07, 2020","title":"kotlin is and as","category":"kotlin","draft":false}}},{"node":{"excerpt":"JVM은 자바 가상머신(Java Virtual Machine)의 약자입니다. JRE는 자바 실행환경(Java Runtime Environment)의 약자입니다. JDK JDK는 자바 개발도구(Java Development Kit)의 약자입니다. JDK는 JRE + 개발을 위해 필요한 도구(javac, java등)들을 포함합니다. v8은 jvm가 아니라 j…","fields":{"slug":"/Java/jre-jvm/"},"frontmatter":{"date":"February 06, 2020","title":"JRE JVM","category":"java","draft":false}}},{"node":{"excerpt":"String a = “”로 생성하는건 String pool을 할당하는거고 내부적으로 intern()이라는 코드를 통해 상수풀에 값을 올립니다. 이미 존재하는 값이라면 값을 주소를 리턴하는 것을 보장합니다. “hello” + “world”와 같은 동작도 String pool을 할당받은 동작을 하는 것이기 때문에 a==e 는 true 입니다. “문자열” + …","fields":{"slug":"/Java/java-string/"},"frontmatter":{"date":"February 05, 2020","title":"Java String","category":"java","draft":false}}},{"node":{"excerpt":"마진병합현상의 조건 인접해있는 Block요소끼리만 일어납니다. 상하단만 해당 됩니다. 레이아웃을 더 보기 좋게 하기 위한 좋은 기능이다. 하지만 원하는 바와 다르게 적용 될 수도 있다. 마진병합을 방지하는 방법 부모에 margin이 0 auto여서 wrapper와 자식의 마진이 사라졌을 경우 부모에 padding: 1px을 줍니다. 부모에 border: …","fields":{"slug":"/frontend/마진-병합/"},"frontmatter":{"date":"February 04, 2020","title":"마진 병합","category":"frontend","draft":false}}},{"node":{"excerpt":"ES2015(ES6)에서 자바스크립트에 클래스(Class)가 도입되었습니다. 자바스크립트는 기본적으로 프로토타입 기반의 언어입니다. 프로토타입 기반으로 객체 지향적으로 설계하는 것이 복잡하여 클래스라는 sugar syntax 문법이 도입된 것입니다. Java에서의 클래스와 똑같은 기능을 한다고 생각 할 수 있지만 여전히 객체 지향을 흉내내고 있고 그 내부…","fields":{"slug":"/javascript/javascript-class/"},"frontmatter":{"date":"February 03, 2020","title":"JavaScript Class","category":"javascript","draft":false}}},{"node":{"excerpt":"Hook가 React 버전 16.8에 새로 추가되었습니다. Hook를 이용하여 Class를 작성할 필요 없이 상태 값과 여러 React의 기능을 사용할 수 있습니다. 하지만 React에서 Class를 제거할 계획은 없습니다. Hook은 알고 있는 React 컨셉을 대체하지 않습니다. 대신에, Hook는 props, state, context, refs, …","fields":{"slug":"/react/react-hook/"},"frontmatter":{"date":"February 02, 2020","title":"React Hook","category":"react","draft":false}}},{"node":{"excerpt":"3.0 새로운 개념의 프로젝트 참조가 도입되었습니다. 프로젝트 참조를 통해 TypeScript 프로젝트는 다른 TypeScript 프로젝트에 의존 할 수 tsconfig.json있습니다. 특히 파일이 다른 tsconfig.json파일 을 참조 할 수 있습니다. 이러한 종속성을 지정하면 TypeScript가 빌드 순서 및 출력 구조를 이해할 수 있는 방법을…","fields":{"slug":"/typescript/TypeScript 버전에 따른 변경점/"},"frontmatter":{"date":"February 01, 2020","title":"TypeScript 버전에 따른 변경점","category":"typescript","draft":false}}},{"node":{"excerpt":"부트스트랩 쉽고 빠르며 다양한 기능들을 제공합니다. 다양한 디자인과 동적인 효과를 사용할 수 있습니다. 모바일 환경과 반응형 웹 제작에 유리하게 사용할 수 있습니다. 높은 퀄리티가 보장이 되기 때문에 시간을 단축하며 그로 인해 비용이 절감 됩니다. jQuery에 의존성이 강합니다(부트스트랩 5가 되면서 jQuery를 제거 했다고 합니다) 정형화되어 있어 …","fields":{"slug":"/frontend/오픈소스-ui-kit들의-장단점/"},"frontmatter":{"date":"January 31, 2020","title":"오픈소스 UI Kit들의 장단점","category":"frontend","draft":false}}},{"node":{"excerpt":"","fields":{"slug":"/frontend/flexbox/"},"frontmatter":{"date":"January 30, 2020","title":"flexbox","category":"frontend","draft":false}}},{"node":{"excerpt":"background CSS 단축 속성은 색상, 이미지, 원점, 크기, 반복 등 여러 배경 스타일을 한 번에 지정합니다. background: background-color | background-image | background-repeat | background-attachment | background-position background: #12345…","fields":{"slug":"/frontend/background/"},"frontmatter":{"date":"January 29, 2020","title":"background","category":"frontend","draft":false}}},{"node":{"excerpt":"position static : 기본값, 다른 태그와의 관계에 의해 자동으로 배치되며 위치를 임의로 설정해 줄 수 없습니다. 움직이지 않고 정적인 상태입니다. relative : 원래 있던 위치를 기준으로 좌표를 지정합니다. 부모 엘리먼트를 기준으로 상대적으로 움직입니다. absolute : 절대 좌표와 함께 위치를 지정해 줄 수 있습니다. positio…","fields":{"slug":"/frontend/position-속성과-offset/"},"frontmatter":{"date":"January 28, 2020","title":"position 속성과 Offset","category":"frontend","draft":false}}},{"node":{"excerpt":"유니온(Union)타입 유니온 타입은 하나의 프로퍼티에 다양한 변수가 올 수 있는 타입을 말합니다. keyof 키워드 keyof 키워드는 타입 값에 존재하는 모든 프로퍼티의 키값을 union 형태로 리턴 받습니다. never 타입 never는 에러가 발생했을 때 프로세스를 중단시키지 않고 무시하는 타입입니다. any를 제외한 다른 모든 타입의 원시 타입으…","fields":{"slug":"/typescript/typescript-헬터-타입/"},"frontmatter":{"date":"January 27, 2020","title":"typescript 헬터 타입","category":"typescript","draft":false}}},{"node":{"excerpt":"prototype을 사용하여 class를 구현하는 방법 prototype을 사용하여 상속을 구현 일반적으로 클래스를 만들면 자동으로 prototype의 constructor라는 프로퍼티가 만들어집니다. 이 프로퍼티에는 해당 클래스의 생성자 정보가 기본값으로 담기게 됩니다. 달리 말하면 constructor 프로퍼티를 이용해 사용하는 객체가 어떤 클래스의 …","fields":{"slug":"/javascript/javascript에서-클래스를-구현하는-방법,-상속하는-방법/"},"frontmatter":{"date":"January 27, 2020","title":"javascript에서 클래스를 구현하는 방법, 상속하는 방법","category":"javascript","draft":false}}},{"node":{"excerpt":"screen.height 화면의 세로 크기를 가져옵니다. screen.availHeight 브라우저의 막대를 포함하여 최대화 된 경우 브라우저의 윈도우가 가질 수 있는 높이입니다. 창이 최대화되면 screen.availHeight === window.outerHeight 작업 표시줄이 차지하는 부분을 제외한 세로 크기를 가져옵니다. 화면 아래의 작업 표시…","fields":{"slug":"/frontend/height/"},"frontmatter":{"date":"January 26, 2020","title":"height","category":"frontend","draft":false}}},{"node":{"excerpt":"HTML부터 React까지의 제가 알고 있는 웹 프론트엔드 흐름에 대해 정리를 해보고자 합니다. 웹은 HTML, CSS, Javascript로 구성되어 있습니다. DART나 KOTLIN.JS, 웹어셈블리 등이 웹을 지원하기는 한다고 합니다. HTML 가장 먼저 HTML은 HyperText Markup Language로 웹페이지를 기술하기 위한 마크업 언어…","fields":{"slug":"/frontend/web-frontend/"},"frontmatter":{"date":"January 24, 2020","title":"WEB FRONTEND","category":"frontend","draft":false}}},{"node":{"excerpt":"자바스크립트로 doublyLinkedList 구현하기 참조 데이터 스트럭쳐란 무엇인가? codingeverybody/datastructurejava","fields":{"slug":"/javascript/doublylinkedlist/"},"frontmatter":{"date":"January 24, 2020","title":"doublyLinkedList","category":"javascript","draft":false}}},{"node":{"excerpt":"자바스크립트로 linkedList 구현하기 참조 데이터 스트럭쳐란 무엇인가? codingeverybody/datastructurejava","fields":{"slug":"/javascript/linkedlist/"},"frontmatter":{"date":"January 24, 2020","title":"linkedList","category":"javascript","draft":false}}},{"node":{"excerpt":"자바스크립트로 arrayList 구현하기 참조 데이터 스트럭쳐란 무엇인가? codingeverybody/datastructurejava","fields":{"slug":"/javascript/arraylist/"},"frontmatter":{"date":"January 24, 2020","title":"arrayList","category":"javascript","draft":false}}},{"node":{"excerpt":"모바일과 PC 웹브라우저의 scroll 모바일 웹을 작업하고 있는데 스크롤을 구현하는게 상당히 골치가 아픕니다. 스크롤은 어디나 들어가는 아주 일반적인 기능이라고 생각하고 있었음에도 구현하는데 여러가지 어려움이 상당히 많습니다. 스크롤 스크롤 영역으로 지정하는 것은 딱히 모바일 웹에 특화된 것은 아닙니다. 스크롤을 사용할 곳의 크기를 지정하고 CSS 속성…","fields":{"slug":"/frontend/scroll/"},"frontmatter":{"date":"January 24, 2020","title":"scroll","category":"frontend","draft":false}}},{"node":{"excerpt":"모바일과 PC 웹브라우저의 viewport 차이 meta viewport 태그는 애플이 아이폰, 아이패드 등 자사의 모바일 브라우저의 뷰포트(viewport) 크기 조절을 위해 만들었습니다. viewport란 우리말로 보임참, 즉 화면 상의 표시 영역을 뜻합니다. 화면의 보여지는 영역과 viewport는 차이가 있는데, viewport는 그림을 그리기 위…","fields":{"slug":"/frontend/viewport/"},"frontmatter":{"date":"January 23, 2020","title":"viewport","category":"frontend","draft":false}}},{"node":{"excerpt":"npm 의존성관리 javascript 패키지 매니저 java에 gradle , php의 composer 와 같은 역할을 한다. npm은 node의 모듈을 관리해주는 패키지 매니저입니다. node.js를 설치하면 내장(built in)되어 있습니다. npm -v를 통해 버전을 확인할 수 있습니다. npm install 명령으로 외부 모듈 패키지를 설치합니다…","fields":{"slug":"/javascript/javascript-패키지-매니저/"},"frontmatter":{"date":"January 22, 2020","title":"javascript 패키지 매니저","category":"javascript","draft":false}}},{"node":{"excerpt":"package.json 파일을 작성할 때에는 JavaScript의 객체 리터럴이 아니라 올바른 JSON 포맷이어야 합니다. npm init 명령어를 통해 package.json 파일을 만들 수 있습니다. -y 옵션을 사용해서 빠르게 생성 할 수도 있습니다. name 필수로 입력되어야 하며 이 항목들이 누락되면 패키지를 설치할 수 없습니다. name은 반드…","fields":{"slug":"/javascript/package.json/"},"frontmatter":{"date":"January 21, 2020","title":"package.json","category":"javascript","draft":false}}},{"node":{"excerpt":"서버 사이드 템플릿 시대를 지나 단일 페이지 애플리케이션(Single Page Application, SPA) 개발이 점차 인기를 얻으면서 자바스크립트의 코드량이 과거에 비해 기하급수적으로 증가하게 되었습니다. 많게는 수천, 수만 줄이나 하는 자바스크립트 코드에서 특정 코드를 찾아 수정하기란 쉽지 않은 일입니다. 그래서, 개발 초기 단계에서 API 기능과…","fields":{"slug":"/javascript/웹팩4(webpack)-설정하기/"},"frontmatter":{"date":"January 20, 2020","title":"웹팩4(Webpack) 설정하기","category":"javascript","draft":false}}},{"node":{"excerpt":"react와 styled-components를 이용해서 퍼센트에 따라 원을 그리는 컴포넌트를 만들었습니다.","fields":{"slug":"/react/퍼센트-원-그리기/"},"frontmatter":{"date":"January 19, 2020","title":"퍼센트 원 그리기","category":"react","draft":false}}},{"node":{"excerpt":"리액트는 배열을 렌더링 할 때 값을 통하여 업데이트 성능을 최적화 합니다. 기본적으로 DOM 노드의 자식에 대해 반복 할 때 React는 두 자식 목록을 동시에 반복하고 차이가 있을 때마다 돌연변이를 생성합니다.(virtual dom diff를 써서 확인) 이 문제를 해결하기 위해 React는 key속성을 지원 합니다. 자식에 키가 있으면 React는이 …","fields":{"slug":"/react/리액트에서-key를-사용하는-이유/"},"frontmatter":{"date":"January 18, 2020","title":"리액트에서 key를 사용하는 이유","category":"react","draft":false}}},{"node":{"excerpt":"프로토타입 기반 프로그래밍은 객체지향 프로그래밍의 한 형태의 갈래로 클래스가 없고, 클래스 기반 언어에서 상속을 사용하는 것과는 다르게, 객체를 원형(프로토타입)으로 하여 복제의 과정을 통하여 객체의 동작 방식을 다시 사용할 수 있습니다. 프로토 타입 역할을 하는 delegation을 통해 기존 객체를 재사용하는 프로세스를 통해 동작 재사용(상속)을 수행…","fields":{"slug":"/javascript/프로토타입-기반의-객체지향/"},"frontmatter":{"date":"January 17, 2020","title":"프로토타입 기반의 객체지향","category":"javascript","draft":false}}},{"node":{"excerpt":"V8이란? 독일 구글 개발 센터에서 만들어진 JavaScript 엔진입니다. 웹 브라우저 안에서 실행되는 JavaScript의 성능을 높이기 위해 처음 고안되었습니다. 오픈 소스이고 C++로 작성되었습니다. 구글 크롬과 Node.js의 런타임에서 사용 중입니다. 속도를 높이기 위해서 V8은 인터프리터를 이용하는 대신 기계어 코드로 번역합니다. JIT(Ju…","fields":{"slug":"/frontend/v8-엔진의-동작-원리/"},"frontmatter":{"date":"January 14, 2020","title":"V8 엔진의 동작 원리","category":"frontend","draft":false}}},{"node":{"excerpt":"가장 먼저 CSS transition 속성을 이용해서 아코디언 애니메이션을 구현했습니다. CSS를 수정하지 않고 애니메이션 구현하기 window.requestAnimationFrame 함수를 사용해서 구현했습니다. 애니메이션을 모두 기다린 후에 클릭을 하면 잘 작동하지만 애니메이션 도중 클릭을 할 경우 제대로 작동하지 않고 다시 클릭 했을 때 2번 작동 …","fields":{"slug":"/frontend/라이브러리-없이-애니메이션-구현하는-방법/"},"frontmatter":{"date":"January 14, 2020","title":"라이브러리 없이 애니메이션 구현하는 방법","category":"frontend","draft":false}}}]}},"pageContext":{}}}