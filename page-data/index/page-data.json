{"componentChunkName":"component---src-pages-index-js","path":"/","result":{"data":{"site":{"siteMetadata":{"title":"yuniq 블로그","configs":{"countOfInitialPost":10}}},"allMarkdownRemark":{"edges":[{"node":{"excerpt":"메타태그의 뷰포트 속성에 을 추가 CSS 추가 하단에 플로팅된 버튼과 아이폰 홈 버튼의 간격이 겹쳐 간격을 주고 싶을때 IOS에서 11.2 업데이트시 constant속성을 없애고 env로 정의하도록 변경이 되었다. 하지만 업데이트 안한 유저들이 있어 두번째, 세번째 라인 모두 추가해야 구, 신기종을 전부 대응할 수 있다. 구버전 대응시 env값을 + 10…","fields":{"slug":"/frontend/아이폰-홈인디케이터/"},"frontmatter":{"date":"February 21, 2020","title":"아이폰 홈인디케이터","category":"frontend","draft":false}}},{"node":{"excerpt":"","fields":{"slug":"/javascript/월의-시작과-끝/"},"frontmatter":{"date":"February 21, 2020","title":"월의 시작과 끝","category":"javascript","draft":false}}},{"node":{"excerpt":"자바스크립트에는 유사배열이라는 것이 존재 합니다. 배열과 유사배열을 구분해야 하는 이유는, 유사배열의 경우 배열의 메서드를 쓸 수 없기 때문입니다. 나 로 확인 할 수 있습니다. 유사배열들 유사배열에서 배열 메서드 사용하기 출처 배열과 유사배열","fields":{"slug":"/frontend/유사배열/"},"frontmatter":{"date":"February 19, 2020","title":"유사배열","category":"frontend","draft":false}}},{"node":{"excerpt":"assign 객체 안에 배열 함수에서 활용 freeze","fields":{"slug":"/javascript/배열-복사/"},"frontmatter":{"date":"February 15, 2020","title":"복사","category":"javascript","draft":false}}},{"node":{"excerpt":"마우스를 올리면 텍스트 밑에 밑줄을 긋는다거나 배경색을 바꾸는 효과를 줄때가 있다. 하지만 모바일에서는 호버 이벤트가 없다 하지만 이를 위해 action 가상 선택자를 통해 클릭 시 효과를 주는 것으로 통일성을 맞춰 나가는거 같다. 하지만 호버 이벤트를 모바일 사이즈에서 없애지 않는다면 클릭 후 색이 남는 현상이 발생 했다. 이벤트 주기 호버 이벤트를 지…","fields":{"slug":"/frontend/hover/"},"frontmatter":{"date":"February 14, 2020","title":"hover","category":"frontend","draft":false}}},{"node":{"excerpt":"스크롤 되는 영역에 그라데이션을 넣어야 했다. 아래 영역에서 before과 absolute를 이용해서 스크롤 되는 리스트 하단에 항상 그라데이션을 넣는 것에는 성공했다. 하지만 그 영역에서 스크롤 되지 않았다. 그냥 보기엔 리스트의 영역처럼 보이지만 실제론 아래 영역 안에 포함된 곳이기 때문에 스크롤이 되지 않는 것이 어찌보면 당연히 맞다. 이를 해결하기…","fields":{"slug":"/frontend/pointer-events/"},"frontmatter":{"date":"February 13, 2020","title":"pointer events","category":"frontend","draft":false}}},{"node":{"excerpt":"이미지를 업로드 하는 경우에 로컬에서는 문제가 없었으나 호스팅한 서버에서는 를 반환했습니다. 413 Request Entity Too Large는 nginx에서 업로드한 파일의 용량이 제한 수치를 넘겨서 발생 했습니다. 로컬에선 nginx를 사용하지 않고 호스팅 된 서버에서는 80포트를 8080포트로 옮겨주기 위해 사용했습니다. 해결 방안 nginx 서버…","fields":{"slug":"/backend/413-request-entity-too-large/"},"frontmatter":{"date":"February 13, 2020","title":"413 Request Entity Too Large","category":"backend","draft":false}}},{"node":{"excerpt":"객체 생성 패턴 네임스페이스 패턴 쉽게 구현할 수 있는 패턴이며 전역변수의 개수를 줄이고, 변수명이 불필요하게 길어짐을 방지한다. 전역 네임스페이스 객체는 흔히 대문자로 선언한다. 이 패턴의 단점은 다음과 같다. 모든 변수와 함수에 접두어를 붙이므로, 전체 코드량이 길어져 다운로드 파일의 크기가 증가 전역 인스턴스가 1개이기 떄문에 부분이 수정되면 다른 …","fields":{"slug":"/javascript/객체-생성-패턴/"},"frontmatter":{"date":"February 12, 2020","title":"객체 생성 패턴","category":"javascript","draft":false}}},{"node":{"excerpt":"HTTP/1은 하나의 TCP 연결에 하나의 요청만 처리하고 연결을 끊어버렸기 때문에 매 요청마다 이 번거로운 핸드쉐이크를 거쳐야 했습니다. HTTP/2에서는 핸드쉐이크를 최소화하기 위해서 단일 TCP 연결을 유지하면서 여러 개의 요청을 처리할 수 있도록 변경 되었습니다. 결국 HTTP/1에서 HTTP/2로 넘어갈 때도 핸드쉐이크 과정 자체는 건드리지 않았…","fields":{"slug":"/frontend/http/"},"frontmatter":{"date":"February 11, 2020","title":"http","category":"frontend","draft":false}}},{"node":{"excerpt":"react에서 function으로 만들어진 component에는 4가지 타입이 있었습니다. FC, SFC, FunctionComponent, StatelessComponent 하지만 hooks로 인해서 function component에서도 state를 사용할 수 있게 되어 SFC와 StatelessComponent가 deprecated 되었습니다.","fields":{"slug":"/react/function-component-type/"},"frontmatter":{"date":"February 10, 2020","title":"function component type","category":"react","draft":false}}},{"node":{"excerpt":"TCP 연결형 서비스 가상 회선 방식 전송 순서 보장 신뢰성 높음 전송 속도 느림 http/1과 http/2는 TCP를 사용 UDP 비연결형 서비스 데이터그램 방식 전송 순서 보장 하지 않음 신뢰성 낮음 전송 속도 빠름 http/3는 UDP를 사용 커스터마이징이 용이하다","fields":{"slug":"/frontend/tcp-udp/"},"frontmatter":{"date":"February 09, 2020","title":"TCP UDP","category":"frontend","draft":false}}},{"node":{"excerpt":"","fields":{"slug":"/frontend/input-number/"},"frontmatter":{"date":"February 08, 2020","title":"input number","category":"frontend","draft":false}}},{"node":{"excerpt":"위와 같이 타입을 바꿀 때 as를 사용 가능 위과 같이 사용할 땐 is를 사용 위의 is와 관련 된 문법엔 오류가 많다(자바랑 섞어 쓰기도 하고)","fields":{"slug":"/kotlin/kotlin-is-and-as/"},"frontmatter":{"date":"February 07, 2020","title":"kotlin is and as","category":"kotlin","draft":false}}},{"node":{"excerpt":"JVM은 자바 가상머신(Java Virtual Machine)의 약자입니다. JRE는 자바 실행환경(Java Runtime Environment)의 약자입니다. JDK JDK는 자바 개발도구(Java Development Kit)의 약자입니다. JDK는 JRE + 개발을 위해 필요한 도구(javac, java등)들을 포함합니다. v8은 jvm가 아니라 j…","fields":{"slug":"/Java/jre-jvm/"},"frontmatter":{"date":"February 06, 2020","title":"JRE JVM","category":"java","draft":false}}},{"node":{"excerpt":"String a = “”로 생성하는건 String pool을 할당하는거고 내부적으로 intern()이라는 코드를 통해 상수풀에 값을 올립니다. 이미 존재하는 값이라면 값을 주소를 리턴하는 것을 보장합니다. “hello” + “world”와 같은 동작도 String pool을 할당받은 동작을 하는 것이기 때문에 a==e 는 true 입니다. “문자열” + …","fields":{"slug":"/Java/java-string/"},"frontmatter":{"date":"February 05, 2020","title":"Java String","category":"java","draft":false}}},{"node":{"excerpt":"마진병합현상의 조건 인접해있는 Block요소끼리만 일어납니다. 상하단만 해당 됩니다. 레이아웃을 더 보기 좋게 하기 위한 좋은 기능이다. 하지만 원하는 바와 다르게 적용 될 수도 있다. 마진병합을 방지하는 방법 부모에 margin이 0 auto여서 wrapper와 자식의 마진이 사라졌을 경우 부모에 padding: 1px을 줍니다. 부모에 border: …","fields":{"slug":"/frontend/마진-병합/"},"frontmatter":{"date":"February 04, 2020","title":"마진 병합","category":"frontend","draft":false}}},{"node":{"excerpt":"ES2015(ES6)에서 자바스크립트에 클래스(Class)가 도입되었습니다. 자바스크립트는 기본적으로 프로토타입 기반의 언어입니다. 프로토타입 기반으로 객체 지향적으로 설계하는 것이 복잡하여 클래스라는 sugar syntax 문법이 도입된 것입니다. Java에서의 클래스와 똑같은 기능을 한다고 생각 할 수 있지만 여전히 객체 지향을 흉내내고 있고 그 내부…","fields":{"slug":"/javascript/javascript-class/"},"frontmatter":{"date":"February 03, 2020","title":"JavaScript Class","category":"javascript","draft":false}}},{"node":{"excerpt":"Hook가 React 버전 16.8에 새로 추가되었습니다. Hook를 이용하여 Class를 작성할 필요 없이 상태 값과 여러 React의 기능을 사용할 수 있습니다. 하지만 React에서 Class를 제거할 계획은 없습니다. Hook은 알고 있는 React 컨셉을 대체하지 않습니다. 대신에, Hook는 props, state, context, refs, …","fields":{"slug":"/react/react-hook/"},"frontmatter":{"date":"February 02, 2020","title":"React Hook","category":"react","draft":false}}},{"node":{"excerpt":"3.0 새로운 개념의 프로젝트 참조가 도입되었습니다. 프로젝트 참조를 통해 TypeScript 프로젝트는 다른 TypeScript 프로젝트에 의존 할 수 tsconfig.json있습니다. 특히 파일이 다른 tsconfig.json파일 을 참조 할 수 있습니다. 이러한 종속성을 지정하면 TypeScript가 빌드 순서 및 출력 구조를 이해할 수 있는 방법을…","fields":{"slug":"/javascript/typescript-3.0~3.6의-변경점/"},"frontmatter":{"date":"February 01, 2020","title":"TypeScript 3.0~3.6의 변경점","category":"javascript","draft":false}}},{"node":{"excerpt":"부트스트랩 쉽고 빠르며 다양한 기능들을 제공합니다. 다양한 디자인과 동적인 효과를 사용할 수 있습니다. 모바일 환경과 반응형 웹 제작에 유리하게 사용할 수 있습니다. 높은 퀄리티가 보장이 되기 때문에 시간을 단축하며 그로 인해 비용이 절감 됩니다. jQuery에 의존성이 강합니다(부트스트랩 5가 되면서 jQuery를 제거 했다고 합니다) 정형화되어 있어 …","fields":{"slug":"/frontend/오픈소스-ui-kit들의-장단점/"},"frontmatter":{"date":"January 31, 2020","title":"오픈소스 UI Kit들의 장단점","category":"frontend","draft":false}}},{"node":{"excerpt":"","fields":{"slug":"/frontend/flexbox/"},"frontmatter":{"date":"January 30, 2020","title":"flexbox","category":"frontend","draft":false}}},{"node":{"excerpt":"background CSS 단축 속성은 색상, 이미지, 원점, 크기, 반복 등 여러 배경 스타일을 한 번에 지정합니다. background: background-color | background-image | background-repeat | background-attachment | background-position background: #12345…","fields":{"slug":"/frontend/background/"},"frontmatter":{"date":"January 29, 2020","title":"background","category":"frontend","draft":false}}},{"node":{"excerpt":"position static : 기본값, 다른 태그와의 관계에 의해 자동으로 배치되며 위치를 임의로 설정해 줄 수 없습니다. 움직이지 않고 정적인 상태입니다. relative : 원래 있던 위치를 기준으로 좌표를 지정합니다. 부모 엘리먼트를 기준으로 상대적으로 움직입니다. absolute : 절대 좌표와 함께 위치를 지정해 줄 수 있습니다. positio…","fields":{"slug":"/frontend/position-속성과-offset/"},"frontmatter":{"date":"January 28, 2020","title":"position 속성과 Offset","category":"frontend","draft":false}}},{"node":{"excerpt":"유니온(Union)타입 유니온 타입은 하나의 프로퍼티에 다양한 변수가 올 수 있는 타입을 말합니다. keyof 키워드 keyof 키워드는 타입 값에 존재하는 모든 프로퍼티의 키값을 union 형태로 리턴 받습니다. never 타입 never는 에러가 발생했을 때 프로세스를 중단시키지 않고 무시하는 타입입니다. any를 제외한 다른 모든 타입의 원시 타입으…","fields":{"slug":"/javascript/typescript-헬터-타입/"},"frontmatter":{"date":"January 27, 2020","title":"typescript 헬터 타입","category":"javascript","draft":false}}},{"node":{"excerpt":"prototype을 사용하여 class를 구현하는 방법 prototype을 사용하여 상속을 구현 일반적으로 클래스를 만들면 자동으로 prototype의 constructor라는 프로퍼티가 만들어집니다. 이 프로퍼티에는 해당 클래스의 생성자 정보가 기본값으로 담기게 됩니다. 달리 말하면 constructor 프로퍼티를 이용해 사용하는 객체가 어떤 클래스의 …","fields":{"slug":"/javascript/javascript에서-클래스를-구현하는-방법,-상속하는-방법/"},"frontmatter":{"date":"January 27, 2020","title":"javascript에서 클래스를 구현하는 방법, 상속하는 방법","category":"javascript","draft":false}}},{"node":{"excerpt":"screen.height 화면의 세로 크기를 가져옵니다. screen.availHeight 브라우저의 막대를 포함하여 최대화 된 경우 브라우저의 윈도우가 가질 수 있는 높이입니다. 창이 최대화되면 screen.availHeight === window.outerHeight 작업 표시줄이 차지하는 부분을 제외한 세로 크기를 가져옵니다. 화면 아래의 작업 표시…","fields":{"slug":"/frontend/height/"},"frontmatter":{"date":"January 26, 2020","title":"height","category":"frontend","draft":false}}},{"node":{"excerpt":"HTML부터 React까지의 제가 알고 있는 웹 프론트엔드 흐름에 대해 정리를 해보고자 합니다. 웹은 HTML, CSS, Javascript로 구성되어 있습니다. DART나 KOTLIN.JS, 웹어셈블리 등이 웹을 지원하기는 한다고 합니다. HTML 가장 먼저 HTML은 HyperText Markup Language로 웹페이지를 기술하기 위한 마크업 언어…","fields":{"slug":"/frontend/web-frontend/"},"frontmatter":{"date":"January 24, 2020","title":"WEB FRONTEND","category":"frontend","draft":false}}},{"node":{"excerpt":"자바스크립트로 doublyLinkedList 구현하기 참조 데이터 스트럭쳐란 무엇인가? codingeverybody/datastructurejava","fields":{"slug":"/javascript/doublylinkedlist/"},"frontmatter":{"date":"January 24, 2020","title":"doublyLinkedList","category":"javascript","draft":false}}},{"node":{"excerpt":"자바스크립트로 linkedList 구현하기 참조 데이터 스트럭쳐란 무엇인가? codingeverybody/datastructurejava","fields":{"slug":"/javascript/linkedlist/"},"frontmatter":{"date":"January 24, 2020","title":"linkedList","category":"javascript","draft":false}}},{"node":{"excerpt":"자바스크립트로 arrayList 구현하기 참조 데이터 스트럭쳐란 무엇인가? codingeverybody/datastructurejava","fields":{"slug":"/javascript/arraylist/"},"frontmatter":{"date":"January 24, 2020","title":"arrayList","category":"javascript","draft":false}}},{"node":{"excerpt":"모바일과 PC 웹브라우저의 scroll 모바일 웹을 작업하고 있는데 스크롤을 구현하는게 상당히 골치가 아픕니다. 스크롤은 어디나 들어가는 아주 일반적인 기능이라고 생각하고 있었음에도 구현하는데 여러가지 어려움이 상당히 많습니다. 스크롤 스크롤 영역으로 지정하는 것은 딱히 모바일 웹에 특화된 것은 아닙니다. 스크롤을 사용할 곳의 크기를 지정하고 CSS 속성…","fields":{"slug":"/frontend/scroll/"},"frontmatter":{"date":"January 24, 2020","title":"scroll","category":"frontend","draft":false}}},{"node":{"excerpt":"모바일과 PC 웹브라우저의 viewport 차이 meta viewport 태그는 애플이 아이폰, 아이패드 등 자사의 모바일 브라우저의 뷰포트(viewport) 크기 조절을 위해 만들었습니다. viewport란 우리말로 보임참, 즉 화면 상의 표시 영역을 뜻합니다. 화면의 보여지는 영역과 viewport는 차이가 있는데, viewport는 그림을 그리기 위…","fields":{"slug":"/frontend/viewport/"},"frontmatter":{"date":"January 23, 2020","title":"viewport","category":"frontend","draft":false}}},{"node":{"excerpt":"npm 의존성관리 javascript 패키지 매니저 java에 gradle , php의 composer 와 같은 역할을 한다. npm은 node의 모듈을 관리해주는 패키지 매니저입니다. node.js를 설치하면 내장(built in)되어 있습니다. npm -v를 통해 버전을 확인할 수 있습니다. npm install 명령으로 외부 모듈 패키지를 설치합니다…","fields":{"slug":"/javascript/javascript-패키지-매니저/"},"frontmatter":{"date":"January 22, 2020","title":"javascript 패키지 매니저","category":"javascript","draft":false}}},{"node":{"excerpt":"package.json 파일을 작성할 때에는 JavaScript의 객체 리터럴이 아니라 올바른 JSON 포맷이어야 합니다. npm init 명령어를 통해 package.json 파일을 만들 수 있습니다. -y 옵션을 사용해서 빠르게 생성 할 수도 있습니다. name 필수로 입력되어야 하며 이 항목들이 누락되면 패키지를 설치할 수 없습니다. name은 반드…","fields":{"slug":"/javascript/package.json/"},"frontmatter":{"date":"January 21, 2020","title":"package.json","category":"javascript","draft":false}}},{"node":{"excerpt":"서버 사이드 템플릿 시대를 지나 단일 페이지 애플리케이션(Single Page Application, SPA) 개발이 점차 인기를 얻으면서 자바스크립트의 코드량이 과거에 비해 기하급수적으로 증가하게 되었습니다. 많게는 수천, 수만 줄이나 하는 자바스크립트 코드에서 특정 코드를 찾아 수정하기란 쉽지 않은 일입니다. 그래서, 개발 초기 단계에서 API 기능과…","fields":{"slug":"/javascript/웹팩4(webpack)-설정하기/"},"frontmatter":{"date":"January 20, 2020","title":"웹팩4(Webpack) 설정하기","category":"javascript","draft":false}}},{"node":{"excerpt":"react와 styled-components를 이용해서 퍼센트에 따라 원을 그리는 컴포넌트를 만들었습니다.","fields":{"slug":"/react/퍼센트-원-그리기/"},"frontmatter":{"date":"January 19, 2020","title":"퍼센트 원 그리기","category":"react","draft":false}}},{"node":{"excerpt":"리액트는 배열을 렌더링 할 때 값을 통하여 업데이트 성능을 최적화 합니다. 기본적으로 DOM 노드의 자식에 대해 반복 할 때 React는 두 자식 목록을 동시에 반복하고 차이가 있을 때마다 돌연변이를 생성합니다.(virtual dom diff를 써서 확인) 이 문제를 해결하기 위해 React는 key속성을 지원 합니다. 자식에 키가 있으면 React는이 …","fields":{"slug":"/react/리액트에서-key를-사용하는-이유/"},"frontmatter":{"date":"January 18, 2020","title":"리액트에서 key를 사용하는 이유","category":"react","draft":false}}},{"node":{"excerpt":"프로토타입 기반 프로그래밍은 객체지향 프로그래밍의 한 형태의 갈래로 클래스가 없고, 클래스 기반 언어에서 상속을 사용하는 것과는 다르게, 객체를 원형(프로토타입)으로 하여 복제의 과정을 통하여 객체의 동작 방식을 다시 사용할 수 있습니다. 프로토 타입 역할을 하는 delegation을 통해 기존 객체를 재사용하는 프로세스를 통해 동작 재사용(상속)을 수행…","fields":{"slug":"/javascript/프로토타입-기반의-객체지향/"},"frontmatter":{"date":"January 17, 2020","title":"프로토타입 기반의 객체지향","category":"javascript","draft":false}}},{"node":{"excerpt":"V8이란? 독일 구글 개발 센터에서 만들어진 JavaScript 엔진입니다. 웹 브라우저 안에서 실행되는 JavaScript의 성능을 높이기 위해 처음 고안되었습니다. 오픈 소스이고 C++로 작성되었습니다. 구글 크롬과 Node.js의 런타임에서 사용 중입니다. 속도를 높이기 위해서 V8은 인터프리터를 이용하는 대신 기계어 코드로 번역합니다. JIT(Ju…","fields":{"slug":"/frontend/v8-엔진의-동작-원리/"},"frontmatter":{"date":"January 14, 2020","title":"V8 엔진의 동작 원리","category":"frontend","draft":false}}},{"node":{"excerpt":"가장 먼저 CSS transition 속성을 이용해서 아코디언 애니메이션을 구현했습니다. CSS를 수정하지 않고 애니메이션 구현하기 window.requestAnimationFrame 함수를 사용해서 구현했습니다. 애니메이션을 모두 기다린 후에 클릭을 하면 잘 작동하지만 애니메이션 도중 클릭을 할 경우 제대로 작동하지 않고 다시 클릭 했을 때 2번 작동 …","fields":{"slug":"/frontend/라이브러리-없이-애니메이션-구현하는-방법/"},"frontmatter":{"date":"January 14, 2020","title":"라이브러리 없이 애니메이션 구현하는 방법","category":"frontend","draft":false}}}]}},"pageContext":{}}}