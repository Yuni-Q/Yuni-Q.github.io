{"componentChunkName":"component---src-pages-index-js","path":"/","result":{"data":{"site":{"siteMetadata":{"title":"yuni-q 블로그","configs":{"countOfInitialPost":10}}},"allMarkdownRemark":{"edges":[{"node":{"excerpt":"잘 설계된 객체지향 애플리케이션은 들로 구성됩니다. 이런 작은 객체들이 단독으로 수행할 수 있는 작업은 거의 없기 때문에 객체 사이의 을 낳습니다. 협력을 위해서는 의존성이 필요하지만 과도한 의존성은 애플리케이션을 수정하기 어렵게 만듭니다. 객체지향 설계의 핵심은 협력을 위해 필요한 의존성은 유지하면서도 변경을 방해하는 의존성을 제거하는 데 있습니다. 이…","fields":{"slug":"/object/object-chapter-08-의존성-관리하기/"},"frontmatter":{"date":"April 20, 2020","title":"object chapter 08 의존성 관리하기","category":"object","draft":false}}},{"node":{"excerpt":"HTTP 요청 흐름 (웹브라우저에서의 요청) 브라우저에서 먼저 URL에 적힌 값을 파싱하여, HTTP 요청 메세지를 만듭니다. 만든 메세지를 웹 서버로 전송하는데, 이때 웹 브라우저 직접 전송을 하는것이 아니라 OS에 ‘보내주세요’ 하고 의뢰를 하게 됩니다. OS는 DNS서버를 조회해서 Host이름을 보내야 할 IP 주소로 변환하게 됩니다. 프로토콜 스택…","fields":{"slug":"/develop/웹과-통신/"},"frontmatter":{"date":"April 16, 2020","title":"웹과 통신","category":"develop","draft":false}}},{"node":{"excerpt":"단편화란 메모리 상에서 적재되고, 해제되는 과정에서 발생하는 메모리 사이의 사용하지 못할 정도로 작은 빈 공간 입니다. 크게 외부 단편화와 내부 단편화로 나뉩니다. 외부 단편화는 프로세스와 프로세스 사이에 발생하는 빈 공간입니다. 외부 단편화는 메모리를 다시 재정렬하는 압축을 통해 해결할 수 있지만, 효율이 좋지 않습니다. 내부 단편화는 프로세스 안에서 …","fields":{"slug":"/develop/메모리/"},"frontmatter":{"date":"April 16, 2020","title":"메모리","category":"develop","draft":false}}},{"node":{"excerpt":"OOP (객체지향 프로그래밍) 객체지향 프로그래밍은 컴퓨터 프로그래밍 패러다임(견해, 사고법)의 하나로, 프로그래밍에서 필요한 데이터를 추상화 시켜서 상태(속성, 어트리뷰트)와 행위(메서드)를 가진 객체로 만들고, 그 객체간의 상호작용을 통해 로직을 구성하는 방법 입니다. 장점 다른 클래스를 가져와 사용할 수 있고, 상속받을 수 있어 코드의 재사용성이 높…","fields":{"slug":"/develop/oop,-aop,-fp/"},"frontmatter":{"date":"April 16, 2020","title":"OOP, AOP, FP","category":"develop","draft":false}}},{"node":{"excerpt":"스케줄러란 CPU와 같은 자원을 우선순위에 기반하여 프로세스에 할당하는 방법을 말합니다. Job Queue : 현재 시스템 안에서 돌고 있는 프로세스의 집합 입니다. Ready Queue : 메모리 안에서 CPU의 할당을 기다리는 프로세스의 집합 입니다. Device Queue : 장치 입출력을 기다리고 있는 프로세스의 집합 입니다. 스케줄러의 종류 세 …","fields":{"slug":"/develop/cpu-스케줄링/"},"frontmatter":{"date":"April 16, 2020","title":"CPU 스케줄링","category":"develop","draft":false}}},{"node":{"excerpt":"List ArrayList 배열로 구현된 List 입니다. 데이터가 저장된 순서가 같습니다. 사실상 배열과 같은 자료구조이기 때문에, 리스트의 연산 자체의 수행시간 속도는 배열과 같습니다. LinkedList 다음 노드의 주소를 기억하고 있는 List로, 배열에 비해 삽입과 삭제가 간단합니다. 그러나 탐색의 경우 첫 번째 노드부터 탐색해 나가야 하기 때문…","fields":{"slug":"/develop/collection/"},"frontmatter":{"date":"April 14, 2020","title":"Collection","category":"develop","draft":false}}},{"node":{"excerpt":"What is GRASP? GRASP는 객체 지향 디자인의 클래스 및 객체에 책임을 할당하기위한 지침으로 구성됩니다. SOLID 설계 원칙과 관련이 없다고는 하지만 서로 엮여있는 부분이 조금씩은 있습니다. General Responsibility Assignment Software Patterns Object-Oriented 디자인의 핵심은 각 객체에 책…","fields":{"slug":"/develop/grasp-(object-oriented-design)/"},"frontmatter":{"date":"April 12, 2020","title":"GRASP (object-oriented design)","category":"develop","draft":false}}},{"node":{"excerpt":"Async/await 더 편안한 환경에서 Promise를 다루기 위해 태어난 특별한 문법입니다. Async 함수 함수 전에 “async”라는 단어가 의미하는 것은 간단합니다 : promise를 반환하는 함수라는 뜻입니다. 심지어 만일함수가 실제로 promise가 아닌 값을 반환해도, “async” 키워드로 정의된 함수는 자바스크립트에서 자동으로 그 값을 …","fields":{"slug":"/javascript/async-await/"},"frontmatter":{"date":"April 12, 2020","title":"Async Await","category":"javascript","draft":false}}},{"node":{"excerpt":"Promise 이해하기 프로미스는 말 그대로 약속 입니다. Promise는 3가지 상태를 가집니다. Pending(미결) Fulfilled(이행) Rejected(거절) Promise는 비동기(Asynchronous)다. ES5, ES6/2015, ES7에서의 Promise ES5 - 주류 브라우저들 Bluebird Promise 라이브러리만 설치했다면,…","fields":{"slug":"/javascript/promise/"},"frontmatter":{"date":"April 12, 2020","title":"Promise","category":"javascript","draft":false}}},{"node":{"excerpt":"Iterator는 자바스크립트의 collection을 반복하는 새로운 방법입니다. ES6에서 소개된 개념이고 매우 유용하고 많은 곳에서 사용되고 있기 때문에 인기가 많습니다. 반복 가능한 것(Iterable)과 Iterator 을 적용한 메소드가 iteratorMethod 입니다. 이와 비슷하게 사용자 정의 오브젝트를 반복하는 프로세스의 표준화가 에 의해…","fields":{"slug":"/javascript/iterator/"},"frontmatter":{"date":"April 12, 2020","title":"Iterator","category":"javascript","draft":false}}},{"node":{"excerpt":"ES6는 제너레이터(Generator) 또는 Generator 함수 형태에서 함수와 Iterator를 다루는 방법을 새롭게 소개했습니다. 제너레이터는 함수를 중간에서 멈추고, 다시 멈췄던 부분부터 실행할 수 있게 합니다. 요약하면, Generator는 함수의 형태를 띄지만, Iterator처럼 동작합니다. 재미있는 사실은 async/await이 Gener…","fields":{"slug":"/javascript/generator/"},"frontmatter":{"date":"April 12, 2020","title":"generator","category":"javascript","draft":false}}},{"node":{"excerpt":"재귀의 3가지 중요한 특성 종료 조건 간단하게, if(나쁜 값이 들어왔다면) { 정지! };과 같이 이해하시면 됩니다. 종료 조건은 재귀의 안전장치입니다. 종료 조건을 여러분들의 긴급 브레이크처럼 생각하세요. 좋지 않은 입력 값이 들어왔을 때, 재귀가 계속하여 동작하는 것을 방지해줍니다. 위의 팩토리얼 예제에서, if (x < 0) return;은 우리가…","fields":{"slug":"/develop/재귀(recursion)/"},"frontmatter":{"date":"April 12, 2020","title":"재귀(Recursion)","category":"develop","draft":false}}},{"node":{"excerpt":"바로 현재 값에 접근할 수 있습니다.(arrayi와 같은 형식으로 접근하려면 매우 불편하죠.) 기존 배열의 변화를 방지할 수 있기 때문입니다.(immutable) 그래서, side-effect를 최소화할 수 있습니다. for loop을 관리할 필요가 없습니다. 빈 배열을 만들고 거기에 push할 필요가 없습니다. 참조 자바스크립트 개발자라면 알아야 할 3…","fields":{"slug":"/javascript/map,-filter,-reduce를-사용하는-이유/"},"frontmatter":{"date":"April 10, 2020","title":"Map, Filter, Reduce를 사용하는 이유","category":"javascript","draft":false}}},{"node":{"excerpt":"자바스크립트에는 눈으로 보기엔 비슷하지만 사실 매우 다른 동등 비교연산자 두개가 있습니다. 자바스크립트에서 === 연산을 사용할 때, 우리는 엄격한 동등성을 비교합니다. 엄격한 동등성의 의미는 타입과 값이 둘 다 같아야 한다는 이야기입니다. 우리가 자바스크립트에서 ==연산자를 쓰는 목적은 느슨한 동등 비교를 위함입니다. == 연산자도 강제 형변환(type…","fields":{"slug":"/javascript/==-vs-===/"},"frontmatter":{"date":"April 10, 2020","title":"== vs ===","category":"javascript","draft":false}}},{"node":{"excerpt":"this 함수가 만들어졌을 때, 뒤에서는 this라 불리는 키워드가 만들어집니다. this는 함수가 동작하는 곳에 있는 오브젝트와 연결해줍니다. this 키워드의 값은 그 함수 자체와는 상관이 없습니다. 함수가 어떻게 불려지는지가 this의 값을 결정합니다. 기본 값으로, this는 언제나 전역 스코프의 root을 참조하는 window Object가 됩니…","fields":{"slug":"/javascript/this,-call(),-apply(),-bind()/"},"frontmatter":{"date":"April 10, 2020","title":"this, call(), apply(), bind()","category":"javascript","draft":false}}},{"node":{"excerpt":"DOM DOM(Document Object Model)은 웹사이트를 유저와 상호작용할 수 있도록 만들기 위해 필수적인 부분입니다. DOM은 프로그래밍 언어가 웹사이트의 내용(content), 구조(structure) 그리고 스타일을 조작할 수 있게 만들어주는 인터페이스입니다. 자바스크립트는 인터넷 브라우저 상의 DOM과 연결해주는 클라이언트 사이드 스크립…","fields":{"slug":"/frontend/dom/"},"frontmatter":{"date":"April 10, 2020","title":"DOM","category":"frontend","draft":false}}},{"node":{"excerpt":"자바스크립트의 모든 것이 Object(객체)인 것은 아닙니다. 자바스크립트에는 6개의 원시 타입이 존재합니다. 원시 타입이 아닌 것들은 모두 Object(객체)입니다. 함수는 단순히 특별한 타입의 Object(객체)일 뿐입니다. 함수는 새로운 Object(객체)를 만들기 위해 사용될 수 있습니다.(생성자 함수) Strings, Booleans, Numbe…","fields":{"slug":"/javascript/primitive-type/"},"frontmatter":{"date":"April 10, 2020","title":"Primitive Type","category":"javascript","draft":false}}},{"node":{"excerpt":"5장에서는 2장에서 소개한 코드의 설계 과정을 한 걸음씩 따라가 보면서 객체에 책임을 할당하는 기본적인 원리를 살펴 봅니다. 데이터 중심의 설계는 하고 협력이라는 문맥을 벗어나 고립된 객체의 상태에 초점을 맞추기 때문에 캡슐화를 위반하기 쉽고, 요소들 사이의 결합도가 높아지며, 코드를 변경하기 어려워집니다. 데이터 중심 설계로 인해 발생하는 문제점을 해결…","fields":{"slug":"/object/object-chapter-05-책임-할당하기/"},"frontmatter":{"date":"April 07, 2020","title":"object chapter 05 책임 할당하기","category":"object","draft":false}}},{"node":{"excerpt":"","fields":{"slug":"/frontend/크롤링/"},"frontmatter":{"date":"April 03, 2020","title":"크롤링","category":"frontend","draft":false}}},{"node":{"excerpt":"주석 C1: 부적절한 정보 다른 시스템에 (예를 들어, 소스 코드 관리 시스템, 버그 추적 시스템，이슈 추적 시스템, 기타 기록 관리 시스템에) 저장할 정보는 주석으로 적절하지 못합니다. 일반적으로 작성자, 최종수정일, SPR(Software Prablem Report)번호 등과 같은 메타 정보만 주석으로 넣습니다. 주석은 코드와 설계에 기술적인 설명을 …","fields":{"slug":"/clean code/clean-code-17장-냄새와-휴리스틱/"},"frontmatter":{"date":"April 02, 2020","title":"clean code 17장 냄새와 휴리스틱","category":"clean code","draft":false}}},{"node":{"excerpt":"지난 수십여 년 동안 쌓아온 경험에서 얻은 교훈이라면, 프로그래밍은 과학보다 공예(craft)에 가깝다는 사실입니다. 깨끗한 코드를 짜려면 먼저 지저분한 코드를 짠 뒤에 정리해야 합니다. 하지만 대다수 신잠 프로그래머는 무조건 돌아가는 프로그램을 목표로 잡습니다. 일단 프로그램이 ‘돌아가면’ 다음 업무로 넘어갑니다. ‘돌아가는’ 프로그램은 그 상태가 어떻…","fields":{"slug":"/clean code/clean-code-14장-점진적인개선/"},"frontmatter":{"date":"April 02, 2020","title":"clean code 14장 점진적인개선","category":"clean code","draft":false}}},{"node":{"excerpt":"클라이언트/서버 예제 먼저 애플리케이션이 어디서 시간을 보내는지 알아야 합니다. 가능성은 다음 두 가지 입니다. I/O : 소켓 사용, 데이터베이스 연결, 가상 메모리 스와핑 기다리기 등에 시간을 보냅니다. 프로세서 : 수치 계산, 정규표현식 처리, 가비지 컬렉션 등에 시간을 보냅니다. 대개 시스템은 둘 다 하느라 시간을 보내지만, 특정 연산을 살펴보면 …","fields":{"slug":"/clean code/clean-code-부록a-동시성2/"},"frontmatter":{"date":"April 02, 2020","title":"clean code 부록A 동시성2","category":"clean code","draft":false}}},{"node":{"excerpt":"15장 JUnit 들여다보기 비록 저자들이 모듈을 아주 좋은 상태로 남겨두었지만 보이스카우트 규칙에 따르면 우리는 처음 왔을 때보다 더 깨끗하게 해놓고 떠나야 합니다. 가장 먼저 눈에 거슬리는 부분은 멤버 변수 앞에 붙인 접두어 f입니다. 오늘날 사용하는 개발 환경에서는 이처럼 변수 이름에 범위를 명시할 필요가 없습니다. 접두어 f는 중복되는 정보입니다.…","fields":{"slug":"/clean code/clean-code-15장-16장/"},"frontmatter":{"date":"April 02, 2020","title":"clean code 15장 16장","category":"clean code","draft":false}}},{"node":{"excerpt":"사용하게 된 계기 github education name.com에서 도메인과 ssl 사용하던 중 예기치 않게 서버를 종료 후 ssl을 다시 적용해야 하는데 쉽지 않았습니다. 메일 같은걸 보내긴 했는데 되는건지도 잘 모르겠고, 인증서를 다시 보려고 해도 에러만 발생합니다… certbot-auto 세팅 www 파일 수정 “greenlock-express”: …","fields":{"slug":"/develop/node-https-적용/"},"frontmatter":{"date":"April 01, 2020","title":"node https 적용","category":"develop","draft":false}}},{"node":{"excerpt":"Intro 객체는 처리의 추상화입니다. 스레드는 일정의 추상화입니다. 동시성과 깔끔한 코드는 양립하기 어렵습니다. 스레드를 하나만 실행 하는 코드는 작성하기 쉽습니다. 겉으로 보기에는 멀쩡하나 깊숙한 곳에 문제가 있는 다중 스레드 코드도 작성하기 쉽습니다. 이런 코드는 시스템이 부하를 받기 전까지 멀쩡하게 돌아갑니다. 본 챕터에서는 concurrent 프…","fields":{"slug":"/clean code/clean-code-13장-동시성/"},"frontmatter":{"date":"March 31, 2020","title":"clean code 13장 동시성","category":"clean code","draft":false}}},{"node":{"excerpt":"Intro 창발성이란 단순한 결합이 복잡한 결과를 나타내는 것을 의합니다. 인간의 뇌를 예로 들면 하나의 뉴런은 인식능력이 없지만 수십억개의 뉴런이 결합하게 되면 자기 인식이 발생하는 현상을 말하는 것입니다. 이 창발성은 명령을 내리는 조정자 없이 각 부분의 의사소통으로 자기 조직화를 이루게 되고 이러한 밑으로 부터의 힘은 예기치 못한 기능을 발현하는 힘…","fields":{"slug":"/clean code/clean-code-12장-창발성/"},"frontmatter":{"date":"March 27, 2020","title":"clean code 12장 창발성","category":"clean code","draft":false}}},{"node":{"excerpt":"클래스 체계 클래스를 정의하는 표준 자바 관례에 따르면, 가장 먼저 변수 목록이 나옵니다. 정적 공개 상수가 있다면 맨 처음에 나옵니다. 다음으로 정적 비공개변수가 나옵니다. 이어서 비공개 인스턴스 변수가 나옵니다. 공개 변수가 필요한 경우는 거의 없습니다. 변수 목록 다음에는 공개 함수가 나옵니다. 비공개 함수는 자신을 호출하는 공개 함수 직후에 넣습니…","fields":{"slug":"/clean code/clean-code-10장-클래스/"},"frontmatter":{"date":"March 27, 2020","title":"clean code 10장 클래스","category":"clean code","draft":false}}},{"node":{"excerpt":"Intro 깨끗한 코드를 구현하면 낮은 추상화 수준에서 관심사를 분리하기 쉬워집니다. 시스템 제작과 시스템 사용을 분리하라 잘 정돈된 견고한 시스템을 만들기 위해서는 전역적이고 일관된 의존성 해결 방법을 통해 작은 편의 코드들이 모듈성의 저해를 가져오는 것을 막아야 합니다. 소프트웨어 시스템은 (애플리케이션 객체를 제작하고 의존성을 서로 ‘연결’하는) 준…","fields":{"slug":"/clean code/clean-code-11장-시스템/"},"frontmatter":{"date":"March 27, 2020","title":"clean code 11장 시스템","category":"clean code","draft":false}}},{"node":{"excerpt":"Intro 1997년만 해도 TDD(Test Driven Development)라는 개념을 아무도 몰랐습니다. 우리들 대다수에게 단위 테스트란 자기 프로그램이 ‘돌아간다’는 사실만 확인하는 일회성 코드에 불과했습니다. 지금은 애자일과 TDD 덕택에 단위 테스트를 자동화하는 프로그래머들이 이미 많아졌으며 점점 더 늘어나는 추세입니다. 우리 분야에 테스트를 …","fields":{"slug":"/clean code/clean-code-9장-단위-테스트/"},"frontmatter":{"date":"March 27, 2020","title":"clean code 9장 단위 테스트","category":"clean code","draft":false}}},{"node":{"excerpt":"원본 .d.ts 파일이 node_modules 아래에 있을 경우 컴파일러는 src/index.ts에서 non-relative module import구문을 발견하여 moduleA모듈에 대한 타입 선언 파일을 탐색하기 시작합니다. compilerOptions.path에 moduleA에 대한 경로 설정이 존재하므로 해당 경로를 우선 탐색합니다. 경로에서 .d…","fields":{"slug":"/typescript/npm-모듈의-타입-선언-파일(.d.ts)을-커스텀-타입-선언-파일로-대체하는-법/"},"frontmatter":{"date":"March 26, 2020","title":"npm 모듈의 타입 선언 파일(.d.ts)을 커스텀 타입 선언 파일로 대체하는 법","category":"typescript","draft":false}}},{"node":{"excerpt":"setInterval(func, delay, …args)와 setTimeout(func, delay, …args) 2개의 메소드는 func을 delayms 이후에 주기적으로 혹은 한번 실행하도록 허용해줍니다. 실행을 취소하기 위해, 우리는 setInterval 또는 setTimeout에서 반환되는 값을 이용해 clearInterval 또는 clearTim…","fields":{"slug":"/javascript/setinterval-and-settimeout/"},"frontmatter":{"date":"March 25, 2020","title":"setInterval and setTimeout","category":"javascript","draft":false}}},{"node":{"excerpt":"우리는 가끔 서드파티 패키지나 오픈소스를 사용해야 될 상황에 직면합니다. 혹은 우리 회사 내부 팀이 만든 컴포넌트를 사용해야 할 상황도 있습니다. 어느 상황이던, 우리는 이 코드들을 우리 내부 코드와 “깨끗하게” 통합시켜야 합니다. 외부 코드 사용하기(서드파티 코드 사용하기) 경계에서의 긴장 패키지 제공자나 프레임워크 제공자는 을 최대한 넓히려 애씁니다.…","fields":{"slug":"/clean code/clean-code-8장-경계/"},"frontmatter":{"date":"March 24, 2020","title":"clean code 8장 경계","category":"clean code","draft":false}}},{"node":{"excerpt":"도메인 구입 DNS 세팅 type : A answer : {본인 IP} SSL 적용 CSR 생성 이메일과 전화번호는 name.com 사이트와 일치하게 작성합니다. 도메인과 파일 이름을 같게 세팅 합니다. 인증서 설치 아래의 정보를 바탕으로 인증서 받기 인증서 정보를 바탕으로 cert.pem 생성 Nginx 세팅 sslsessioncache shared:S…","fields":{"slug":"/develop/github-education-name.com-사용하기/"},"frontmatter":{"date":"March 22, 2020","title":"github education name.com 사용하기","category":"develop","draft":false}}},{"node":{"excerpt":"","fields":{"slug":"/javascript/생년월일-확인/"},"frontmatter":{"date":"March 20, 2020","title":"생년월일 확인","category":"javascript","draft":false}}},{"node":{"excerpt":"추상클래스 클래스가 미완성이라는 것은 멤버의 개수에 관계된 것이 아니라, 단지 미완성 메서드(추상메서드)들 포함하고 있는 의미입니다. 추상클래스로 인터턴스는 생성할 수 없습니다. 추상클래스는 상속을 통해서 자손클래스에 의해서만 완성될 수 있습니다. 상속을 강제하기 위한 추상메서드를 하나 이상 가진 클래스를 말합니다. 맥락에 따라서 달라질 수 있는 기능들이…","fields":{"slug":"/develop/추상클래스와-인터페이스/"},"frontmatter":{"date":"March 18, 2020","title":"추상클래스와 인터페이스","category":"develop","draft":false}}},{"node":{"excerpt":"싱글톤 패턴 싱글톤 패턴은 단 하나의 인스턴스를 생성해 사용하는 디자인 패턴입니다. 클래스 인스턴스가 하나만 만들어지도록 하고, 그 인스턴스에 대한 전역 접근을 제공합니다. 이를 구현할 때는 private 생성자와, 정적 메소드, 정적 변수만을 사용합니다. 캐시나 로그 기록, 사용자 설정 같이 자주 사용되는 데이터들을 같이 공유하며 저장해두는 것들에 이용…","fields":{"slug":"/design pattern/싱글톤/"},"frontmatter":{"date":"March 18, 2020","title":"싱글톤","category":"design pattern","draft":false}}},{"node":{"excerpt":"Model 데이터를 처리하는 역할 입니다. 애플리케이션의 정보(데이터)를 처리하는 컴포넌트를 말합니다. 데이터베이스에 연결하고 데이터를 추출하거나 저장, 삭제, 업데이트, 변환 등의 작업을 수행하는 역할을 합니다. View 사용자가 보는 화면입니다. 화면에 표시되는 부분입니다. 추출한 데이터나 일반적인 텍스트 데이터를 표시하거나 input, button …","fields":{"slug":"/design pattern/mvc-mvp-mvvm/"},"frontmatter":{"date":"March 18, 2020","title":"MVC MVP MVVM","category":"design pattern","draft":false}}},{"node":{"excerpt":"명령형과 선언형의 차이 명령형 프로그래밍 명령형 프로그래밍이란 프로그래밍의 상태와 상태를 변경시키는 구문의 관점에서 연산을 설명하는 방식입니다. 알고리즘을 명시하고 목표는 명시하지 않습니다. 프로그램은 명령의 수행입니다. 어떻게(how to)에 초점을 맞춥니다. 튜링 머신에 이론적 배경을 둡니다. 선언형 프로그래밍 선언형 프로그래밍은 어떤 방법으로 해야하…","fields":{"slug":"/programming paradigm/프로그래밍-패러다임/"},"frontmatter":{"date":"March 18, 2020","title":"프로그래밍 패러다임","category":"develop","draft":false}}},{"node":{"excerpt":"참조 [code-lab] CSS Gradient로 투명배경판 만들기 [CSS] linear-gradient를 활용하여 체스판 배경 만들기","fields":{"slug":"/frontend/css로-격자-만들기/"},"frontmatter":{"date":"March 13, 2020","title":"CSS로 격자 만들기","category":"frontend","draft":false}}},{"node":{"excerpt":"Intro 오류 처리는 프로그램에 반드시 필요한 요소 중 하나일 뿐입니다. 입력 이 이상하거나 디바이스가 실패할지도 모르기 때문입니다. 간단히 말해, 뭔가 잘못될 가능성은 늘 존재합니다. 뭔가 잘못되면 바로 잡을 책임은 바로 우리 프로그래머에게 있습니다. 깨끗한 코드와 오류 처리는 확실히 연관성이 있습니다. 상당수 코드 기반은 전적으로 오류 처리 코드에 …","fields":{"slug":"/clean code/clean-code-7장-오류-처리/"},"frontmatter":{"date":"March 10, 2020","title":"clean code 7장 오류 처리","category":"clean code","draft":false}}},{"node":{"excerpt":"Intro 변수를 비공개로 정의하는 이유가 있습니다. 남들이 변수에 의존하지 않게 만들고 싶어서 입니다. 충동이든 변덕이든, 변수 타입이나 구현을 맘대로 바꾸고 싶어합니다. 자료 추상화 변수 사이에 함수라는 계층을 넣는다고 구현이 저절로 감춰지지는 않습니다. 구현을 감추려면 추상화가 필요합니다. 그저 (형식 논리에 치우쳐) 조회 함수와 설정 함수로 변수를…","fields":{"slug":"/clean code/clean-code-6장-객체와-자료-구조/"},"frontmatter":{"date":"March 07, 2020","title":"clean code 6장 객체와 자료 구조","category":"clean code","draft":false}}},{"node":{"excerpt":"공변성 : 타입 T를 확장한 타입에 대해서 허용합니다. 보통 인자는 공변성을 가집니다. 무공변성 : 타입 T만 허용합니다. 반공변성: 타입 T의 상위(부모) 타입에 대해서 허용합니다. 보통 리턴 타입은 반공변성을 가집니다. 참조 공변성과 반공변성, 무공변성","fields":{"slug":"/develop/공변-반공변-무공변/"},"frontmatter":{"date":"March 06, 2020","title":"공변 반공변 무공변","category":"develop","draft":false}}},{"node":{"excerpt":"Intro 질서정연하고 깔끔하며, 일관적인 코드를 본다면 사람들에게 전문가가 짰다는 인상을 심어줄 수 있습니다. 반대로, 코드가 어수선해 보인다면 프로젝트 전반적으로 무성의한 태도로 작성했다고 생각합니다. 프로그래머라면 형식을 깔끔하게 맞춰 코드를 짜야 합니다. 코드 형식을 맞추기 위한 간단한 규칙을 정하고 그 규칙을 착실히 따라야 합니다. 팀으로 일한다…","fields":{"slug":"/clean code/clean-code-5장-형식-맞추기/"},"frontmatter":{"date":"March 06, 2020","title":"clean code 5장 형식 맞추기","category":"clean code","draft":false}}},{"node":{"excerpt":"나쁜 코드에 주석을 달지 말아야 합니다. 새로 짜는 것이 좋습니다. 주석은 필요악 입니다. 코드로 의도를 표현하지 못해, 실패를 만회하기 위해 쓰는 것입니다. 주석은 언제나 실패를 의미합니다. 주석 없이는 자신을 표현할 방법을 찾지 못해 할 수 없이 주석을 사용합니다. 그래서 주석은 반가울수 없습니다. 주석이 오래될수록 코드에서 멀어져서 거짓말을 하게 될…","fields":{"slug":"/clean code/clean-code-4장-주석/"},"frontmatter":{"date":"March 04, 2020","title":"clean code 4장 주석","category":"clean code","draft":false}}},{"node":{"excerpt":"의도를 분명히 밝힙니다. 변수의 존재 이유, 기능, 사용법 등이 변수/함수/클래스명에 드러나야 합니다. 따로 주석이 필요하지 않을 정도로 드러나야 합니다. 의미를 함축하거나 독자(코드를 읽는 사람)가 사전 지식을 가지고 있다고 가정하지 않습니다. 그릇된 정보를 피합니다. 중의적으로 해석될 수 있는 이름 피해야 합니다. 개발자에게는 특수한 의미를 가지는 단…","fields":{"slug":"/clean code/clean-code-2장-의미-있는-이름/"},"frontmatter":{"date":"March 03, 2020","title":"clean code 2장 의미 있는 이름","category":"clean code","draft":false}}},{"node":{"excerpt":"Intro 프로그래밍 초창기에는 시스템을 루틴과 하위 루틴으로 나눴습니다. 포트란과 PL/1 시절에는 시스템을 프로그램, 하위 프로그램, 함수로 나눴습니다. 하지만 지금은 함수만 살아 남았습니다. 어떤 프로그램이든 가장 기본적인 단위가 함수입니다. 작게 만들어라! 함수를 만드는 첫째 규칙은  입니다. 함수를 만드는 둘째 규칙은  입니다. 이 규칙은 근거를…","fields":{"slug":"/clean code/clean-code-3장-함수/"},"frontmatter":{"date":"March 03, 2020","title":"clean code 3장 함수","category":"clean code","draft":false}}},{"node":{"excerpt":"추천사 5S 원칙 정리(Seiri) 또는 조직(정럴(sort)) 적절한 명명법 등과 같은 방법을 사용해 무엇이 어디에 있는지 알아야 합니다. 정돈(Seiton) 또는 단정함(체계화) “물건마다 모두 제자리 가 있다”라는 속담이 있습니다. 코드는 누구나 예상히는 위치에 있어야 합니다. 그렇지 않으면 다시 정돈해 누구나 예상하는 위치로 옮겨야 합니다. 청소(…","fields":{"slug":"/clean code/clean-code-추천사-및-0장/"},"frontmatter":{"date":"March 03, 2020","title":"clean code 추천사 및 0장 들어가면서","category":"clean code","draft":false}}},{"node":{"excerpt":"코드가 존재하리라 코드는 요구사항을 표현하는 언어라는 사실을 명심해야 합니다. 요구사항에 더욱 가까운 언어를 만들 수도 있고, 요구사항에서 정형 구조를 뽑아내는 도구를 만들 수도 있습니다. 하지만 어느 순간에는 정밀한 표현이 필요합니다. 그 필요성을 없앨 방법은 없습니다. 그러므로 코드도 항상 존재 합니다. 코드에 관한 책은 구시대적이고, 곧 명세를 기준…","fields":{"slug":"/clean code/clean-code-1장-깨끗한-코드/"},"frontmatter":{"date":"March 03, 2020","title":"clean code 1장 깨끗한 코드","category":"clean code","draft":false}}},{"node":{"excerpt":"Repository는 하나의 도메인에 관련 된 것들을 컨트롤 합니다. 하나의 도메인에는 여러개의 테이블이 존재할 수 있습니다. REPOSITORY는 메모리에 로드된 객체 컬렉션에 대한 집합 처리를 위한 인터페이스를 제공합니다. DAO(Data Access Object)는 하나의 테이블에 관련 된 것들을 컨트롤 합니다. Entity Bean을 대체하기 위한…","fields":{"slug":"/develop/repository와-dao/"},"frontmatter":{"date":"February 24, 2020","title":"repository와 DAO","category":"develop","draft":false}}},{"node":{"excerpt":"SYNC / ASYNC return 한다면 SYNC, callback으로 응답한다면 ASYNC 입니다. Synchronous / Asynchronous는 호출되는 함수의 작업 완료 여부를 누가 신경쓰냐가 관심사 입니다. SYNC : 서브루틴이 즉시 값을 반환 합니다. 이벤트를 자신이 직접 처리 합니다.(확인의 주체가 유저 프로세스이며, 다 될때까지 기다리…","fields":{"slug":"/develop/동기-비동기/"},"frontmatter":{"date":"February 24, 2020","title":"동기 비동기","category":"develop","draft":false}}},{"node":{"excerpt":"tsconfig 파일 작성 esModuleInterop을 설정하지 않고 module.exports와 export default를 다르게 import 한다. module.exports 를 사용해서 import 해야한다. scripts 작성 webpack 적용 nodeExternals를 사용하지 않으면 웹팩에서 에러가 발생한다. 왜인지는 아직 잘 모르겠다… …","fields":{"slug":"/typescript/node-javascript에서-typescript로-바꾸기/"},"frontmatter":{"date":"February 22, 2020","title":"Node javascript에서 typescript로 바꾸기","category":"typescript","draft":false}}},{"node":{"excerpt":"XSS 란? Cross Site Scripting의 약자로 CSS라고 하는 것이 맞지만 Cascading Style Sheets의 약어로 사용되어 있어 XSS라고 합니다. XSS 게시판이나 웹 메일 등에 자바스크립트 같은 스크립트 코드를 삽입 해 개발자가 고려하지 않은 기능이 작동하게 하는 치명적일 수 있는 공격 입니다. 대부분의 웹 해킹 공격 기법과는 …","fields":{"slug":"/frontend/xss/"},"frontmatter":{"date":"February 21, 2020","title":"XSS","category":"frontend","draft":false}}},{"node":{"excerpt":",  두 속성을 이용해서 html 수정을 허용 할 수 있습니다.","fields":{"slug":"/frontend/html-edit/"},"frontmatter":{"date":"February 21, 2020","title":"html edit","category":"frontend","draft":false}}},{"node":{"excerpt":"Circular dependency 소프트웨어 엔지니어링 하는 순환 종속성은 직접 또는 간접적으로 제대로 작동 서로 의존 두개 또는 그 이상의 모듈들 간의 관계입니다. 이러한 모듈은 상호 재귀 라고도 합니다. 무조건 터지느건 아니고 컨스트럭터 이전에 생성을 하기 위해 참조하던 것이 생성하고 있는 중인 것을 참조해서 터지는 경우가 발생했습니다. 이를 끊어내…","fields":{"slug":"/javascript/순환-의존성/"},"frontmatter":{"date":"February 21, 2020","title":"순환 의존성","category":"javascript","draft":false}}},{"node":{"excerpt":"메타태그의 뷰포트 속성에 을 추가 CSS 추가 하단에 플로팅된 버튼과 아이폰 홈 버튼의 간격이 겹쳐 간격을 주고 싶을때 IOS에서 11.2 업데이트시 constant속성을 없애고 env로 정의하도록 변경이 되었다. 하지만 업데이트 안한 유저들이 있어 두번째, 세번째 라인 모두 추가해야 구, 신기종을 전부 대응할 수 있다. 구버전 대응시 env값을 + 10…","fields":{"slug":"/frontend/아이폰-홈인디케이터/"},"frontmatter":{"date":"February 21, 2020","title":"아이폰 홈인디케이터","category":"frontend","draft":false}}},{"node":{"excerpt":"","fields":{"slug":"/javascript/월의-시작과-끝/"},"frontmatter":{"date":"February 21, 2020","title":"월의 시작과 끝","category":"javascript","draft":false}}},{"node":{"excerpt":"자바스크립트에는 유사배열이라는 것이 존재 합니다. 배열과 유사배열을 구분해야 하는 이유는, 유사배열의 경우 배열의 메서드를 쓸 수 없기 때문입니다. 나 로 확인 할 수 있습니다. 유사배열들 유사배열에서 배열 메서드 사용하기 출처 배열과 유사배열","fields":{"slug":"/frontend/유사배열/"},"frontmatter":{"date":"February 19, 2020","title":"유사배열","category":"frontend","draft":false}}},{"node":{"excerpt":"assign 객체 안에 배열 함수에서 활용 freeze","fields":{"slug":"/javascript/배열-복사/"},"frontmatter":{"date":"February 15, 2020","title":"복사","category":"javascript","draft":false}}},{"node":{"excerpt":"마우스를 올리면 텍스트 밑에 밑줄을 긋는다거나 배경색을 바꾸는 효과를 줄때가 있다. 하지만 모바일에서는 호버 이벤트가 없다 하지만 이를 위해 action 가상 선택자를 통해 클릭 시 효과를 주는 것으로 통일성을 맞춰 나가는거 같다. 하지만 호버 이벤트를 모바일 사이즈에서 없애지 않는다면 클릭 후 색이 남는 현상이 발생 했다. 이벤트 주기 호버 이벤트를 지…","fields":{"slug":"/frontend/hover/"},"frontmatter":{"date":"February 14, 2020","title":"hover","category":"frontend","draft":false}}},{"node":{"excerpt":"스크롤 되는 영역에 그라데이션을 넣어야 했다. 아래 영역에서 before과 absolute를 이용해서 스크롤 되는 리스트 하단에 항상 그라데이션을 넣는 것에는 성공했다. 하지만 그 영역에서 스크롤 되지 않았다. 그냥 보기엔 리스트의 영역처럼 보이지만 실제론 아래 영역 안에 포함된 곳이기 때문에 스크롤이 되지 않는 것이 어찌보면 당연히 맞다. 이를 해결하기…","fields":{"slug":"/frontend/pointer-events/"},"frontmatter":{"date":"February 13, 2020","title":"pointer events","category":"frontend","draft":false}}},{"node":{"excerpt":"이미지를 업로드 하는 경우에 로컬에서는 문제가 없었으나 호스팅한 서버에서는 를 반환했습니다. 413 Request Entity Too Large는 nginx에서 업로드한 파일의 용량이 제한 수치를 넘겨서 발생 했습니다. 로컬에선 nginx를 사용하지 않고 호스팅 된 서버에서는 80포트를 8080포트로 옮겨주기 위해 사용했습니다. 해결 방안 nginx 서버…","fields":{"slug":"/backend/413-request-entity-too-large/"},"frontmatter":{"date":"February 13, 2020","title":"413 Request Entity Too Large","category":"backend","draft":false}}},{"node":{"excerpt":"객체 생성 패턴 네임스페이스 패턴 쉽게 구현할 수 있는 패턴이며 전역변수의 개수를 줄이고, 변수명이 불필요하게 길어짐을 방지한다. 전역 네임스페이스 객체는 흔히 대문자로 선언한다. 이 패턴의 단점은 다음과 같다. 모든 변수와 함수에 접두어를 붙이므로, 전체 코드량이 길어져 다운로드 파일의 크기가 증가 전역 인스턴스가 1개이기 떄문에 부분이 수정되면 다른 …","fields":{"slug":"/javascript/객체-생성-패턴/"},"frontmatter":{"date":"February 12, 2020","title":"객체 생성 패턴","category":"javascript","draft":false}}},{"node":{"excerpt":"HTTP/1은 하나의 TCP 연결에 하나의 요청만 처리하고 연결을 끊어버렸기 때문에 매 요청마다 이 번거로운 핸드쉐이크를 거쳐야 했습니다. HTTP/2에서는 핸드쉐이크를 최소화하기 위해서 단일 TCP 연결을 유지하면서 여러 개의 요청을 처리할 수 있도록 변경 되었습니다. 결국 HTTP/1에서 HTTP/2로 넘어갈 때도 핸드쉐이크 과정 자체는 건드리지 않았…","fields":{"slug":"/frontend/http/"},"frontmatter":{"date":"February 11, 2020","title":"http","category":"frontend","draft":false}}},{"node":{"excerpt":"react에서 function으로 만들어진 component에는 4가지 타입이 있었습니다. FC, SFC, FunctionComponent, StatelessComponent 하지만 hooks로 인해서 function component에서도 state를 사용할 수 있게 되어 SFC와 StatelessComponent가 deprecated 되었습니다.","fields":{"slug":"/react/function-component-type/"},"frontmatter":{"date":"February 10, 2020","title":"function component type","category":"react","draft":false}}},{"node":{"excerpt":"TCP 연결형 서비스 가상 회선 방식 전송 순서 보장 신뢰성 높음 전송 속도 느림 http/1과 http/2는 TCP를 사용 UDP 비연결형 서비스 데이터그램 방식 전송 순서 보장 하지 않음 신뢰성 낮음 전송 속도 빠름 http/3는 UDP를 사용 커스터마이징이 용이하다","fields":{"slug":"/develop/tcp-udp/"},"frontmatter":{"date":"February 09, 2020","title":"TCP UDP","category":"frontend","draft":false}}},{"node":{"excerpt":"","fields":{"slug":"/frontend/input-number/"},"frontmatter":{"date":"February 08, 2020","title":"input number","category":"frontend","draft":false}}},{"node":{"excerpt":"위와 같이 타입을 바꿀 때 as를 사용 가능 위과 같이 사용할 땐 is를 사용 위의 is와 관련 된 문법엔 오류가 많다(자바랑 섞어 쓰기도 하고)","fields":{"slug":"/kotlin/kotlin-is-and-as/"},"frontmatter":{"date":"February 07, 2020","title":"kotlin is and as","category":"kotlin","draft":false}}},{"node":{"excerpt":"JVM은 자바 가상머신(Java Virtual Machine)의 약자입니다. JRE는 자바 실행환경(Java Runtime Environment)의 약자입니다. JDK JDK는 자바 개발도구(Java Development Kit)의 약자입니다. JDK는 JRE + 개발을 위해 필요한 도구(javac, java등)들을 포함합니다. v8은 jvm가 아니라 j…","fields":{"slug":"/java/jre-jvm/"},"frontmatter":{"date":"February 06, 2020","title":"JRE JVM","category":"java","draft":false}}},{"node":{"excerpt":"String a = “”로 생성하는건 String pool을 할당하는거고 내부적으로 intern()이라는 코드를 통해 상수풀에 값을 올립니다. 이미 존재하는 값이라면 값을 주소를 리턴하는 것을 보장합니다. “hello” + “world”와 같은 동작도 String pool을 할당받은 동작을 하는 것이기 때문에 a==e 는 true 입니다. “문자열” + …","fields":{"slug":"/java/java-string/"},"frontmatter":{"date":"February 05, 2020","title":"Java String","category":"java","draft":false}}},{"node":{"excerpt":"마진병합현상의 조건 인접해있는 Block요소끼리만 일어납니다. 상하단만 해당 됩니다. 레이아웃을 더 보기 좋게 하기 위한 좋은 기능이다. 하지만 원하는 바와 다르게 적용 될 수도 있다. 마진병합을 방지하는 방법 부모에 margin이 0 auto여서 wrapper와 자식의 마진이 사라졌을 경우 부모에 padding: 1px을 줍니다. 부모에 border: …","fields":{"slug":"/frontend/마진-병합/"},"frontmatter":{"date":"February 04, 2020","title":"마진 병합","category":"frontend","draft":false}}},{"node":{"excerpt":"ES2015(ES6)에서 자바스크립트에 클래스(Class)가 도입되었습니다. 자바스크립트는 기본적으로 프로토타입 기반의 언어입니다. 프로토타입 기반으로 객체 지향적으로 설계하는 것이 복잡하여 클래스라는 sugar syntax 문법이 도입된 것입니다. Java에서의 클래스와 똑같은 기능을 한다고 생각 할 수 있지만 여전히 객체 지향을 흉내내고 있고 그 내부…","fields":{"slug":"/javascript/javascript-class/"},"frontmatter":{"date":"February 03, 2020","title":"JavaScript Class","category":"javascript","draft":false}}},{"node":{"excerpt":"Hook가 React 버전 16.8에 새로 추가되었습니다. Hook를 이용하여 Class를 작성할 필요 없이 상태 값과 여러 React의 기능을 사용할 수 있습니다. 하지만 React에서 Class를 제거할 계획은 없습니다. Hook은 알고 있는 React 컨셉을 대체하지 않습니다. 대신에, Hook는 props, state, context, refs, …","fields":{"slug":"/react/react-hook/"},"frontmatter":{"date":"February 02, 2020","title":"React Hook","category":"react","draft":false}}},{"node":{"excerpt":"3.0 새로운 개념의 프로젝트 참조가 도입되었습니다. 프로젝트 참조를 통해 TypeScript 프로젝트는 다른 TypeScript 프로젝트에 의존 할 수 tsconfig.json있습니다. 특히 파일이 다른 tsconfig.json파일 을 참조 할 수 있습니다. 이러한 종속성을 지정하면 TypeScript가 빌드 순서 및 출력 구조를 이해할 수 있는 방법을…","fields":{"slug":"/typescript/TypeScript 버전에 따른 변경점/"},"frontmatter":{"date":"February 01, 2020","title":"TypeScript 버전에 따른 변경점","category":"typescript","draft":false}}},{"node":{"excerpt":"부트스트랩 쉽고 빠르며 다양한 기능들을 제공합니다. 다양한 디자인과 동적인 효과를 사용할 수 있습니다. 모바일 환경과 반응형 웹 제작에 유리하게 사용할 수 있습니다. 높은 퀄리티가 보장이 되기 때문에 시간을 단축하며 그로 인해 비용이 절감 됩니다. jQuery에 의존성이 강합니다(부트스트랩 5가 되면서 jQuery를 제거 했다고 합니다) 정형화되어 있어 …","fields":{"slug":"/frontend/오픈소스-ui-kit들의-장단점/"},"frontmatter":{"date":"January 31, 2020","title":"오픈소스 UI Kit들의 장단점","category":"frontend","draft":false}}},{"node":{"excerpt":"","fields":{"slug":"/frontend/flexbox/"},"frontmatter":{"date":"January 30, 2020","title":"flexbox","category":"frontend","draft":false}}},{"node":{"excerpt":"background CSS 단축 속성은 색상, 이미지, 원점, 크기, 반복 등 여러 배경 스타일을 한 번에 지정합니다. background: background-color | background-image | background-repeat | background-attachment | background-position background: #12345…","fields":{"slug":"/frontend/background/"},"frontmatter":{"date":"January 29, 2020","title":"background","category":"frontend","draft":false}}},{"node":{"excerpt":"position static : 기본값, 다른 태그와의 관계에 의해 자동으로 배치되며 위치를 임의로 설정해 줄 수 없습니다. 움직이지 않고 정적인 상태입니다. relative : 원래 있던 위치를 기준으로 좌표를 지정합니다. 부모 엘리먼트를 기준으로 상대적으로 움직입니다. absolute : 절대 좌표와 함께 위치를 지정해 줄 수 있습니다. positio…","fields":{"slug":"/frontend/position-속성과-offset/"},"frontmatter":{"date":"January 28, 2020","title":"position 속성과 Offset","category":"frontend","draft":false}}},{"node":{"excerpt":"유니온(Union)타입 유니온 타입은 하나의 프로퍼티에 다양한 변수가 올 수 있는 타입을 말합니다. keyof 키워드 keyof 키워드는 타입 값에 존재하는 모든 프로퍼티의 키값을 union 형태로 리턴 받습니다. never 타입 never는 에러가 발생했을 때 프로세스를 중단시키지 않고 무시하는 타입입니다. any를 제외한 다른 모든 타입의 원시 타입으…","fields":{"slug":"/typescript/typescript-헬터-타입/"},"frontmatter":{"date":"January 27, 2020","title":"typescript 헬터 타입","category":"typescript","draft":false}}},{"node":{"excerpt":"prototype을 사용하여 class를 구현하는 방법 prototype을 사용하여 상속을 구현 일반적으로 클래스를 만들면 자동으로 prototype의 constructor라는 프로퍼티가 만들어집니다. 이 프로퍼티에는 해당 클래스의 생성자 정보가 기본값으로 담기게 됩니다. 달리 말하면 constructor 프로퍼티를 이용해 사용하는 객체가 어떤 클래스의 …","fields":{"slug":"/javascript/javascript에서-클래스를-구현하는-방법,-상속하는-방법/"},"frontmatter":{"date":"January 27, 2020","title":"javascript에서 클래스를 구현하는 방법, 상속하는 방법","category":"javascript","draft":false}}},{"node":{"excerpt":"screen.height 화면의 세로 크기를 가져옵니다. screen.availHeight 브라우저의 막대를 포함하여 최대화 된 경우 브라우저의 윈도우가 가질 수 있는 높이입니다. 창이 최대화되면 screen.availHeight === window.outerHeight 작업 표시줄이 차지하는 부분을 제외한 세로 크기를 가져옵니다. 화면 아래의 작업 표시…","fields":{"slug":"/frontend/height/"},"frontmatter":{"date":"January 26, 2020","title":"height","category":"frontend","draft":false}}},{"node":{"excerpt":"HTML부터 React까지의 제가 알고 있는 웹 프론트엔드 흐름에 대해 정리를 해보고자 합니다. 웹은 HTML, CSS, Javascript로 구성되어 있습니다. DART나 KOTLIN.JS, 웹어셈블리 등이 웹을 지원하기는 한다고 합니다. HTML 가장 먼저 HTML은 HyperText Markup Language로 웹페이지를 기술하기 위한 마크업 언어…","fields":{"slug":"/frontend/web-frontend/"},"frontmatter":{"date":"January 24, 2020","title":"WEB FRONTEND","category":"frontend","draft":false}}},{"node":{"excerpt":"자바스크립트로 doublyLinkedList 구현하기 참조 데이터 스트럭쳐란 무엇인가? codingeverybody/datastructurejava","fields":{"slug":"/javascript/doublylinkedlist/"},"frontmatter":{"date":"January 24, 2020","title":"doublyLinkedList","category":"javascript","draft":false}}},{"node":{"excerpt":"자바스크립트로 linkedList 구현하기 참조 데이터 스트럭쳐란 무엇인가? codingeverybody/datastructurejava","fields":{"slug":"/javascript/linkedlist/"},"frontmatter":{"date":"January 24, 2020","title":"linkedList","category":"javascript","draft":false}}},{"node":{"excerpt":"자바스크립트로 arrayList 구현하기 참조 데이터 스트럭쳐란 무엇인가? codingeverybody/datastructurejava","fields":{"slug":"/javascript/arraylist/"},"frontmatter":{"date":"January 24, 2020","title":"arrayList","category":"javascript","draft":false}}},{"node":{"excerpt":"모바일과 PC 웹브라우저의 scroll 모바일 웹을 작업하고 있는데 스크롤을 구현하는게 상당히 골치가 아픕니다. 스크롤은 어디나 들어가는 아주 일반적인 기능이라고 생각하고 있었음에도 구현하는데 여러가지 어려움이 상당히 많습니다. 스크롤 스크롤 영역으로 지정하는 것은 딱히 모바일 웹에 특화된 것은 아닙니다. 스크롤을 사용할 곳의 크기를 지정하고 CSS 속성…","fields":{"slug":"/frontend/scroll/"},"frontmatter":{"date":"January 24, 2020","title":"scroll","category":"frontend","draft":false}}},{"node":{"excerpt":"모바일과 PC 웹브라우저의 viewport 차이 meta viewport 태그는 애플이 아이폰, 아이패드 등 자사의 모바일 브라우저의 뷰포트(viewport) 크기 조절을 위해 만들었습니다. viewport란 우리말로 보임참, 즉 화면 상의 표시 영역을 뜻합니다. 화면의 보여지는 영역과 viewport는 차이가 있는데, viewport는 그림을 그리기 위…","fields":{"slug":"/frontend/viewport/"},"frontmatter":{"date":"January 23, 2020","title":"viewport","category":"frontend","draft":false}}},{"node":{"excerpt":"npm 의존성관리 javascript 패키지 매니저 java에 gradle , php의 composer 와 같은 역할을 한다. npm은 node의 모듈을 관리해주는 패키지 매니저입니다. node.js를 설치하면 내장(built in)되어 있습니다. npm -v를 통해 버전을 확인할 수 있습니다. npm install 명령으로 외부 모듈 패키지를 설치합니다…","fields":{"slug":"/javascript/javascript-패키지-매니저/"},"frontmatter":{"date":"January 22, 2020","title":"javascript 패키지 매니저","category":"javascript","draft":false}}},{"node":{"excerpt":"package.json 파일을 작성할 때에는 JavaScript의 객체 리터럴이 아니라 올바른 JSON 포맷이어야 합니다. npm init 명령어를 통해 package.json 파일을 만들 수 있습니다. -y 옵션을 사용해서 빠르게 생성 할 수도 있습니다. name 필수로 입력되어야 하며 이 항목들이 누락되면 패키지를 설치할 수 없습니다. name은 반드…","fields":{"slug":"/javascript/package.json/"},"frontmatter":{"date":"January 21, 2020","title":"package.json","category":"javascript","draft":false}}},{"node":{"excerpt":"서버 사이드 템플릿 시대를 지나 단일 페이지 애플리케이션(Single Page Application, SPA) 개발이 점차 인기를 얻으면서 자바스크립트의 코드량이 과거에 비해 기하급수적으로 증가하게 되었습니다. 많게는 수천, 수만 줄이나 하는 자바스크립트 코드에서 특정 코드를 찾아 수정하기란 쉽지 않은 일입니다. 그래서, 개발 초기 단계에서 API 기능과…","fields":{"slug":"/javascript/웹팩4(webpack)-설정하기/"},"frontmatter":{"date":"January 20, 2020","title":"웹팩4(Webpack) 설정하기","category":"javascript","draft":false}}},{"node":{"excerpt":"react와 styled-components를 이용해서 퍼센트에 따라 원을 그리는 컴포넌트를 만들었습니다.","fields":{"slug":"/react/퍼센트-원-그리기/"},"frontmatter":{"date":"January 19, 2020","title":"퍼센트 원 그리기","category":"react","draft":false}}},{"node":{"excerpt":"리액트는 배열을 렌더링 할 때 값을 통하여 업데이트 성능을 최적화 합니다. 기본적으로 DOM 노드의 자식에 대해 반복 할 때 React는 두 자식 목록을 동시에 반복하고 차이가 있을 때마다 돌연변이를 생성합니다.(virtual dom diff를 써서 확인) 이 문제를 해결하기 위해 React는 key속성을 지원 합니다. 자식에 키가 있으면 React는이 …","fields":{"slug":"/react/리액트에서-key를-사용하는-이유/"},"frontmatter":{"date":"January 18, 2020","title":"리액트에서 key를 사용하는 이유","category":"react","draft":false}}},{"node":{"excerpt":"프로토타입 기반 프로그래밍은 객체지향 프로그래밍의 한 형태의 갈래로 클래스가 없고, 클래스 기반 언어에서 상속을 사용하는 것과는 다르게, 객체를 원형(프로토타입)으로 하여 복제의 과정을 통하여 객체의 동작 방식을 다시 사용할 수 있습니다. 프로토 타입 역할을 하는 delegation을 통해 기존 객체를 재사용하는 프로세스를 통해 동작 재사용(상속)을 수행…","fields":{"slug":"/javascript/프로토타입-기반의-객체지향/"},"frontmatter":{"date":"January 17, 2020","title":"프로토타입 기반의 객체지향","category":"javascript","draft":false}}},{"node":{"excerpt":"V8이란? 독일 구글 개발 센터에서 만들어진 JavaScript 엔진입니다. 웹 브라우저 안에서 실행되는 JavaScript의 성능을 높이기 위해 처음 고안되었습니다. 오픈 소스이고 C++로 작성되었습니다. 구글 크롬과 Node.js의 런타임에서 사용 중입니다. 속도를 높이기 위해서 V8은 인터프리터를 이용하는 대신 기계어 코드로 번역합니다. JIT(Ju…","fields":{"slug":"/frontend/v8-엔진의-동작-원리/"},"frontmatter":{"date":"January 14, 2020","title":"V8 엔진의 동작 원리","category":"frontend","draft":false}}},{"node":{"excerpt":"가장 먼저 CSS transition 속성을 이용해서 아코디언 애니메이션을 구현했습니다. CSS를 수정하지 않고 애니메이션 구현하기 window.requestAnimationFrame 함수를 사용해서 구현했습니다. 애니메이션을 모두 기다린 후에 클릭을 하면 잘 작동하지만 애니메이션 도중 클릭을 할 경우 제대로 작동하지 않고 다시 클릭 했을 때 2번 작동 …","fields":{"slug":"/frontend/라이브러리-없이-애니메이션-구현하는-방법/"},"frontmatter":{"date":"January 14, 2020","title":"라이브러리 없이 애니메이션 구현하는 방법","category":"frontend","draft":false}}}]}},"pageContext":{}}}