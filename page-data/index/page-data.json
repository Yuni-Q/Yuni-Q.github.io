{"componentChunkName":"component---src-pages-index-js","path":"/","result":{"data":{"site":{"siteMetadata":{"title":"yuni-q 블로그","configs":{"countOfInitialPost":10}}},"allMarkdownRemark":{"edges":[{"node":{"excerpt":"","fields":{"slug":"/frontend/blur-처리/"},"frontmatter":{"date":"June 29, 2020","title":"blur 처리","category":"frontend","draft":false}}},{"node":{"excerpt":"창을 닫을 때 현재 활성화 되어 있는 포커스 제거합니다. alert 사용 시 chrom에서는 정상 작동하지 않습니다.","fields":{"slug":"/frontend/close-event/"},"frontmatter":{"date":"June 29, 2020","title":"close event","category":"frontend","draft":false}}},{"node":{"excerpt":"1. 문자열 뒤집기 2. 자바스크립트 배열 비우기 3. 숫자가 정수인지 확인하기 4. 콜백 함수란? callback함수는 인수로 다른 함수로 전달되고, 일부 동작이 완료된 후에 수행되는 함수입니다. 5. anagrams 6. 다음 코드의 결과는 무엇입니까? 7. 다음 코드는 무엇을 출력합니까? 8. 다음 코드는 무엇을 출력합니까? 9. palindrome…","fields":{"slug":"/javascript/자바스크립트-코딩-기술-10가지/"},"frontmatter":{"date":"June 28, 2020","title":"자바스크립트 코딩 기술 10가지","category":"javascript","draft":false}}},{"node":{"excerpt":"ie11에서 max-width가 동작하지 않는다. position: absolute; left: 0;으로 해결","fields":{"slug":"/frontend/ie11-max-width/"},"frontmatter":{"date":"June 26, 2020","title":"ie11 max-width","category":"frontend","draft":false}}},{"node":{"excerpt":"자바스크립트에서 클래스란? ES2015부터 class 키워드를 지원하기 시작했으나, 문법적인 양념일 뿐이며 자바스크립트는 여전히 프로토타입 기반의 언어다. https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain JavaScript class는…","fields":{"slug":"/javascript/class/"},"frontmatter":{"date":"May 27, 2020","title":"Class","category":"javascript","draft":false}}},{"node":{"excerpt":"REST API를 사용할 때는 cURL 옵션 중 몇 가지를 꼭 알아두는 것이 좋습니다. -i: 응답 헤더 출력 (옵션 없으면 응답 본문만 출력함) -v: 중간 처리 과정, 오류 메시지, 요청 메시지와 응답 메시지를 헤더와 본문을 포함해 전체 출력 -X: 요청 메소드를 지정 (옵션 없으면 기본값은 GET) -H: 요청 헤더를 지정 -d: 요청 본문을 지정 …","fields":{"slug":"/develop/curl/"},"frontmatter":{"date":"May 25, 2020","title":"CURL","category":"develop","draft":false}}},{"node":{"excerpt":"find 첫번째 대괄호 안의 조건으로 두번째 대관호 안에 값이 1이나 true인 필드를 가져옵니다. 정렬 가능헙니다.( -1은 내림차순 ) limit와 skip도 사용 가능합니다. update update는 set을 사용합니다. remove 삭제 mongoose가 mongoDB에는 mongoose가 있습니다. mysql의 시퀄라이즈와는 달리 ORM이 아니…","fields":{"slug":"/backend/mongo/"},"frontmatter":{"date":"May 25, 2020","title":"mongo","category":"backend","draft":false}}},{"node":{"excerpt":"","fields":{"slug":"/develop/a-+-b/"},"frontmatter":{"date":"May 25, 2020","title":"A + B","category":"develop","draft":false}}},{"node":{"excerpt":"폴링 : 주기적으로 서버에게 요청 SSE : 한번 연결 하면 서버가 단방향 통신 웹 소켓 : 한번 연결 하면 양방향 통신","fields":{"slug":"/develop/폴링-vs-see-vs-웹소켓/"},"frontmatter":{"date":"May 25, 2020","title":"폴링 vs SEE vs 웹소켓","category":"develop","draft":false}}},{"node":{"excerpt":"zsh 버전 확인 zsh가 없다면 설치 bash를 zsh로 변경 재로그인하거나 터미널을 종료하고 재시작한 후 기본 쉘이 zsh인 것을 확인한다. 일부 시스템 특히 OS X에서는 /etc/shells 파일에 설치한 쉘을 등록한 후에 재시작해야 합니다. oh-my-zsh 설치 iTerm2 iTerm2 에서 다운로드 하거나, Homebrew 를 통해 다운 받는…","fields":{"slug":"/develop/terminer-setting/"},"frontmatter":{"date":"May 25, 2020","title":"Terminer Setting","category":"develop","draft":false}}},{"node":{"excerpt":"pwd : 현재 위치 cd (directory) : change directory mkdir (폴더명) : 폴더 생성 touch (파일명) : 파일 생성 sudo (명령어) : root 권한 rm -rf (폴더명 or 파일명) : 모든 하위 폴더와 파일을 포함하여 삭제 ls : 현재 디렉토리에 파일 및 폴더 표시 ls -a : 숨김 파일도 표시 ls -l…","fields":{"slug":"/develop/terminer-명령어/"},"frontmatter":{"date":"May 25, 2020","title":"Terminer 명령어","category":"develop","draft":false}}},{"node":{"excerpt":"크롬에서 로컬 호스트로 접속한 경우 IP가 ::1 로 뜹니다.","fields":{"slug":"/backend/클라이언트-ip-알아내기/"},"frontmatter":{"date":"May 25, 2020","title":"클라이언트 IP 알아내기","category":"backend","draft":false}}},{"node":{"excerpt":"multer single, array, fields single은 하나의 이미지를 업로드 ( req.file ) array와 fields는 여러개의 미미지를 업로드 ( req.files ) body 속성 하나에 이미지를 여러개 업로드 array 여러개의 속성에 이미지를 하나씩 업로드 fields none은 이미지를 올리지 않고 데이터만 multipart …","fields":{"slug":"/backend/image-올리기/"},"frontmatter":{"date":"May 25, 2020","title":"image 올리기","category":"backend","draft":false}}},{"node":{"excerpt":"혹은 proxy-adddr 패키지 사용 크롬에서 로컬 호스트로 접속한 경우 IP가 ::1 로 뜹니다.","fields":{"slug":"/frontend/클라이언트-ip-알아내기/"},"frontmatter":{"date":"May 16, 2020","title":"클라이언트 IP 알아내기","category":"frontend","draft":false}}},{"node":{"excerpt":"MySQL, PostgreSQL, SQLite, SQL Server 중 PostgreSQL 과 SQLite 만 ‘a’와 ‘a ‘를 다른 값으로 평가합니다. 이유 : 비교하려는 두 문자열의 길이가 다른 경우, 짧은 쪽에 공백을 이어붙여 길이를 똑같이 만든 다음 비교하기 때문에 발생합니다. MySQL은 CHAR와 VARCHAR 모두 PAD 방식으로 비교합니다…","fields":{"slug":"/backend/MySQL에서 'a' = 'a '가 true로 평가된다?/"},"frontmatter":{"date":"May 15, 2020","title":"MySQL에서 'a' = 'a '가 true로 평가된다?","category":"backend","draft":false}}},{"node":{"excerpt":"코드를 사용해 이벤트를 직접 생성하려면 먼저 이벤트 객체를 만들어야 합니다. 범용적으로 쓰이는 Event(name, options) 클래스의 생성자는 임의의 이벤트 이름과 두 개의 프로퍼티가 있는 options라는 객체를 받습니다. bubbles: true 이면 이벤트는 버블링됩니다. cancelable: true 이면 event.preventDefaul…","fields":{"slug":"/frontend/커스텀-이벤트-디스패치/"},"frontmatter":{"date":"May 14, 2020","title":"커스텀 이벤트 디스패치","category":"frontend","draft":false}}},{"node":{"excerpt":"port 죽이기","fields":{"slug":"/develop/port/"},"frontmatter":{"date":"May 14, 2020","title":"port","category":"develop","draft":false}}},{"node":{"excerpt":"SQL 규칙에 맞는 데이터 입력 테이브 간 JOIN 지원 트랜잭션 지원 안정성, 일관성 용어 ( 테이블, 로우, 칼럼 ) NoSQL 자유로운 데이터 입력 컬랙션 간 JOIN 미지원 트랜잭션 미지원 확장성, 가용성 용어 ( 컬렉션, 다큐먼트, 필드 )","fields":{"slug":"/backend/sql-and-nosql/"},"frontmatter":{"date":"May 13, 2020","title":"SQL and NoSQL","category":"backend","draft":false}}},{"node":{"excerpt":"socket.to(소켓 아이디).emit(이벤트, 데이터) 나를 제외한 나머지 사람에게 메시지를 보내고 싶을 때는 socket.broadcast 객체를 이용합니다. to 메서드와 같이 사용하면 특정 방 안에서 나를 제외한 나머지에게 메시지를 보낼 수 있습니다. 나를 제외한 전체에게 메시지 보내기 socket.broadcast.emit(이벤트, 데이터); …","fields":{"slug":"/javascript/socket/"},"frontmatter":{"date":"May 12, 2020","title":"Socket","category":"javascript","draft":false}}},{"node":{"excerpt":"PM2는 Node.js 프로세스 관리 도구입니다. 자바스크립트는 싱글 스레드로 앱을 실행하지만 PM2는 Node.js의 Cluster 모듈을 사용해서 서버 앱에 복수의 인스턴스가 같은 포트를 사용하게 할 수 있도록 해줍니다. 이를 통해 사용량에 따라 CPU 점유율 늘리고 줄이면서 앱의 안정성을 높일 수 있습니다. PM2 ecosystem 파일 생성 PM2…","fields":{"slug":"/javascript/pm2/"},"frontmatter":{"date":"May 10, 2020","title":"PM2","category":"javascript","draft":false}}},{"node":{"excerpt":"Sequelize에서 Raw Query 사용 like 라이크 조건절은 두 가지 방법으로 사용합니다. 둘다 동일하게 동작합니다. lt, gt, lte, gte, between 값의 대소를 비교하는 경우 lt, gt, lte, gte를 사용합니다. Date.parse() 같은 날짜 함수를 사용할 수도 있습니다. 만약 구간을 검색할 경우 between 을 사용…","fields":{"slug":"/backend/sequelize/"},"frontmatter":{"date":"May 09, 2020","title":"Sequelize","category":"backend","draft":false}}},{"node":{"excerpt":"2.1 KISS(Keep It Simple, Stupid / Keep It Short and Simple) 오컴의 면도날 : 어떤 사항을 설명하는 데 필요 이상으로 많은 전제를 가정해서는 안된다는 사고방식 입니다. 코드를 작성할 때는 최우선 가치를 단순성과 간결성 입니다. 복잡한 코드는 일기 어렵고 수정하기 어려워집니다. 프로그래밍 중에도 코드가 동작할 …","fields":{"slug":"/프로그래밍 정석/2.-원칙:-프로그래밍의-가이드라인/"},"frontmatter":{"date":"May 08, 2020","title":"2. 원칙. 프로그래밍의 가이드라인","category":"프로그래밍 정석","draft":false}}},{"node":{"excerpt":"CSS 값에 대한 레벨 4 사양에서 완전히 인식하지 못한 몇 가지 새로운 단위가 있습니다. lh은 계산 된 값과 동일한 line-height, rlh는 루트 요소 (아마도의 동일 html요소)가 아닌 현재의 구성 요소의 line-height 입니다.","fields":{"slug":"/frontend/lh-and-rlh/"},"frontmatter":{"date":"May 08, 2020","title":"lh and rlh","category":"frontend","draft":false}}},{"node":{"excerpt":"3.1 프로그래밍 이론 좋은 프로그래머는 시간이 걸리더라도 언어, 도구, 기술, 문제 영역 등 분야를 막론하고 제대로 이해하고 나서 작업에 착수하는 경향이 있습니다. 제대로 이유를 설명할 수 있을 때까지 끈질기게 이해하고 나서 코드를 확정하도록 해야합니다. 3.2 의사소통 소프트웨어 개발 비용의 대부분은 최초 개발된 이후에 발생합니다. 즉, 유지보수에 드…","fields":{"slug":"/프로그래밍 정석/3.-사상:-프로그래밍의-이데올로기/"},"frontmatter":{"date":"May 08, 2020","title":"3. 사상. 프로그래밍의 이데올로기","category":"프로그래밍 정석","draft":false}}},{"node":{"excerpt":"1.1 프로그래밍에 은제 탄환은 없다 (No Silver Bullet in programming) 소프트웨어는 본질적으로 복잡성, 호환성, 변경 가능성, 비가시성(프로세스, 의사결정)이 4가지 성질 때문에 난해성을 가지고 있습니다. 이를 결과물로 하는 프로그래밍 작업 역시 난해해집니다. 상황이 복잡하고 문제가 너무 다방면에 걸쳐 있기 때문에 모든 것을 해…","fields":{"slug":"/프로그래밍 정석/1.-전체:프로그래밍-불변의-사실/"},"frontmatter":{"date":"May 08, 2020","title":"1. 전체:프로그래밍 불변의 사실","category":"프로그래밍 정석","draft":false}}},{"node":{"excerpt":"AWS EC2를 이용해 사이드 프로젝트를 진행하는 중 $273.11 달러의 요금 청구서가 날아왔습니다. Free Tier를 사용하고 있었기 때문에 과금 될 요소가 있지 않다고 생각했습니다. EC2, MYSQL, S3 사용 비용 발생 요인은 Data Transfer 입니다. $0.126 per GB - first 10 TB / month data trans…","fields":{"slug":"/aws/data-transfer/"},"frontmatter":{"date":"May 07, 2020","title":"data transfer","category":"aws","draft":false}}},{"node":{"excerpt":"ADP: 의존성 비순환 원칙(Acyclic Dependencies Principle) 컴포넌트 의존성 그래프에 순환(cycle)이 있어서는 안 됩니다. 동일한 소스파일을 수정하는 환경에서 동작되던 기능이 다른 사람으로 인해 동작하지 않을 때는 숙취 증후군이라고 부릅니다. 숙취 증후군을 해결하기 위해서 ADP 원칙을 사용합니다. 이상적인 구조는 비순환 방향…","fields":{"slug":"/clean architecture/14장-컴포넌트-결합/"},"frontmatter":{"date":"May 04, 2020","title":"14장 컴포넌트 결합","category":"clean architecture","draft":false}}},{"node":{"excerpt":"REP: 재사용/릴리즈 등가 원칙(Reuse/Release Equivalence Principle) 재사용 단위는 릴리즈 단위와 같습니다. 소프트웨어 컴포넌트가 릴리즈 절차를 통해 추적 관리되지 않거나 릴리즈 번호가 부여되지 않는다면 해당 컴포넌트를 재사용하고 싶어도 할 수도 없고 하지도 않을 것입니다. 릴리즈 번호가 없다면 재사용 컴포넌트들이 서로 호환…","fields":{"slug":"/clean architecture/13장-컴포넌트-응집도/"},"frontmatter":{"date":"May 04, 2020","title":"13장 컴포넌트 응집도","category":"clean architecture","draft":false}}},{"node":{"excerpt":"ISP: 인터페이스 분리 원칙 (Interface Segregation Principle) ISP를 아키텍처가 아니라 언어와 관련된 문제라고 결론 내릴 여지가 있습니다. 정적 타입언어는 사용자가 타입선언문을 사용하도록 강제합니다. 선언문으로 인해 소스 코드 의존성이 발생하고, 이로 인해 재컴파일 또는 재배포가 강제되는 상황이 무조건 초래됩니다. 하지만 동…","fields":{"slug":"/clean architecture/10장-isp-인터페이스-분리-원칙/"},"frontmatter":{"date":"May 04, 2020","title":"10장 ISP 인터페이스 분리 원칙","category":"clean architecture","draft":false}}},{"node":{"excerpt":"플러그인 아키텍처 1950년대 후반에 프로그램은 장치 독립적이어야 함을 발견하게 되었습니다. 당시에 장치에 의존적인 수많은 프로그램을 만들었고, 다른 장치에 프로그램이 필요하면 기존 프로그램에서 상당한 많은 부분을 재작성헸습니다. 입출력 장치 독립성을 지원하기 위해 만들어 졌고, 등장 이후 거의 모든 운영체제에서 구현 되었습니다. 의존성 역전 일반적인 상…","fields":{"slug":"/clean architecture/5장-객체-지향-프로그래밍/"},"frontmatter":{"date":"May 04, 2020","title":"5장 객체 지향 프로그래밍","category":"clean architecture","draft":false}}},{"node":{"excerpt":"불변성과 아키텍처 경합(race) 조건, 교착상태(deadlock) 조건, 동시성 업데이트(concurrent update) 문제가 모두 가변 변수로 인해 발생하기 때문에 아키텍트는 변수의 가변성을 염려합니다. 가변성의 분리 불변성과 관련하여 가장 중요한 타협 중 하나는 애플리케이션 내부에서 가변과 불변을 분리하는 것입니다. 이벤트 소싱 상태가 아닌 트랜…","fields":{"slug":"/clean architecture/6장-함수형-프로그래밍/"},"frontmatter":{"date":"May 04, 2020","title":"6장 함수형 프로그래밍","category":"clean architecture","draft":false}}},{"node":{"excerpt":"아키텍처란 아키텍처는 저수준의 세부사항과는 분리된 고수준의 무언가를 가리킬 때 사용합니다. 설계는 저수준의 구조 또는 결정사항들을 의미할 때가 많습니다. 하지만 실제로 이들을 구분 짖는 경계는 뚜렷하지 않습니다. 고수준에서 저수준으로 향하는 의사결정의 연속성만이 있을 뿐입니다. 저수준의 세부사항과 고수준의 구조는 모두 소프트웨어 전체 설계의 구성요소입니다…","fields":{"slug":"/clean architecture/클린-아키텍처-일부-요약/"},"frontmatter":{"date":"May 04, 2020","title":"클린 아키텍처 일부 요약","category":"clean architecture","draft":false}}},{"node":{"excerpt":"DIP: 의존성 역전 원칙 (Dependency Inversion Principle) 의존성 역전 원칙에서 말하는 유연성이 극대화된 시스템이란 소스 코드 의존성이 추상에 의존하여 구체에는 의존하지 않는 시스템입니다. 이 아이디어를 규칙으로 보기는 확실히 비현실적입니다. 소프트웨어 시스템이라면 구체적인 많은 장치에 반드시 의존하기 때문입니다. DIP를 논할…","fields":{"slug":"/clean architecture/11장-dip-의존성-역전-원칙/"},"frontmatter":{"date":"May 04, 2020","title":"11장 DIP 의존성 역전 원칙","category":"clean architecture","draft":false}}},{"node":{"excerpt":"SRP: 단일 책임 원칙 (Single Responsibility Principle) 단일 모듈은 변경의 이유가 하나. 오직 하나 뿐이어야 합니다. 변경의 이유 소프트웨어 시스템은 사용자와 이해관계자를 만족시키기 위해 변경됩니다. SRP가 말하는 변경의 이유는 바로 이들 사용자와 이해관계자를 가리킵니다. 단일 모듈 가장 단순한 정의는 소스파일입니다. 대부…","fields":{"slug":"/clean architecture/7장-srp-단일-책임-원칙/"},"frontmatter":{"date":"May 04, 2020","title":"7장 SRP 단일 책임 원칙","category":"clean architecture","draft":false}}},{"node":{"excerpt":"OCP: 개방-패쇄 원칙 (Open-Closed Principle) 소프트웨어 개체(artifact)는 확장에는 열려 있어야 하고, 변경에는 닫혀있어야 합니다. 소프트웨어 개체의 행위는 확장할 수 있어야 하지만, 이때 산출물을 변경해서는 안 됩니다. 소프트웨어 아키텍처를 공부하는 가장 근본적인 이유가 바로 이 때문입니다. 만약 요구사항을 살짝 확장하는 데…","fields":{"slug":"/clean architecture/8장-ocp-개방-폐쇄-원칙/"},"frontmatter":{"date":"May 04, 2020","title":"8장 OCP 개방 폐쇄 원칙","category":"clean architecture","draft":false}}},{"node":{"excerpt":"LSP: 리스코프 치환 원칙 (Liskov Substitution Principle) S타입의 객체 o1 각각에 대응하는 T타입 객체 o2가 있고, T타입을 이용해서 정의한 모든 프로그램 P에 o2의 자리에 o1을 치환하더라도 P의 행위가 변하지 않는다면, S는 T의 하위타입 입니다. LSP는 아키텍처 수준까지 확장할 수 있고, 반드시 확장 해야만 합니다…","fields":{"slug":"/clean architecture/9장-lsp-리스코프-치환-원칙/"},"frontmatter":{"date":"May 04, 2020","title":"9장 LSP 리스코프 치환 원칙","category":"clean architecture","draft":false}}},{"node":{"excerpt":"mapValues mapValues는 Object의 요소들을 순회하면서 주어진 함수의 평가결과를 value에 할당합니다. for…in를 대체할 수 있습니다. mapKeys mapKeys는 Object의 요소들을 순회하면서 주어진 함수의 평가결과를 key에 할당합니다. filterObject filterObject는 Object의 요소들을 순회하면서 주어진…","fields":{"slug":"/실용주의 프론트 엔드 개발/object/"},"frontmatter":{"date":"May 03, 2020","title":"Object","category":"실용주의 프론트 엔드 개발","draft":false}}},{"node":{"excerpt":"Array#reduce accumulator, acc reduce는 각 배열 요소를 주어진 함수의 결과와 누산하여 하나의 결과값을 반환합니다. Array#map map은 배열의 모든 요소를 주어진 함수의 결과로 변경한 새로운 배열을 반환합니다. Array#forEach forEach를 모든 배열을 순회합니다. 단순히 배열을 순회하는 for, while를 …","fields":{"slug":"/실용주의 프론트 엔드 개발/array/"},"frontmatter":{"date":"May 03, 2020","title":"Array","category":"실용주의 프론트 엔드 개발","draft":false}}},{"node":{"excerpt":"함수형 addDate subtractDate diffDay 객체지향 참고 Date","fields":{"slug":"/실용주의 프론트 엔드 개발/date/"},"frontmatter":{"date":"May 03, 2020","title":"Date","category":"실용주의 프론트 엔드 개발","draft":false}}},{"node":{"excerpt":"from join fromEntries 참고 Iterable","fields":{"slug":"/실용주의 프론트 엔드 개발/iterable/"},"frontmatter":{"date":"May 03, 2020","title":"Iterable","category":"실용주의 프론트 엔드 개발","draft":false}}},{"node":{"excerpt":"curry plucker partial pipe always switchCase switch…case문을 함수형으로 다루는 방법은 3가지가 있습니다. Function 함수로 구현하는 방법이 있지만 switchCase, case와 의존이 생기는 방식임으로 권하고 싶은 방식은 아닙니다. Array 2차원 배열에서 첫번째 아이템은 case를 두번째 아이템은 c…","fields":{"slug":"/실용주의 프론트 엔드 개발/high-order/"},"frontmatter":{"date":"May 03, 2020","title":"High Order","category":"실용주의 프론트 엔드 개발","draft":false}}},{"node":{"excerpt":"URL 유효성 배열 아이템 삭제 천단위 콤마 표시 정렬 Overlap Subset SVG Parser Throttle 연속적으로 콜백 실행 요청되어도, 지정된 시간 주기로 콜백이 실행하는 기법 Throttle 기법을 사용하면 일정한 시간을 주기로 콜백을 실행 할 수 있습니다. Debounce 다수의 이벤트 실행을 방지하기 위해 하나로 그룹화하여 특정 시간…","fields":{"slug":"/실용주의 프론트 엔드 개발/one-piece/"},"frontmatter":{"date":"May 03, 2020","title":"One Piece","category":"실용주의 프론트 엔드 개발","draft":false}}},{"node":{"excerpt":"async 함수 async 함수는 Promise를 반환합니다. 정상적인 동작으로 값을 반환하면 then에서 받을 수 있습니다. 비정상적인 동작으로 에러를 발생하면 catch에서 받을 수 있습니다. async에서 Promise 반환 async 함수의 반환값으로 Promise를 사용하면 호출자에서는 async 함수 사용과 동일하게 사용됩니다. resolve …","fields":{"slug":"/실용주의 프론트 엔드 개발/async-await-정리/"},"frontmatter":{"date":"May 03, 2020","title":"async await 정리","category":"실용주의 프론트 엔드 개발","draft":false}}},{"node":{"excerpt":"코루틴이란 코루틴은 실행 지점을 코드 블럭으로 저장하여, 해당 지점을 실행/중단/재시작을 하는 것을 말합니다. 자발적/주기적으로 유휴상태를 만들 수 있기 때문에 비선점 멀티태스킹이 가능합니다. 동시성과 병렬 처리가 가능합니다. 코루틴 사이의 전환은 컨텍스트 전환이 발생하지 않습니다. 컨텍스트 전환 기존의 프로세스의 상태 또는 레지스터값을 저장 후 다음 프…","fields":{"slug":"/실용주의 프론트 엔드 개발/코루틴을-사용한-지연-평가/"},"frontmatter":{"date":"May 03, 2020","title":"코루틴을 사용한 지연 평가","category":"실용주의 프론트 엔드 개발","draft":false}}},{"node":{"excerpt":"불변 자료 구조 - Immutable Data Structures 불변 자료 구조는 영원히 변하지 않는 상태를 말합니다. 변화가 필요할 때 새로운 상태를 만들어 내고 값을 변경합니다. 이전 상태는 사용하지 않으면 메모리 상에서 제거됩니다. clone을 사용한 예시 모두 새롭게 만들기 때문에 inner도 다른 객체가 됩니다. 영속 자료 구조 - Pesist…","fields":{"slug":"/실용주의 프론트 엔드 개발/영속-자료-구조(persistent-data-structures)/"},"frontmatter":{"date":"May 03, 2020","title":"영속 자료 구조(Persistent Data Structures)","category":"실용주의 프론트 엔드 개발","draft":false}}},{"node":{"excerpt":"Promise 상태 Promise의 상태는 대기, 이행, 거부 상태가 있습니다. 상태는 대기에서 이행/거부로만 변경이 가능합니다. 대기 : 초기상태 이행 : 성공 상태, resolve(), Promise.resolve() 거부 : 실패 상태, reject(), Promise.reject() 이행상태는 then으로 처리할 수 있습니다. resolve를 통해…","fields":{"slug":"/실용주의 프론트 엔드 개발/promise-정리/"},"frontmatter":{"date":"May 03, 2020","title":"Promise 정리","category":"실용주의 프론트 엔드 개발","draft":false}}},{"node":{"excerpt":"이벤트 정의 javascript와 HTML 간의 상호작용을 담당합니다. 옵져버 패턴으로 이벤트가 발생할 때만 리스너가 실행 됩니다. 이벤트 흐름 히스토리 DOM 이벤트 API는 DOM Level 2에서 논리적으로 표준화하려는 시도 입니다. DOM Level 2 개정전 IE와 Netscape가 서로 정반대 이벤트 흐름을 채택했습니다. IE는 이벤트 버블링,…","fields":{"slug":"/실용주의 프론트 엔드 개발/event/"},"frontmatter":{"date":"May 03, 2020","title":"Event","category":"실용주의 프론트 엔드 개발","draft":false}}},{"node":{"excerpt":"var vs let var var is Function Scope ES5 변수에서는 var 키워드로 변수 선언을 했습니다. var 키워드는 Function Scope로 블럭에 정의를 해도 블럭 밖에서 사용이 가능합니다. let let is Block Scope ES6에서는 let 키워드가 추가 되었고, 블럭 단위로 변수를 선언할 수 있습니다. let 키워…","fields":{"slug":"/실용주의 프론트 엔드 개발/es6-overview/"},"frontmatter":{"date":"May 02, 2020","title":"ES6 Overview","category":"실용주의 프론트 엔드 개발","draft":false}}},{"node":{"excerpt":"프로라면 어떤도구를 사용하든 기능 요구사항은 당연히 구현가능해야 된다고 생각합니다. 문서로는 소프트웨어를 완뱍하게 설계했지만, 소프트웨어가 의도한데로 동작하지 않다면 문서를 작성한 노력과 소프트웨어 개발한 노력은 인정받기 힘듭니다. 소프트웨어의 품질을 높이기 위해서는 비기능 요구사항이 충족해야 합니다. 비기능 요구사항은 개발이나 유지보수, 운영, 컴퓨터 …","fields":{"slug":"/실용주의 프론트 엔드 개발/소프트웨어의-핵심-비기능-요구사항/"},"frontmatter":{"date":"May 02, 2020","title":"소프트웨어의 핵심 비기능 요구사항","category":"실용주의 프론트 엔드 개발","draft":false}}},{"node":{"excerpt":"에러 처리는 소프트웨어의 비정상적인 동작에 대한 큰 사고로 이어지지 않도록 예방하는 것입니다. 서비스 운영에 있어서는 사용자들이 서비스를 비정상적으로 사용하는 부분이 있는 지 감지를 할 수 있습니다. 실패를 전달하는 방법 사고 발생 시 큰 사고로 이어지지 않도록 실패를 알리는 구조가 에러 처리입니다. 반환값으로 실패 전달 에러 처리 중 반환값으로 실패를 …","fields":{"slug":"/실용주의 프론트 엔드 개발/에러-처리-정리/"},"frontmatter":{"date":"May 02, 2020","title":"에러 처리 정리","category":"실용주의 프론트 엔드 개발","draft":false}}},{"node":{"excerpt":"재사용 가능한 모듈 또는 컴포넌트를 만드는 작업은 비용을 절약하는 데 큰 역할을 합니다. 재사용성 관련해서는 난이도 3배의 법칙이 있습니다. 재사용 가능한 모듈을 만드는 작업은 단일 소프트웨어에서 사용할 모듈을 개발할 때보다 3배 어렵다는 법칙입니다. 프런트의 역할이 많아지면서 소프트웨어의 볼륨이 커졌습니다. 재사용 가능한 모듈과 컴포넌트를 만들지 않으면…","fields":{"slug":"/실용주의 프론트 엔드 개발/재사용-가능한-코드-개발/"},"frontmatter":{"date":"May 02, 2020","title":"재사용 가능한 코드 개발","category":"실용주의 프론트 엔드 개발","draft":false}}},{"node":{"excerpt":"객체란 객체란 식별 가능한 개체 또는 사물입니다. 객체는 자동차처럼 만질 수 있는 구체적인 사물일 수도 있고, 시간처럼 추상적인 개념일 수도 있습니다. 객체는 구별 가능한 식별자, 특징적인 행동, 변경 가능한 상태를 가집니다. 소프트웨어 안에서 객체는 저장된 상태와 실행 가능한 코드를 통해 구현됩니다. 객체를 상태와 행동을 함께 지닌 실체라고 정의합니다.…","fields":{"slug":"/실용주의 프론트 엔드 개발/객체지향은-객체와-객체간의-관계로-시작한다/"},"frontmatter":{"date":"May 01, 2020","title":"객체지향은 객체와 객체간의 관계로 시작한다","category":"실용주의 프론트 엔드 개발","draft":false}}},{"node":{"excerpt":"함수형에서 이야기하는 함수는 수학에서 다루는 함수입니다. 수학에서 다루는 함수는 입력값을 계산하고 출력값을 반환합니다. 그리고 입력값은 항상 같은 출력값에 대응됩니다. 함수형에서 이야기하는 함수도 동일하게 동작합니다. 함수는 인자라는 입력값을 받아 계산하고 반환값이라는 출력값을 반환합니다. 자바스크립트는 수학에서 다루는 함수가 아닌 다른 형태의 함수를 만…","fields":{"slug":"/실용주의 프론트 엔드 개발/함수형은-함수를-이해하는-게-절반이다/"},"frontmatter":{"date":"May 01, 2020","title":"함수형은 함수를 이해하는 게 절반이다","category":"실용주의 프론트 엔드 개발","draft":false}}},{"node":{"excerpt":"추상화 객체지향 객체를 추상화 도구로 사용합니다. 함수형 함수를 추상화 도구로 사용합니다. 루틴 루틴은 어떤 절차를 묶어 호출 가능하도록 이름를 부여한 기능 모듈을 의미합니다. 루틴은 다시 프로시저와 함수로 구분할 수 있습니다. 프로시저는 정해진 절차에 따라 내부의 상태를 변경합니다. 함수는 어떤 절차에 따라 필요한 값을 계산해서 반환합니다. 객체지향 객…","fields":{"slug":"/실용주의 프론트 엔드 개발/객체지향과-함수형/"},"frontmatter":{"date":"May 01, 2020","title":"객체지향과 함수형","category":"실용주의 프론트 엔드 개발","draft":false}}},{"node":{"excerpt":"테스트 코드가 읽기 쉬워야 한다는 점은 테스트와 상관없는 실제 코드와 마찬가지로 중요합니다. 다른 프로그래머는 종종 테스트 코드를 실제 코드가 어떻게 동작하며 어떻게 사용되어야 하는지에 관한 비공식적인 문서라고 생각합니다. 테스트 코드가 읽기 쉬우면, 사용자는 실제 코드가 어떻게 동작하는 지 그만큼 더 쉽게 이해할 수 있습니다. 일반적인 설계 원리를 따르…","fields":{"slug":"/실용주의 프론트 엔드 개발/테스트-코드도-이해하기-쉽게-작성하자/"},"frontmatter":{"date":"May 01, 2020","title":"테스트 코드도 이해하기 쉽게 작성하자","category":"실용주의 프론트 엔드 개발","draft":false}}},{"node":{"excerpt":"1. Object Creation 2. Basic Constructors 3. Constructor with prototypes. Module Pattern 모듈 패턴은 기존 소프트웨어 엔지니어링의 클래스에 캡슐화를 모두 제공하는 방법으로 정의되었습니다. JavaScript에서 모듈 패턴은 private/public 메소드와 변수를 단일 오브젝트 내에 포…","fields":{"slug":"/javascript/javascript-웹-응용-프로그램-작성을위한-최고의-디자인-패턴/"},"frontmatter":{"date":"April 30, 2020","title":"JavaScript 웹 응용 프로그램 작성을위한 최고의 디자인 패턴","category":"javascript","draft":false}}},{"node":{"excerpt":"XHTML이란? XHTML과 HTML은 현재 가장 널리 사용되는 웹 문서 규격입니다. 이름에서도 알 수 있듯이 XHTML은 기존에 사용되던 HTML 규격이 가진 문제점을 극복하고, 보다 다양한 분야에 응용될 수 있도록 해주는 여러가지 확장된 기능을 포함하고 있습니다. HTML을 XML 바탕으로 새롭게 구성(reformulation)한 XHTML은 CSS와…","fields":{"slug":"/frontend/DocType/"},"frontmatter":{"date":"April 29, 2020","title":"DocType","category":"frontend","draft":false}}},{"node":{"excerpt":"1. 중복 값 삭제 2. 배열의 값을 변경 3. map ()없는 맵 배열 4. 배열 비우기 5. 배열을 객체로 변환 6. 배열 병합 7. 두 배열 사이에서 같은 값을 찾습니다 8. 배열에서 Falsy 값을 삭제하십시오 9. 배열에서 마지막으로 나타나는 요소의 색인을 찾습니다 10. 배열의 값을 계산 11. 배열 반전 12. 배열에서 가장 작은 숫자 찾기 …","fields":{"slug":"/javascript/javascript-배열-팁/"},"frontmatter":{"date":"April 29, 2020","title":"JavaScript 배열 팁","category":"javascript","draft":false}}},{"node":{"excerpt":"if, for같은 기본 문법을 사용하는 것보다 선언형으로 작성하면 이해하기 쉬운 코드를 작성할 수 있습니다. 객체 객체를 순회하기 위해서 for…in을 사용하는 데, 선언형 함수를 통해서 for…in를 대부분 대체 가능합니다. Object#entries entries는 Object의 key와 value를 2차원 배열로 담아 반환해줍니다. Object#va…","fields":{"slug":"/실용주의 프론트 엔드 개발/선언형으로-대체-가능한-문법들-정리/"},"frontmatter":{"date":"April 28, 2020","title":"선언형으로 대체 가능한 문법들 정리","category":"실용주의 프론트 엔드 개발","draft":false}}},{"node":{"excerpt":"1줄 2줄 line-clamp : 몇줄뒤에 콘텐츠를 자를지를 설정 합니다. box-orient : 박스의 흐름 방향을 지정합니다. 한줄에 여러 요소가 있는 경우 나머지 영역을 모두 채우고 ellipsis 부모에게 , 형제에겐 을 주면 남은 영역을 모두 차지하고 첫번째 줄에서 ellipsis 됩니다. flex를 이용한 ellipsis 버그 숫자만 있는 경우…","fields":{"slug":"/frontend/ellipsis/"},"frontmatter":{"date":"April 28, 2020","title":"ellipsis","category":"frontend","draft":false}}},{"node":{"excerpt":"이름은 효과와 목적을 설명하도록 합니다. 이름은 발음 가능한 것으로 합니다. 이름은 검색 가능하도록 합니다. 이름에 정보를 담아내는 방법 보편적인 단어를 피하고 구체적인 단어를 선택합니다. 어디에서 가져오는 지, 무엇을 수행하는 지, 무엇을 반환하는 지에 따라 구체적인 단어를 선택할 수 있습니다. 시간의 양이나 바이트의 수 같이 측정치를 포함한다면, 단위…","fields":{"slug":"/실용주의 프론트 엔드 개발/네이밍을-명확히-하자/"},"frontmatter":{"date":"April 28, 2020","title":"네이밍을 명확히 하자","category":"실용주의 프론트 엔드 개발","draft":false}}},{"node":{"excerpt":"일관성과 간결성을 위해서 줄바꿈을 통해 재정렬 합니다. 불규칙적으로 정의된 로직은 메소드를 활용하여 정렬 합니다. 선언문을 블록으로 구성 합니다. 우리의 뇌는 자연스럽게 그룹과 계층 구조를 따라서 동작합니다. 논리 영역에 따라서 비슷한 생각을 묶어서 선언하면 성격이 다른 생각과 구분합니다. 추상화 수준으로 정리 합니다. 코드를 정리할 때는 높은 수준의 추…","fields":{"slug":"/실용주의 프론트 엔드 개발/코드-외관도-아름답게-하자/"},"frontmatter":{"date":"April 28, 2020","title":"코드 외관도 아름답게 하자","category":"실용주의 프론트 엔드 개발","draft":false}}},{"node":{"excerpt":"설명 변수를 사용합니다. 커다란 표현을 쪼개는 가장 쉬운 방법은 작은 하위 표현을 담을 추가 변수를 만드는 것입니다. 하위표현의 의미를 설명하므로 설명 변수라고도 합니다. 상관없는 하위문제 추출하기 주어진 함수가 코드 블록을 보고, 스스로에게 질문합니다. 상위수준에서 본 이 코드의 목적은 무엇입니까? 코드의 모든 줄에 질문을 던집니다. 이 코드는 직접적으…","fields":{"slug":"/실용주의 프론트 엔드 개발/코드를-작게-만들자/"},"frontmatter":{"date":"April 28, 2020","title":"코드를 작게 만들자","category":"실용주의 프론트 엔드 개발","draft":false}}},{"node":{"excerpt":"조건문에서 인수는 왼쪽에 정의합니다. 인수의 왼쪽은 질문을 받는 표현을 정의하고, 오른쪽에는 비교대상을 두는 것이 통계적으로 가독성이 더 좋습니다. 이러한 가이드 라인은 영어 어순과 일치합니다. 조건문은 긍정을 먼저 다룹니다. if/else를 사용하는 경우 부정이 아닌 긍정을 먼저 다루는 게 좋습니다. 첫번째 블록을 생각할 때 한번 부정한 값을 생각해야 …","fields":{"slug":"/실용주의 프론트 엔드 개발/조건문을-단순화하자/"},"frontmatter":{"date":"April 28, 2020","title":"조건문을 단순화하자","category":"실용주의 프론트 엔드 개발","draft":false}}},{"node":{"excerpt":"이번 장에서는 유연하고 재사용 가능할 설계를 만들기 위해 적용할 수 있는 다양한 의존성 관리 기법들을 이라는 관점에서 정리 합니다. 01. 개방-폐쇄 원칙 개방-폐쇄 원칙(Open-CLosed Principle, OCP) : 소프트웨어 개체(클래스, 모듈, 함수 등등)는 , . 확장에 대해 열려 있다는 것은 애플리케이션의 요구사항이 변경될 때 이 변경에 …","fields":{"slug":"/object/object-chapter-09-유연한-설계/"},"frontmatter":{"date":"April 25, 2020","title":"object chapter 09 유연한 설계","category":"object","draft":false}}},{"node":{"excerpt":"잘 설계된 객체지향 애플리케이션은 들로 구성됩니다. 이런 작은 객체들이 단독으로 수행할 수 있는 작업은 거의 없기 때문에 객체 사이의 을 낳습니다. 협력을 위해서는 의존성이 필요하지만 과도한 의존성은 애플리케이션을 수정하기 어렵게 만듭니다. 객체지향 설계의 핵심은 협력을 위해 필요한 의존성은 유지하면서도 변경을 방해하는 의존성을 제거하는 데 있습니다. 이…","fields":{"slug":"/object/object-chapter-08-의존성-관리하기/"},"frontmatter":{"date":"April 20, 2020","title":"object chapter 08 의존성 관리하기","category":"object","draft":false}}},{"node":{"excerpt":"HTTP 요청 흐름 (웹브라우저에서의 요청) 브라우저에서 먼저 URL에 적힌 값을 파싱하여, HTTP 요청 메세지를 만듭니다. 만든 메세지를 웹 서버로 전송하는데, 이때 웹 브라우저 직접 전송을 하는것이 아니라 OS에 ‘보내주세요’ 하고 의뢰를 하게 됩니다. OS는 DNS서버를 조회해서 Host이름을 보내야 할 IP 주소로 변환하게 됩니다. 프로토콜 스택…","fields":{"slug":"/develop/웹과-통신/"},"frontmatter":{"date":"April 16, 2020","title":"웹과 통신","category":"develop","draft":false}}},{"node":{"excerpt":"단편화란 메모리 상에서 적재되고, 해제되는 과정에서 발생하는 메모리 사이의 사용하지 못할 정도로 작은 빈 공간 입니다. 크게 외부 단편화와 내부 단편화로 나뉩니다. 외부 단편화는 프로세스와 프로세스 사이에 발생하는 빈 공간입니다. 외부 단편화는 메모리를 다시 재정렬하는 압축을 통해 해결할 수 있지만, 효율이 좋지 않습니다. 내부 단편화는 프로세스 안에서 …","fields":{"slug":"/develop/메모리/"},"frontmatter":{"date":"April 16, 2020","title":"메모리","category":"develop","draft":false}}},{"node":{"excerpt":"OOP (객체지향 프로그래밍) 객체지향 프로그래밍은 컴퓨터 프로그래밍 패러다임(견해, 사고법)의 하나로, 프로그래밍에서 필요한 데이터를 추상화 시켜서 상태(속성, 어트리뷰트)와 행위(메서드)를 가진 객체로 만들고, 그 객체간의 상호작용을 통해 로직을 구성하는 방법 입니다. 장점 다른 클래스를 가져와 사용할 수 있고, 상속받을 수 있어 코드의 재사용성이 높…","fields":{"slug":"/develop/oop,-aop,-fp/"},"frontmatter":{"date":"April 16, 2020","title":"OOP, AOP, FP","category":"develop","draft":false}}},{"node":{"excerpt":"스케줄러란 CPU와 같은 자원을 우선순위에 기반하여 프로세스에 할당하는 방법을 말합니다. Job Queue : 현재 시스템 안에서 돌고 있는 프로세스의 집합 입니다. Ready Queue : 메모리 안에서 CPU의 할당을 기다리는 프로세스의 집합 입니다. Device Queue : 장치 입출력을 기다리고 있는 프로세스의 집합 입니다. 스케줄러의 종류 세 …","fields":{"slug":"/develop/cpu-스케줄링/"},"frontmatter":{"date":"April 16, 2020","title":"CPU 스케줄링","category":"develop","draft":false}}},{"node":{"excerpt":"List ArrayList 배열로 구현된 List 입니다. 데이터가 저장된 순서가 같습니다. 사실상 배열과 같은 자료구조이기 때문에, 리스트의 연산 자체의 수행시간 속도는 배열과 같습니다. LinkedList 다음 노드의 주소를 기억하고 있는 List로, 배열에 비해 삽입과 삭제가 간단합니다. 그러나 탐색의 경우 첫 번째 노드부터 탐색해 나가야 하기 때문…","fields":{"slug":"/develop/collection/"},"frontmatter":{"date":"April 14, 2020","title":"Collection","category":"develop","draft":false}}},{"node":{"excerpt":"What is GRASP? GRASP는 객체 지향 디자인의 클래스 및 객체에 책임을 할당하기위한 지침으로 구성됩니다. SOLID 설계 원칙과 관련이 없다고는 하지만 서로 엮여있는 부분이 조금씩은 있습니다. General Responsibility Assignment Software Patterns Object-Oriented 디자인의 핵심은 각 객체에 책…","fields":{"slug":"/develop/grasp-(object-oriented-design)/"},"frontmatter":{"date":"April 12, 2020","title":"GRASP (object-oriented design)","category":"develop","draft":false}}},{"node":{"excerpt":"Async/await 더 편안한 환경에서 Promise를 다루기 위해 태어난 특별한 문법입니다. Async 함수 함수 전에 “async”라는 단어가 의미하는 것은 간단합니다 : promise를 반환하는 함수라는 뜻입니다. 심지어 만일함수가 실제로 promise가 아닌 값을 반환해도, “async” 키워드로 정의된 함수는 자바스크립트에서 자동으로 그 값을 …","fields":{"slug":"/javascript/async-await/"},"frontmatter":{"date":"April 12, 2020","title":"Async Await","category":"javascript","draft":false}}},{"node":{"excerpt":"Promise 이해하기 프로미스는 말 그대로 약속 입니다. Promise는 3가지 상태를 가집니다. Pending(미결) Fulfilled(이행) Rejected(거절) Promise는 비동기(Asynchronous)다. ES5, ES6/2015, ES7에서의 Promise ES5 - 주류 브라우저들 Bluebird Promise 라이브러리만 설치했다면,…","fields":{"slug":"/javascript/promise/"},"frontmatter":{"date":"April 12, 2020","title":"Promise","category":"javascript","draft":false}}},{"node":{"excerpt":"Iterator는 자바스크립트의 collection을 반복하는 새로운 방법입니다. ES6에서 소개된 개념이고 매우 유용하고 많은 곳에서 사용되고 있기 때문에 인기가 많습니다. 반복 가능한 것(Iterable)과 Iterator 을 적용한 메소드가 iteratorMethod 입니다. 이와 비슷하게 사용자 정의 오브젝트를 반복하는 프로세스의 표준화가 에 의해…","fields":{"slug":"/javascript/iterator/"},"frontmatter":{"date":"April 12, 2020","title":"Iterator","category":"javascript","draft":false}}},{"node":{"excerpt":"ES6는 제너레이터(Generator) 또는 Generator 함수 형태에서 함수와 Iterator를 다루는 방법을 새롭게 소개했습니다. 제너레이터는 함수를 중간에서 멈추고, 다시 멈췄던 부분부터 실행할 수 있게 합니다. 요약하면, Generator는 함수의 형태를 띄지만, Iterator처럼 동작합니다. 재미있는 사실은 async/await이 Gener…","fields":{"slug":"/javascript/generator/"},"frontmatter":{"date":"April 12, 2020","title":"generator","category":"javascript","draft":false}}},{"node":{"excerpt":"재귀의 3가지 중요한 특성 종료 조건 간단하게, if(나쁜 값이 들어왔다면) { 정지! };과 같이 이해하시면 됩니다. 종료 조건은 재귀의 안전장치입니다. 종료 조건을 여러분들의 긴급 브레이크처럼 생각하세요. 좋지 않은 입력 값이 들어왔을 때, 재귀가 계속하여 동작하는 것을 방지해줍니다. 위의 팩토리얼 예제에서, if (x < 0) return;은 우리가…","fields":{"slug":"/develop/재귀(recursion)/"},"frontmatter":{"date":"April 12, 2020","title":"재귀(Recursion)","category":"develop","draft":false}}},{"node":{"excerpt":"바로 현재 값에 접근할 수 있습니다.(arrayi와 같은 형식으로 접근하려면 매우 불편하죠.) 기존 배열의 변화를 방지할 수 있기 때문입니다.(immutable) 그래서, side-effect를 최소화할 수 있습니다. for loop을 관리할 필요가 없습니다. 빈 배열을 만들고 거기에 push할 필요가 없습니다. 참조 자바스크립트 개발자라면 알아야 할 3…","fields":{"slug":"/javascript/map,-filter,-reduce를-사용하는-이유/"},"frontmatter":{"date":"April 10, 2020","title":"Map, Filter, Reduce를 사용하는 이유","category":"javascript","draft":false}}},{"node":{"excerpt":"자바스크립트에는 눈으로 보기엔 비슷하지만 사실 매우 다른 동등 비교연산자 두개가 있습니다. 자바스크립트에서 === 연산을 사용할 때, 우리는 엄격한 동등성을 비교합니다. 엄격한 동등성의 의미는 타입과 값이 둘 다 같아야 한다는 이야기입니다. 우리가 자바스크립트에서 ==연산자를 쓰는 목적은 느슨한 동등 비교를 위함입니다. == 연산자도 강제 형변환(type…","fields":{"slug":"/javascript/==-vs-===/"},"frontmatter":{"date":"April 10, 2020","title":"== vs ===","category":"javascript","draft":false}}},{"node":{"excerpt":"this 함수가 만들어졌을 때, 뒤에서는 this라 불리는 키워드가 만들어집니다. this는 함수가 동작하는 곳에 있는 오브젝트와 연결해줍니다. this 키워드의 값은 그 함수 자체와는 상관이 없습니다. 함수가 어떻게 불려지는지가 this의 값을 결정합니다. 기본 값으로, this는 언제나 전역 스코프의 root을 참조하는 window Object가 됩니…","fields":{"slug":"/javascript/this,-call(),-apply(),-bind()/"},"frontmatter":{"date":"April 10, 2020","title":"this, call(), apply(), bind()","category":"javascript","draft":false}}},{"node":{"excerpt":"DOM DOM(Document Object Model)은 웹사이트를 유저와 상호작용할 수 있도록 만들기 위해 필수적인 부분입니다. DOM은 프로그래밍 언어가 웹사이트의 내용(content), 구조(structure) 그리고 스타일을 조작할 수 있게 만들어주는 인터페이스입니다. 자바스크립트는 인터넷 브라우저 상의 DOM과 연결해주는 클라이언트 사이드 스크립…","fields":{"slug":"/frontend/dom/"},"frontmatter":{"date":"April 10, 2020","title":"DOM","category":"frontend","draft":false}}},{"node":{"excerpt":"자바스크립트의 모든 것이 Object(객체)인 것은 아닙니다. 자바스크립트에는 6개의 원시 타입이 존재합니다. 원시 타입이 아닌 것들은 모두 Object(객체)입니다. 함수는 단순히 특별한 타입의 Object(객체)일 뿐입니다. 함수는 새로운 Object(객체)를 만들기 위해 사용될 수 있습니다.(생성자 함수) Strings, Booleans, Numbe…","fields":{"slug":"/javascript/primitive-type/"},"frontmatter":{"date":"April 10, 2020","title":"Primitive Type","category":"javascript","draft":false}}},{"node":{"excerpt":"5장에서는 2장에서 소개한 코드의 설계 과정을 한 걸음씩 따라가 보면서 객체에 책임을 할당하는 기본적인 원리를 살펴 봅니다. 데이터 중심의 설계는 하고 협력이라는 문맥을 벗어나 고립된 객체의 상태에 초점을 맞추기 때문에 캡슐화를 위반하기 쉽고, 요소들 사이의 결합도가 높아지며, 코드를 변경하기 어려워집니다. 데이터 중심 설계로 인해 발생하는 문제점을 해결…","fields":{"slug":"/object/object-chapter-05-책임-할당하기/"},"frontmatter":{"date":"April 07, 2020","title":"object chapter 05 책임 할당하기","category":"object","draft":false}}},{"node":{"excerpt":"","fields":{"slug":"/frontend/크롤링/"},"frontmatter":{"date":"April 03, 2020","title":"크롤링","category":"frontend","draft":false}}},{"node":{"excerpt":"주석 C1: 부적절한 정보 다른 시스템에 (예를 들어, 소스 코드 관리 시스템, 버그 추적 시스템，이슈 추적 시스템, 기타 기록 관리 시스템에) 저장할 정보는 주석으로 적절하지 못합니다. 일반적으로 작성자, 최종수정일, SPR(Software Prablem Report)번호 등과 같은 메타 정보만 주석으로 넣습니다. 주석은 코드와 설계에 기술적인 설명을 …","fields":{"slug":"/clean code/clean-code-17장-냄새와-휴리스틱/"},"frontmatter":{"date":"April 02, 2020","title":"clean code 17장 냄새와 휴리스틱","category":"clean code","draft":false}}},{"node":{"excerpt":"지난 수십여 년 동안 쌓아온 경험에서 얻은 교훈이라면, 프로그래밍은 과학보다 공예(craft)에 가깝다는 사실입니다. 깨끗한 코드를 짜려면 먼저 지저분한 코드를 짠 뒤에 정리해야 합니다. 하지만 대다수 신잠 프로그래머는 무조건 돌아가는 프로그램을 목표로 잡습니다. 일단 프로그램이 ‘돌아가면’ 다음 업무로 넘어갑니다. ‘돌아가는’ 프로그램은 그 상태가 어떻…","fields":{"slug":"/clean code/clean-code-14장-점진적인개선/"},"frontmatter":{"date":"April 02, 2020","title":"clean code 14장 점진적인개선","category":"clean code","draft":false}}},{"node":{"excerpt":"클라이언트/서버 예제 먼저 애플리케이션이 어디서 시간을 보내는지 알아야 합니다. 가능성은 다음 두 가지 입니다. I/O : 소켓 사용, 데이터베이스 연결, 가상 메모리 스와핑 기다리기 등에 시간을 보냅니다. 프로세서 : 수치 계산, 정규표현식 처리, 가비지 컬렉션 등에 시간을 보냅니다. 대개 시스템은 둘 다 하느라 시간을 보내지만, 특정 연산을 살펴보면 …","fields":{"slug":"/clean code/clean-code-부록a-동시성2/"},"frontmatter":{"date":"April 02, 2020","title":"clean code 부록A 동시성2","category":"clean code","draft":false}}},{"node":{"excerpt":"15장 JUnit 들여다보기 비록 저자들이 모듈을 아주 좋은 상태로 남겨두었지만 보이스카우트 규칙에 따르면 우리는 처음 왔을 때보다 더 깨끗하게 해놓고 떠나야 합니다. 가장 먼저 눈에 거슬리는 부분은 멤버 변수 앞에 붙인 접두어 f입니다. 오늘날 사용하는 개발 환경에서는 이처럼 변수 이름에 범위를 명시할 필요가 없습니다. 접두어 f는 중복되는 정보입니다.…","fields":{"slug":"/clean code/clean-code-15장-16장/"},"frontmatter":{"date":"April 02, 2020","title":"clean code 15장 16장","category":"clean code","draft":false}}},{"node":{"excerpt":"사용하게 된 계기 github education name.com에서 도메인과 ssl 사용하던 중 예기치 않게 서버를 종료 후 ssl을 다시 적용해야 하는데 쉽지 않았습니다. 메일 같은걸 보내긴 했는데 되는건지도 잘 모르겠고, 인증서를 다시 보려고 해도 에러만 발생합니다… certbot-auto 세팅 www 파일 수정 “greenlock-express”: …","fields":{"slug":"/develop/node-https-적용/"},"frontmatter":{"date":"April 01, 2020","title":"node https 적용","category":"develop","draft":false}}},{"node":{"excerpt":"Intro 객체는 처리의 추상화입니다. 스레드는 일정의 추상화입니다. 동시성과 깔끔한 코드는 양립하기 어렵습니다. 스레드를 하나만 실행 하는 코드는 작성하기 쉽습니다. 겉으로 보기에는 멀쩡하나 깊숙한 곳에 문제가 있는 다중 스레드 코드도 작성하기 쉽습니다. 이런 코드는 시스템이 부하를 받기 전까지 멀쩡하게 돌아갑니다. 본 챕터에서는 concurrent 프…","fields":{"slug":"/clean code/clean-code-13장-동시성/"},"frontmatter":{"date":"March 31, 2020","title":"clean code 13장 동시성","category":"clean code","draft":false}}},{"node":{"excerpt":"Intro 창발성이란 단순한 결합이 복잡한 결과를 나타내는 것을 의합니다. 인간의 뇌를 예로 들면 하나의 뉴런은 인식능력이 없지만 수십억개의 뉴런이 결합하게 되면 자기 인식이 발생하는 현상을 말하는 것입니다. 이 창발성은 명령을 내리는 조정자 없이 각 부분의 의사소통으로 자기 조직화를 이루게 되고 이러한 밑으로 부터의 힘은 예기치 못한 기능을 발현하는 힘…","fields":{"slug":"/clean code/clean-code-12장-창발성/"},"frontmatter":{"date":"March 27, 2020","title":"clean code 12장 창발성","category":"clean code","draft":false}}},{"node":{"excerpt":"클래스 체계 클래스를 정의하는 표준 자바 관례에 따르면, 가장 먼저 변수 목록이 나옵니다. 정적 공개 상수가 있다면 맨 처음에 나옵니다. 다음으로 정적 비공개변수가 나옵니다. 이어서 비공개 인스턴스 변수가 나옵니다. 공개 변수가 필요한 경우는 거의 없습니다. 변수 목록 다음에는 공개 함수가 나옵니다. 비공개 함수는 자신을 호출하는 공개 함수 직후에 넣습니…","fields":{"slug":"/clean code/clean-code-10장-클래스/"},"frontmatter":{"date":"March 27, 2020","title":"clean code 10장 클래스","category":"clean code","draft":false}}},{"node":{"excerpt":"Intro 깨끗한 코드를 구현하면 낮은 추상화 수준에서 관심사를 분리하기 쉬워집니다. 시스템 제작과 시스템 사용을 분리하라 잘 정돈된 견고한 시스템을 만들기 위해서는 전역적이고 일관된 의존성 해결 방법을 통해 작은 편의 코드들이 모듈성의 저해를 가져오는 것을 막아야 합니다. 소프트웨어 시스템은 (애플리케이션 객체를 제작하고 의존성을 서로 ‘연결’하는) 준…","fields":{"slug":"/clean code/clean-code-11장-시스템/"},"frontmatter":{"date":"March 27, 2020","title":"clean code 11장 시스템","category":"clean code","draft":false}}},{"node":{"excerpt":"Intro 1997년만 해도 TDD(Test Driven Development)라는 개념을 아무도 몰랐습니다. 우리들 대다수에게 단위 테스트란 자기 프로그램이 ‘돌아간다’는 사실만 확인하는 일회성 코드에 불과했습니다. 지금은 애자일과 TDD 덕택에 단위 테스트를 자동화하는 프로그래머들이 이미 많아졌으며 점점 더 늘어나는 추세입니다. 우리 분야에 테스트를 …","fields":{"slug":"/clean code/clean-code-9장-단위-테스트/"},"frontmatter":{"date":"March 27, 2020","title":"clean code 9장 단위 테스트","category":"clean code","draft":false}}},{"node":{"excerpt":"원본 .d.ts 파일이 node_modules 아래에 있을 경우 컴파일러는 src/index.ts에서 non-relative module import구문을 발견하여 moduleA모듈에 대한 타입 선언 파일을 탐색하기 시작합니다. compilerOptions.path에 moduleA에 대한 경로 설정이 존재하므로 해당 경로를 우선 탐색합니다. 경로에서 .d…","fields":{"slug":"/typescript/npm-모듈의-타입-선언-파일(.d.ts)을-커스텀-타입-선언-파일로-대체하는-법/"},"frontmatter":{"date":"March 26, 2020","title":"npm 모듈의 타입 선언 파일(.d.ts)을 커스텀 타입 선언 파일로 대체하는 법","category":"typescript","draft":false}}},{"node":{"excerpt":"setInterval(func, delay, …args)와 setTimeout(func, delay, …args) 2개의 메소드는 func을 delayms 이후에 주기적으로 혹은 한번 실행하도록 허용해줍니다. 실행을 취소하기 위해, 우리는 setInterval 또는 setTimeout에서 반환되는 값을 이용해 clearInterval 또는 clearTim…","fields":{"slug":"/javascript/setinterval-and-settimeout/"},"frontmatter":{"date":"March 25, 2020","title":"setInterval and setTimeout","category":"javascript","draft":false}}},{"node":{"excerpt":"우리는 가끔 서드파티 패키지나 오픈소스를 사용해야 될 상황에 직면합니다. 혹은 우리 회사 내부 팀이 만든 컴포넌트를 사용해야 할 상황도 있습니다. 어느 상황이던, 우리는 이 코드들을 우리 내부 코드와 “깨끗하게” 통합시켜야 합니다. 외부 코드 사용하기(서드파티 코드 사용하기) 경계에서의 긴장 패키지 제공자나 프레임워크 제공자는 을 최대한 넓히려 애씁니다.…","fields":{"slug":"/clean code/clean-code-8장-경계/"},"frontmatter":{"date":"March 24, 2020","title":"clean code 8장 경계","category":"clean code","draft":false}}},{"node":{"excerpt":"도메인 구입 DNS 세팅 type : A answer : {본인 IP} SSL 적용 CSR 생성 이메일과 전화번호는 name.com 사이트와 일치하게 작성합니다. 도메인과 파일 이름을 같게 세팅 합니다. 인증서 설치 아래의 정보를 바탕으로 인증서 받기 인증서 정보를 바탕으로 cert.pem 생성 Nginx 세팅 sslsessioncache shared:S…","fields":{"slug":"/develop/github-education-name.com-사용하기/"},"frontmatter":{"date":"March 22, 2020","title":"github education name.com 사용하기","category":"develop","draft":false}}},{"node":{"excerpt":"","fields":{"slug":"/javascript/생년월일-확인/"},"frontmatter":{"date":"March 20, 2020","title":"생년월일 확인","category":"javascript","draft":false}}},{"node":{"excerpt":"추상클래스 클래스가 미완성이라는 것은 멤버의 개수에 관계된 것이 아니라, 단지 미완성 메서드(추상메서드)들 포함하고 있는 의미입니다. 추상클래스로 인터턴스는 생성할 수 없습니다. 추상클래스는 상속을 통해서 자손클래스에 의해서만 완성될 수 있습니다. 상속을 강제하기 위한 추상메서드를 하나 이상 가진 클래스를 말합니다. 맥락에 따라서 달라질 수 있는 기능들이…","fields":{"slug":"/develop/추상클래스와-인터페이스/"},"frontmatter":{"date":"March 18, 2020","title":"추상클래스와 인터페이스","category":"develop","draft":false}}},{"node":{"excerpt":"싱글톤 패턴 싱글톤 패턴은 단 하나의 인스턴스를 생성해 사용하는 디자인 패턴입니다. 클래스 인스턴스가 하나만 만들어지도록 하고, 그 인스턴스에 대한 전역 접근을 제공합니다. 이를 구현할 때는 private 생성자와, 정적 메소드, 정적 변수만을 사용합니다. 캐시나 로그 기록, 사용자 설정 같이 자주 사용되는 데이터들을 같이 공유하며 저장해두는 것들에 이용…","fields":{"slug":"/design pattern/싱글톤/"},"frontmatter":{"date":"March 18, 2020","title":"싱글톤","category":"design pattern","draft":false}}},{"node":{"excerpt":"Model 데이터를 처리하는 역할 입니다. 애플리케이션의 정보(데이터)를 처리하는 컴포넌트를 말합니다. 데이터베이스에 연결하고 데이터를 추출하거나 저장, 삭제, 업데이트, 변환 등의 작업을 수행하는 역할을 합니다. View 사용자가 보는 화면입니다. 화면에 표시되는 부분입니다. 추출한 데이터나 일반적인 텍스트 데이터를 표시하거나 input, button …","fields":{"slug":"/design pattern/mvc-mvp-mvvm/"},"frontmatter":{"date":"March 18, 2020","title":"MVC MVP MVVM","category":"design pattern","draft":false}}},{"node":{"excerpt":"명령형과 선언형의 차이 명령형 프로그래밍 명령형 프로그래밍이란 프로그래밍의 상태와 상태를 변경시키는 구문의 관점에서 연산을 설명하는 방식입니다. 알고리즘을 명시하고 목표는 명시하지 않습니다. 프로그램은 명령의 수행입니다. 어떻게(how to)에 초점을 맞춥니다. 튜링 머신에 이론적 배경을 둡니다. 선언형 프로그래밍 선언형 프로그래밍은 어떤 방법으로 해야하…","fields":{"slug":"/programming paradigm/프로그래밍-패러다임/"},"frontmatter":{"date":"March 18, 2020","title":"프로그래밍 패러다임","category":"develop","draft":false}}},{"node":{"excerpt":"참조 [code-lab] CSS Gradient로 투명배경판 만들기 [CSS] linear-gradient를 활용하여 체스판 배경 만들기","fields":{"slug":"/frontend/css로-격자-만들기/"},"frontmatter":{"date":"March 13, 2020","title":"CSS로 격자 만들기","category":"frontend","draft":false}}},{"node":{"excerpt":"Intro 오류 처리는 프로그램에 반드시 필요한 요소 중 하나일 뿐입니다. 입력 이 이상하거나 디바이스가 실패할지도 모르기 때문입니다. 간단히 말해, 뭔가 잘못될 가능성은 늘 존재합니다. 뭔가 잘못되면 바로 잡을 책임은 바로 우리 프로그래머에게 있습니다. 깨끗한 코드와 오류 처리는 확실히 연관성이 있습니다. 상당수 코드 기반은 전적으로 오류 처리 코드에 …","fields":{"slug":"/clean code/clean-code-7장-오류-처리/"},"frontmatter":{"date":"March 10, 2020","title":"clean code 7장 오류 처리","category":"clean code","draft":false}}},{"node":{"excerpt":"Intro 변수를 비공개로 정의하는 이유가 있습니다. 남들이 변수에 의존하지 않게 만들고 싶어서 입니다. 충동이든 변덕이든, 변수 타입이나 구현을 맘대로 바꾸고 싶어합니다. 자료 추상화 변수 사이에 함수라는 계층을 넣는다고 구현이 저절로 감춰지지는 않습니다. 구현을 감추려면 추상화가 필요합니다. 그저 (형식 논리에 치우쳐) 조회 함수와 설정 함수로 변수를…","fields":{"slug":"/clean code/clean-code-6장-객체와-자료-구조/"},"frontmatter":{"date":"March 07, 2020","title":"clean code 6장 객체와 자료 구조","category":"clean code","draft":false}}},{"node":{"excerpt":"공변성 : 타입 T를 확장한 타입에 대해서 허용합니다. 보통 인자는 공변성을 가집니다. 무공변성 : 타입 T만 허용합니다. 반공변성: 타입 T의 상위(부모) 타입에 대해서 허용합니다. 보통 리턴 타입은 반공변성을 가집니다. 참조 공변성과 반공변성, 무공변성","fields":{"slug":"/develop/공변-반공변-무공변/"},"frontmatter":{"date":"March 06, 2020","title":"공변 반공변 무공변","category":"develop","draft":false}}},{"node":{"excerpt":"Intro 질서정연하고 깔끔하며, 일관적인 코드를 본다면 사람들에게 전문가가 짰다는 인상을 심어줄 수 있습니다. 반대로, 코드가 어수선해 보인다면 프로젝트 전반적으로 무성의한 태도로 작성했다고 생각합니다. 프로그래머라면 형식을 깔끔하게 맞춰 코드를 짜야 합니다. 코드 형식을 맞추기 위한 간단한 규칙을 정하고 그 규칙을 착실히 따라야 합니다. 팀으로 일한다…","fields":{"slug":"/clean code/clean-code-5장-형식-맞추기/"},"frontmatter":{"date":"March 06, 2020","title":"clean code 5장 형식 맞추기","category":"clean code","draft":false}}},{"node":{"excerpt":"나쁜 코드에 주석을 달지 말아야 합니다. 새로 짜는 것이 좋습니다. 주석은 필요악 입니다. 코드로 의도를 표현하지 못해, 실패를 만회하기 위해 쓰는 것입니다. 주석은 언제나 실패를 의미합니다. 주석 없이는 자신을 표현할 방법을 찾지 못해 할 수 없이 주석을 사용합니다. 그래서 주석은 반가울수 없습니다. 주석이 오래될수록 코드에서 멀어져서 거짓말을 하게 될…","fields":{"slug":"/clean code/clean-code-4장-주석/"},"frontmatter":{"date":"March 04, 2020","title":"clean code 4장 주석","category":"clean code","draft":false}}},{"node":{"excerpt":"의도를 분명히 밝힙니다. 변수의 존재 이유, 기능, 사용법 등이 변수/함수/클래스명에 드러나야 합니다. 따로 주석이 필요하지 않을 정도로 드러나야 합니다. 의미를 함축하거나 독자(코드를 읽는 사람)가 사전 지식을 가지고 있다고 가정하지 않습니다. 그릇된 정보를 피합니다. 중의적으로 해석될 수 있는 이름 피해야 합니다. 개발자에게는 특수한 의미를 가지는 단…","fields":{"slug":"/clean code/clean-code-2장-의미-있는-이름/"},"frontmatter":{"date":"March 03, 2020","title":"clean code 2장 의미 있는 이름","category":"clean code","draft":false}}},{"node":{"excerpt":"Intro 프로그래밍 초창기에는 시스템을 루틴과 하위 루틴으로 나눴습니다. 포트란과 PL/1 시절에는 시스템을 프로그램, 하위 프로그램, 함수로 나눴습니다. 하지만 지금은 함수만 살아 남았습니다. 어떤 프로그램이든 가장 기본적인 단위가 함수입니다. 작게 만들어라! 함수를 만드는 첫째 규칙은  입니다. 함수를 만드는 둘째 규칙은  입니다. 이 규칙은 근거를…","fields":{"slug":"/clean code/clean-code-3장-함수/"},"frontmatter":{"date":"March 03, 2020","title":"clean code 3장 함수","category":"clean code","draft":false}}},{"node":{"excerpt":"추천사 5S 원칙 정리(Seiri) 또는 조직(정럴(sort)) 적절한 명명법 등과 같은 방법을 사용해 무엇이 어디에 있는지 알아야 합니다. 정돈(Seiton) 또는 단정함(체계화) “물건마다 모두 제자리 가 있다”라는 속담이 있습니다. 코드는 누구나 예상히는 위치에 있어야 합니다. 그렇지 않으면 다시 정돈해 누구나 예상하는 위치로 옮겨야 합니다. 청소(…","fields":{"slug":"/clean code/clean-code-추천사-및-0장/"},"frontmatter":{"date":"March 03, 2020","title":"clean code 추천사 및 0장 들어가면서","category":"clean code","draft":false}}},{"node":{"excerpt":"코드가 존재하리라 코드는 요구사항을 표현하는 언어라는 사실을 명심해야 합니다. 요구사항에 더욱 가까운 언어를 만들 수도 있고, 요구사항에서 정형 구조를 뽑아내는 도구를 만들 수도 있습니다. 하지만 어느 순간에는 정밀한 표현이 필요합니다. 그 필요성을 없앨 방법은 없습니다. 그러므로 코드도 항상 존재 합니다. 코드에 관한 책은 구시대적이고, 곧 명세를 기준…","fields":{"slug":"/clean code/clean-code-1장-깨끗한-코드/"},"frontmatter":{"date":"March 03, 2020","title":"clean code 1장 깨끗한 코드","category":"clean code","draft":false}}},{"node":{"excerpt":"Repository는 하나의 도메인에 관련 된 것들을 컨트롤 합니다. 하나의 도메인에는 여러개의 테이블이 존재할 수 있습니다. REPOSITORY는 메모리에 로드된 객체 컬렉션에 대한 집합 처리를 위한 인터페이스를 제공합니다. DAO(Data Access Object)는 하나의 테이블에 관련 된 것들을 컨트롤 합니다. Entity Bean을 대체하기 위한…","fields":{"slug":"/develop/repository와-dao/"},"frontmatter":{"date":"February 24, 2020","title":"repository와 DAO","category":"develop","draft":false}}},{"node":{"excerpt":"SYNC / ASYNC return 한다면 SYNC, callback으로 응답한다면 ASYNC 입니다. Synchronous / Asynchronous는 호출되는 함수의 작업 완료 여부를 누가 신경쓰냐가 관심사 입니다. SYNC : 서브루틴이 즉시 값을 반환 합니다. 이벤트를 자신이 직접 처리 합니다.(확인의 주체가 유저 프로세스이며, 다 될때까지 기다리…","fields":{"slug":"/develop/동기-비동기/"},"frontmatter":{"date":"February 24, 2020","title":"동기 비동기","category":"develop","draft":false}}},{"node":{"excerpt":"tsconfig 파일 작성 esModuleInterop을 설정하지 않고 module.exports와 export default를 다르게 import 한다. module.exports 를 사용해서 import 해야한다. scripts 작성 webpack 적용 nodeExternals를 사용하지 않으면 웹팩에서 에러가 발생한다. 왜인지는 아직 잘 모르겠다… …","fields":{"slug":"/typescript/node-javascript에서-typescript로-바꾸기/"},"frontmatter":{"date":"February 22, 2020","title":"Node javascript에서 typescript로 바꾸기","category":"typescript","draft":false}}},{"node":{"excerpt":"XSS 란? Cross Site Scripting의 약자로 CSS라고 하는 것이 맞지만 Cascading Style Sheets의 약어로 사용되어 있어 XSS라고 합니다. XSS 게시판이나 웹 메일 등에 자바스크립트 같은 스크립트 코드를 삽입 해 개발자가 고려하지 않은 기능이 작동하게 하는 치명적일 수 있는 공격 입니다. 대부분의 웹 해킹 공격 기법과는 …","fields":{"slug":"/frontend/xss/"},"frontmatter":{"date":"February 21, 2020","title":"XSS","category":"frontend","draft":false}}},{"node":{"excerpt":",  두 속성을 이용해서 html 수정을 허용 할 수 있습니다.","fields":{"slug":"/frontend/html-edit/"},"frontmatter":{"date":"February 21, 2020","title":"html edit","category":"frontend","draft":false}}},{"node":{"excerpt":"Circular dependency 소프트웨어 엔지니어링 하는 순환 종속성은 직접 또는 간접적으로 제대로 작동 서로 의존 두개 또는 그 이상의 모듈들 간의 관계입니다. 이러한 모듈은 상호 재귀 라고도 합니다. 무조건 터지느건 아니고 컨스트럭터 이전에 생성을 하기 위해 참조하던 것이 생성하고 있는 중인 것을 참조해서 터지는 경우가 발생했습니다. 이를 끊어내…","fields":{"slug":"/javascript/순환-의존성/"},"frontmatter":{"date":"February 21, 2020","title":"순환 의존성","category":"javascript","draft":false}}},{"node":{"excerpt":"메타태그의 뷰포트 속성에 을 추가 CSS 추가 하단에 플로팅된 버튼과 아이폰 홈 버튼의 간격이 겹쳐 간격을 주고 싶을때 IOS에서 11.2 업데이트시 constant속성을 없애고 env로 정의하도록 변경이 되었다. 하지만 업데이트 안한 유저들이 있어 두번째, 세번째 라인 모두 추가해야 구, 신기종을 전부 대응할 수 있다. 구버전 대응시 env값을 + 10…","fields":{"slug":"/frontend/아이폰-홈인디케이터/"},"frontmatter":{"date":"February 21, 2020","title":"아이폰 홈인디케이터","category":"frontend","draft":false}}},{"node":{"excerpt":"","fields":{"slug":"/javascript/월의-시작과-끝/"},"frontmatter":{"date":"February 21, 2020","title":"월의 시작과 끝","category":"javascript","draft":false}}},{"node":{"excerpt":"자바스크립트에는 유사배열이라는 것이 존재 합니다. 배열과 유사배열을 구분해야 하는 이유는, 유사배열의 경우 배열의 메서드를 쓸 수 없기 때문입니다. 나 로 확인 할 수 있습니다. 유사배열들 유사배열에서 배열 메서드 사용하기 출처 배열과 유사배열","fields":{"slug":"/frontend/유사배열/"},"frontmatter":{"date":"February 19, 2020","title":"유사배열","category":"frontend","draft":false}}},{"node":{"excerpt":"assign 객체 안에 배열 함수에서 활용 freeze","fields":{"slug":"/javascript/배열-복사/"},"frontmatter":{"date":"February 15, 2020","title":"복사","category":"javascript","draft":false}}},{"node":{"excerpt":"마우스를 올리면 텍스트 밑에 밑줄을 긋는다거나 배경색을 바꾸는 효과를 줄때가 있다. 하지만 모바일에서는 호버 이벤트가 없다 하지만 이를 위해 action 가상 선택자를 통해 클릭 시 효과를 주는 것으로 통일성을 맞춰 나가는거 같다. 하지만 호버 이벤트를 모바일 사이즈에서 없애지 않는다면 클릭 후 색이 남는 현상이 발생 했다. 이벤트 주기 호버 이벤트를 지…","fields":{"slug":"/frontend/hover/"},"frontmatter":{"date":"February 14, 2020","title":"hover","category":"frontend","draft":false}}},{"node":{"excerpt":"스크롤 되는 영역에 그라데이션을 넣어야 했다. 아래 영역에서 before과 absolute를 이용해서 스크롤 되는 리스트 하단에 항상 그라데이션을 넣는 것에는 성공했다. 하지만 그 영역에서 스크롤 되지 않았다. 그냥 보기엔 리스트의 영역처럼 보이지만 실제론 아래 영역 안에 포함된 곳이기 때문에 스크롤이 되지 않는 것이 어찌보면 당연히 맞다. 이를 해결하기…","fields":{"slug":"/frontend/pointer-events/"},"frontmatter":{"date":"February 13, 2020","title":"pointer events","category":"frontend","draft":false}}},{"node":{"excerpt":"이미지를 업로드 하는 경우에 로컬에서는 문제가 없었으나 호스팅한 서버에서는 를 반환했습니다. 413 Request Entity Too Large는 nginx에서 업로드한 파일의 용량이 제한 수치를 넘겨서 발생 했습니다. 로컬에선 nginx를 사용하지 않고 호스팅 된 서버에서는 80포트를 8080포트로 옮겨주기 위해 사용했습니다. 해결 방안 nginx 서버…","fields":{"slug":"/backend/413-request-entity-too-large/"},"frontmatter":{"date":"February 13, 2020","title":"413 Request Entity Too Large","category":"backend","draft":false}}},{"node":{"excerpt":"객체 생성 패턴 네임스페이스 패턴 쉽게 구현할 수 있는 패턴이며 전역변수의 개수를 줄이고, 변수명이 불필요하게 길어짐을 방지한다. 전역 네임스페이스 객체는 흔히 대문자로 선언한다. 이 패턴의 단점은 다음과 같다. 모든 변수와 함수에 접두어를 붙이므로, 전체 코드량이 길어져 다운로드 파일의 크기가 증가 전역 인스턴스가 1개이기 때문에 부분이 수정되면 다른 …","fields":{"slug":"/javascript/객체-생성-패턴/"},"frontmatter":{"date":"February 12, 2020","title":"객체 생성 패턴","category":"javascript","draft":false}}},{"node":{"excerpt":"HTTP/1은 하나의 TCP 연결에 하나의 요청만 처리하고 연결을 끊어버렸기 때문에 매 요청마다 이 번거로운 핸드쉐이크를 거쳐야 했습니다. HTTP/2에서는 핸드쉐이크를 최소화하기 위해서 단일 TCP 연결을 유지하면서 여러 개의 요청을 처리할 수 있도록 변경 되었습니다. 결국 HTTP/1에서 HTTP/2로 넘어갈 때도 핸드쉐이크 과정 자체는 건드리지 않았…","fields":{"slug":"/frontend/http/"},"frontmatter":{"date":"February 11, 2020","title":"http","category":"frontend","draft":false}}},{"node":{"excerpt":"react에서 function으로 만들어진 component에는 4가지 타입이 있었습니다. FC, SFC, FunctionComponent, StatelessComponent 하지만 hooks로 인해서 function component에서도 state를 사용할 수 있게 되어 SFC와 StatelessComponent가 deprecated 되었습니다.","fields":{"slug":"/react/function-component-type/"},"frontmatter":{"date":"February 10, 2020","title":"function component type","category":"react","draft":false}}},{"node":{"excerpt":"TCP 연결형 서비스 가상 회선 방식 전송 순서 보장 신뢰성 높음 전송 속도 느림 http/1과 http/2는 TCP를 사용 UDP 비연결형 서비스 데이터그램 방식 전송 순서 보장 하지 않음 신뢰성 낮음 전송 속도 빠름 http/3는 UDP를 사용 커스터마이징이 용이하다","fields":{"slug":"/develop/tcp-udp/"},"frontmatter":{"date":"February 09, 2020","title":"TCP UDP","category":"frontend","draft":false}}},{"node":{"excerpt":"","fields":{"slug":"/frontend/input-number/"},"frontmatter":{"date":"February 08, 2020","title":"input number","category":"frontend","draft":false}}},{"node":{"excerpt":"위와 같이 타입을 바꿀 때 as를 사용 가능 위과 같이 사용할 땐 is를 사용 위의 is와 관련 된 문법엔 오류가 많다(자바랑 섞어 쓰기도 하고)","fields":{"slug":"/kotlin/kotlin-is-and-as/"},"frontmatter":{"date":"February 07, 2020","title":"kotlin is and as","category":"kotlin","draft":false}}},{"node":{"excerpt":"JVM은 자바 가상머신(Java Virtual Machine)의 약자입니다. JRE는 자바 실행환경(Java Runtime Environment)의 약자입니다. JDK JDK는 자바 개발도구(Java Development Kit)의 약자입니다. JDK는 JRE + 개발을 위해 필요한 도구(javac, java등)들을 포함합니다. v8은 jvm가 아니라 j…","fields":{"slug":"/java/jre-jvm/"},"frontmatter":{"date":"February 06, 2020","title":"JRE JVM","category":"java","draft":false}}},{"node":{"excerpt":"String a = “”로 생성하는건 String pool을 할당하는거고 내부적으로 intern()이라는 코드를 통해 상수풀에 값을 올립니다. 이미 존재하는 값이라면 값을 주소를 리턴하는 것을 보장합니다. “hello” + “world”와 같은 동작도 String pool을 할당받은 동작을 하는 것이기 때문에 a==e 는 true 입니다. “문자열” + …","fields":{"slug":"/java/java-string/"},"frontmatter":{"date":"February 05, 2020","title":"Java String","category":"java","draft":false}}},{"node":{"excerpt":"마진병합현상의 조건 인접해있는 Block요소끼리만 일어납니다. 상하단만 해당 됩니다. 레이아웃을 더 보기 좋게 하기 위한 좋은 기능이다. 하지만 원하는 바와 다르게 적용 될 수도 있다. 마진병합을 방지하는 방법 부모에 margin이 0 auto여서 wrapper와 자식의 마진이 사라졌을 경우 부모에 padding: 1px을 줍니다. 부모에 border: …","fields":{"slug":"/frontend/마진-병합/"},"frontmatter":{"date":"February 04, 2020","title":"마진 병합","category":"frontend","draft":false}}},{"node":{"excerpt":"ES2015(ES6)에서 자바스크립트에 클래스(Class)가 도입되었습니다. 자바스크립트는 기본적으로 프로토타입 기반의 언어입니다. 프로토타입 기반으로 객체 지향적으로 설계하는 것이 복잡하여 클래스라는 sugar syntax 문법이 도입된 것입니다. Java에서의 클래스와 똑같은 기능을 한다고 생각 할 수 있지만 여전히 객체 지향을 흉내내고 있고 그 내부…","fields":{"slug":"/javascript/javascript-class/"},"frontmatter":{"date":"February 03, 2020","title":"JavaScript Class","category":"javascript","draft":false}}},{"node":{"excerpt":"Hook가 React 버전 16.8에 새로 추가되었습니다. Hook를 이용하여 Class를 작성할 필요 없이 상태 값과 여러 React의 기능을 사용할 수 있습니다. 하지만 React에서 Class를 제거할 계획은 없습니다. Hook은 알고 있는 React 컨셉을 대체하지 않습니다. 대신에, Hook는 props, state, context, refs, …","fields":{"slug":"/react/react-hook/"},"frontmatter":{"date":"February 02, 2020","title":"React Hook","category":"react","draft":false}}},{"node":{"excerpt":"3.0 새로운 개념의 프로젝트 참조가 도입되었습니다. 프로젝트 참조를 통해 TypeScript 프로젝트는 다른 TypeScript 프로젝트에 의존 할 수 tsconfig.json있습니다. 특히 파일이 다른 tsconfig.json파일 을 참조 할 수 있습니다. 이러한 종속성을 지정하면 TypeScript가 빌드 순서 및 출력 구조를 이해할 수 있는 방법을…","fields":{"slug":"/typescript/TypeScript 버전에 따른 변경점/"},"frontmatter":{"date":"February 01, 2020","title":"TypeScript 버전에 따른 변경점","category":"typescript","draft":false}}},{"node":{"excerpt":"부트스트랩 쉽고 빠르며 다양한 기능들을 제공합니다. 다양한 디자인과 동적인 효과를 사용할 수 있습니다. 모바일 환경과 반응형 웹 제작에 유리하게 사용할 수 있습니다. 높은 퀄리티가 보장이 되기 때문에 시간을 단축하며 그로 인해 비용이 절감 됩니다. jQuery에 의존성이 강합니다(부트스트랩 5가 되면서 jQuery를 제거 했다고 합니다) 정형화되어 있어 …","fields":{"slug":"/frontend/오픈소스-ui-kit들의-장단점/"},"frontmatter":{"date":"January 31, 2020","title":"오픈소스 UI Kit들의 장단점","category":"frontend","draft":false}}},{"node":{"excerpt":"","fields":{"slug":"/frontend/flexbox/"},"frontmatter":{"date":"January 30, 2020","title":"flexbox","category":"frontend","draft":false}}},{"node":{"excerpt":"background CSS 단축 속성은 색상, 이미지, 원점, 크기, 반복 등 여러 배경 스타일을 한 번에 지정합니다. background: background-color | background-image | background-repeat | background-attachment | background-position background: #12345…","fields":{"slug":"/frontend/background/"},"frontmatter":{"date":"January 29, 2020","title":"background","category":"frontend","draft":false}}},{"node":{"excerpt":"position static : 기본값, 다른 태그와의 관계에 의해 자동으로 배치되며 위치를 임의로 설정해 줄 수 없습니다. 움직이지 않고 정적인 상태입니다. relative : 원래 있던 위치를 기준으로 좌표를 지정합니다. 부모 엘리먼트를 기준으로 상대적으로 움직입니다. absolute : 절대 좌표와 함께 위치를 지정해 줄 수 있습니다. positio…","fields":{"slug":"/frontend/position-속성과-offset/"},"frontmatter":{"date":"January 28, 2020","title":"position 속성과 Offset","category":"frontend","draft":false}}},{"node":{"excerpt":"유니온(Union)타입 유니온 타입은 하나의 프로퍼티에 다양한 변수가 올 수 있는 타입을 말합니다. keyof 키워드 keyof 키워드는 타입 값에 존재하는 모든 프로퍼티의 키값을 union 형태로 리턴 받습니다. never 타입 never는 에러가 발생했을 때 프로세스를 중단시키지 않고 무시하는 타입입니다. any를 제외한 다른 모든 타입의 원시 타입으…","fields":{"slug":"/typescript/typescript-헬터-타입/"},"frontmatter":{"date":"January 27, 2020","title":"typescript 헬터 타입","category":"typescript","draft":false}}},{"node":{"excerpt":"prototype을 사용하여 class를 구현하는 방법 prototype을 사용하여 상속을 구현 일반적으로 클래스를 만들면 자동으로 prototype의 constructor라는 프로퍼티가 만들어집니다. 이 프로퍼티에는 해당 클래스의 생성자 정보가 기본값으로 담기게 됩니다. 달리 말하면 constructor 프로퍼티를 이용해 사용하는 객체가 어떤 클래스의 …","fields":{"slug":"/javascript/javascript에서-클래스를-구현하는-방법,-상속하는-방법/"},"frontmatter":{"date":"January 27, 2020","title":"javascript에서 클래스를 구현하는 방법, 상속하는 방법","category":"javascript","draft":false}}},{"node":{"excerpt":"screen.height 화면의 세로 크기를 가져옵니다. screen.availHeight 브라우저의 막대를 포함하여 최대화 된 경우 브라우저의 윈도우가 가질 수 있는 높이입니다. 창이 최대화되면 screen.availHeight === window.outerHeight 작업 표시줄이 차지하는 부분을 제외한 세로 크기를 가져옵니다. 화면 아래의 작업 표시…","fields":{"slug":"/frontend/height/"},"frontmatter":{"date":"January 26, 2020","title":"height","category":"frontend","draft":false}}},{"node":{"excerpt":"HTML부터 React까지의 제가 알고 있는 웹 프론트엔드 흐름에 대해 정리를 해보고자 합니다. 웹은 HTML, CSS, Javascript로 구성되어 있습니다. DART나 KOTLIN.JS, 웹어셈블리 등이 웹을 지원하기는 한다고 합니다. HTML 가장 먼저 HTML은 HyperText Markup Language로 웹페이지를 기술하기 위한 마크업 언어…","fields":{"slug":"/frontend/web-frontend/"},"frontmatter":{"date":"January 24, 2020","title":"WEB FRONTEND","category":"frontend","draft":false}}},{"node":{"excerpt":"자바스크립트로 doublyLinkedList 구현하기 참조 데이터 스트럭쳐란 무엇인가? codingeverybody/datastructurejava","fields":{"slug":"/javascript/doublylinkedlist/"},"frontmatter":{"date":"January 24, 2020","title":"doublyLinkedList","category":"javascript","draft":false}}},{"node":{"excerpt":"자바스크립트로 linkedList 구현하기 참조 데이터 스트럭쳐란 무엇인가? codingeverybody/datastructurejava","fields":{"slug":"/javascript/linkedlist/"},"frontmatter":{"date":"January 24, 2020","title":"linkedList","category":"javascript","draft":false}}},{"node":{"excerpt":"자바스크립트로 arrayList 구현하기 참조 데이터 스트럭쳐란 무엇인가? codingeverybody/datastructurejava","fields":{"slug":"/javascript/arraylist/"},"frontmatter":{"date":"January 24, 2020","title":"arrayList","category":"javascript","draft":false}}},{"node":{"excerpt":"모바일과 PC 웹브라우저의 scroll 모바일 웹을 작업하고 있는데 스크롤을 구현하는게 상당히 골치가 아픕니다. 스크롤은 어디나 들어가는 아주 일반적인 기능이라고 생각하고 있었음에도 구현하는데 여러가지 어려움이 상당히 많습니다. 스크롤 스크롤 영역으로 지정하는 것은 딱히 모바일 웹에 특화된 것은 아닙니다. 스크롤을 사용할 곳의 크기를 지정하고 CSS 속성…","fields":{"slug":"/frontend/scroll/"},"frontmatter":{"date":"January 24, 2020","title":"scroll","category":"frontend","draft":false}}},{"node":{"excerpt":"모바일과 PC 웹브라우저의 viewport 차이 meta viewport 태그는 애플이 아이폰, 아이패드 등 자사의 모바일 브라우저의 뷰포트(viewport) 크기 조절을 위해 만들었습니다. viewport란 우리말로 보임참, 즉 화면 상의 표시 영역을 뜻합니다. 화면의 보여지는 영역과 viewport는 차이가 있는데, viewport는 그림을 그리기 위…","fields":{"slug":"/frontend/viewport/"},"frontmatter":{"date":"January 23, 2020","title":"viewport","category":"frontend","draft":false}}},{"node":{"excerpt":"npm 의존성관리 javascript 패키지 매니저 java에 gradle , php의 composer 와 같은 역할을 한다. npm은 node의 모듈을 관리해주는 패키지 매니저입니다. node.js를 설치하면 내장(built in)되어 있습니다. npm -v를 통해 버전을 확인할 수 있습니다. npm install 명령으로 외부 모듈 패키지를 설치합니다…","fields":{"slug":"/javascript/javascript-패키지-매니저/"},"frontmatter":{"date":"January 22, 2020","title":"javascript 패키지 매니저","category":"javascript","draft":false}}},{"node":{"excerpt":"package.json 파일을 작성할 때에는 JavaScript의 객체 리터럴이 아니라 올바른 JSON 포맷이어야 합니다. npm init 명령어를 통해 package.json 파일을 만들 수 있습니다. -y 옵션을 사용해서 빠르게 생성 할 수도 있습니다. name 필수로 입력되어야 하며 이 항목들이 누락되면 패키지를 설치할 수 없습니다. name은 반드…","fields":{"slug":"/javascript/package.json/"},"frontmatter":{"date":"January 21, 2020","title":"package.json","category":"javascript","draft":false}}},{"node":{"excerpt":"서버 사이드 템플릿 시대를 지나 단일 페이지 애플리케이션(Single Page Application, SPA) 개발이 점차 인기를 얻으면서 자바스크립트의 코드량이 과거에 비해 기하급수적으로 증가하게 되었습니다. 많게는 수천, 수만 줄이나 하는 자바스크립트 코드에서 특정 코드를 찾아 수정하기란 쉽지 않은 일입니다. 그래서, 개발 초기 단계에서 API 기능과…","fields":{"slug":"/javascript/웹팩4(webpack)-설정하기/"},"frontmatter":{"date":"January 20, 2020","title":"웹팩4(Webpack) 설정하기","category":"javascript","draft":false}}},{"node":{"excerpt":"react와 styled-components를 이용해서 퍼센트에 따라 원을 그리는 컴포넌트를 만들었습니다.","fields":{"slug":"/react/퍼센트-원-그리기/"},"frontmatter":{"date":"January 19, 2020","title":"퍼센트 원 그리기","category":"react","draft":false}}},{"node":{"excerpt":"리액트는 배열을 렌더링 할 때 값을 통하여 업데이트 성능을 최적화 합니다. 기본적으로 DOM 노드의 자식에 대해 반복 할 때 React는 두 자식 목록을 동시에 반복하고 차이가 있을 때마다 돌연변이를 생성합니다.(virtual dom diff를 써서 확인) 이 문제를 해결하기 위해 React는 key속성을 지원 합니다. 자식에 키가 있으면 React는이 …","fields":{"slug":"/react/리액트에서-key를-사용하는-이유/"},"frontmatter":{"date":"January 18, 2020","title":"리액트에서 key를 사용하는 이유","category":"react","draft":false}}},{"node":{"excerpt":"프로토타입 기반 프로그래밍은 객체지향 프로그래밍의 한 형태의 갈래로 클래스가 없고, 클래스 기반 언어에서 상속을 사용하는 것과는 다르게, 객체를 원형(프로토타입)으로 하여 복제의 과정을 통하여 객체의 동작 방식을 다시 사용할 수 있습니다. 프로토 타입 역할을 하는 delegation을 통해 기존 객체를 재사용하는 프로세스를 통해 동작 재사용(상속)을 수행…","fields":{"slug":"/javascript/프로토타입-기반의-객체지향/"},"frontmatter":{"date":"January 17, 2020","title":"프로토타입 기반의 객체지향","category":"javascript","draft":false}}},{"node":{"excerpt":"V8이란? 독일 구글 개발 센터에서 만들어진 JavaScript 엔진입니다. 웹 브라우저 안에서 실행되는 JavaScript의 성능을 높이기 위해 처음 고안되었습니다. 오픈 소스이고 C++로 작성되었습니다. 구글 크롬과 Node.js의 런타임에서 사용 중입니다. 속도를 높이기 위해서 V8은 인터프리터를 이용하는 대신 기계어 코드로 번역합니다. JIT(Ju…","fields":{"slug":"/frontend/v8-엔진의-동작-원리/"},"frontmatter":{"date":"January 14, 2020","title":"V8 엔진의 동작 원리","category":"frontend","draft":false}}},{"node":{"excerpt":"가장 먼저 CSS transition 속성을 이용해서 아코디언 애니메이션을 구현했습니다. CSS를 수정하지 않고 애니메이션 구현하기 window.requestAnimationFrame 함수를 사용해서 구현했습니다. 애니메이션을 모두 기다린 후에 클릭을 하면 잘 작동하지만 애니메이션 도중 클릭을 할 경우 제대로 작동하지 않고 다시 클릭 했을 때 2번 작동 …","fields":{"slug":"/frontend/라이브러리-없이-애니메이션-구현하는-방법/"},"frontmatter":{"date":"January 14, 2020","title":"라이브러리 없이 애니메이션 구현하는 방법","category":"frontend","draft":false}}}]}},"pageContext":{}}}