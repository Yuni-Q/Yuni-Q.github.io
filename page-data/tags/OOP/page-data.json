{"componentChunkName":"component---src-templates-tags-tsx","path":"/tags/OOP/","result":{"data":{"site":{"siteMetadata":{"title":"yuni-q 블로그","configs":{"countOfInitialPost":10}}},"allMarkdownRemark":{"totalCount":12,"edges":[{"node":{"excerpt":"TL;DR 2장에서는 책임을 중심으로 설계된 객체지향 코드의 대력적인 모양을 살펴봅니다. 객체지향 프로그래밍에서 사용되는 다양한 요소와 개념을 이해하게 됩니다. 01. 영화 예매 시스템 요구사항 살펴보기 02 객체지향 프로그래밍을 향해 협력, 객체, 클래스 입니다. C++, 자바, 루비, C…","fields":{"slug":"/오브젝트/02-객체지향-프로그래밍/02-객체지향-프로그래밍/"},"frontmatter":{"date":"17 <span> April </span>","title":"02 객체지향 프로그래밍","category":"오브젝트","tags":["OOP","객체지향"],"draft":false}}},{"node":{"excerpt":"TL;DR…","fields":{"slug":"/오브젝트/03-역할,-책임,-협력/"},"frontmatter":{"date":"11 <span> April </span>","title":"03 역할, 책임, 협력","category":"오브젝트","tags":["OOP","객체지향"],"draft":false}}},{"node":{"excerpt":"TL;DR 절차적 프로그래밍 방식으로 구현해보고 이렇게 구현된 코드의 품질이 나쁜 이유를 설명합니다. 품질을 평가하기 위해 사용할 수있는 척도인 캡슐화, 응집도, 결합도의 개념도 함께 소개합니다.…","fields":{"slug":"/오브젝트/04-설계-품질과-트레이드오프/"},"frontmatter":{"date":"11 <span> April </span>","title":"04 설계 품질과 트레이드오프","category":"오브젝트","tags":["OOP","객체지향"],"draft":false}}},{"node":{"excerpt":"TL;DR GRASP라고 부르는 책임 할당 패턴을 설명합니다. 2장에서 소개한 영화 예매 시스템의 설계를 책임 할당의 관점에서 설명하고 4장에서 구현한 절차적 프로그래밍 방식과 비교합니다. 책임을 중심으로 설계를 이끌어가는 것이 캡슐화, 응집도, 결합도의 관점에서 설계를 개선한다는 사실을 이해하게 될 것입니다. 5장에서는…","fields":{"slug":"/오브젝트/05-책임-할당하기/"},"frontmatter":{"date":"11 <span> April </span>","title":"05 책임 할당하기","category":"오브젝트","tags":["OOP","객체지향"],"draft":false}}},{"node":{"excerpt":"TL;DR 추상화의 한 가지 방법인 분해의 역사를 다룹니다. 프로시저 추상화와 데이터 추상화 사이의 갈등과 분쟁의 역사를 이해하면 기능 분해에서 시작해서 객체지향에 이르기까지 소프트웨어 패러다임의 변화를 자연스럽게 이해하게 될 것입니다. 사람이 동시에 단기 기억 안에 저장할 수 있는 정보의 개수는 5개에서 많아 봐야 9개 정도를 넘지 못합니다. 새운 정보를 받아 들이는 데…","fields":{"slug":"/오브젝트/07-객체-분해/"},"frontmatter":{"date":"11 <span> April </span>","title":"07 객체 분해","category":"오브젝트","tags":["OOP","객체지향"],"draft":false}}},{"node":{"excerpt":"TL;DR…","fields":{"slug":"/오브젝트/08-의존성-관리하기/"},"frontmatter":{"date":"11 <span> April </span>","title":"08 의존성 관리하기","category":"오브젝트","tags":["OOP","객체지향"],"draft":false}}},{"node":{"excerpt":"TL;DR 객체지향의 대표적인 재사용 기법인 상속에 관해 다룹니다. 조금 놀랄 수도 있겠지만 1…","fields":{"slug":"/오브젝트/10-상속과-코드-재사용/"},"frontmatter":{"date":"11 <span> April </span>","title":"10 상속과 코드 재사용","category":"오브젝트","tags":["OOP","객체지향"],"draft":false}}},{"node":{"excerpt":"TL;DR 훌륭한 퍼블릭 인터페이스를 작성하기 위해 따라야 하는 설계 원칙을 소개합니다. 디미터 법칙, 묻지말고 시켜라, 의도를 드러내는 인터페이스, 명령-쿼리 분리 원칙을 조합하면 직관적이고, 예측 가능하며, 유연한 퍼블릭 인터페이스를 창조할 수 있는 사실을 알게 될 것입니다. Intro…","fields":{"slug":"/오브젝트/06-메시지와-인터페이스/"},"frontmatter":{"date":"11 <span> April </span>","title":"06 메시지와 인터페이스","category":"오브젝트","tags":["OOP","객체지향"],"draft":false}}},{"node":{"excerpt":"TL;DR…","fields":{"slug":"/오브젝트/11-합성과-유연한-설계/"},"frontmatter":{"date":"11 <span> April </span>","title":"11 합성과 유연한 설계","category":"오브젝트","tags":["OOP","객체지향"],"draft":false}}},{"node":{"excerpt":"01. 개방-폐쇄 원칙 유연한 설계란 도 애플리케이션의 동작을 확장할 수 있는 설계입니다. 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라 유연하고 재사용 가능한 설계에서 런타임 의존성과 컴파일타임 의존성은 서로 다른 구조를 가집니다. 이로인해 컴파일타임 의존성을 수정하지 않고도 런타임 의존성을 쉽게 변경 할 수 있습니다. 컴파일타임 의존성은 에서 드러나는 클래스들 사이의 관계입니다. 런타임 의존성은 에 협력에 참여하는 객체들 사이의 관계입니다. 추상화가 핵심이다(DIP…","fields":{"slug":"/오브젝트/09-유연한-설계/"},"frontmatter":{"date":"11 <span> April </span>","title":"09 유연한 설계","category":"오브젝트","tags":["OOP","객체지향"],"draft":false}}},{"node":{"excerpt":"TL;DR 티켓 판매 시스템이라는 간단한 도메인을 예로 들어 채그이 전체적인 주제를 함축해서 전달합니다. intro 소프트웨어 개발에서 실무가 이론보다 앞서 있는 대표적인 분야로 ‘소프트웨어 설계’와 ‘소프트웨어 유지보수’를 들 수 있습니다. 대부분 사람들은 이론이 먼저 정립된 후에 실무가 그 뒤를 따라 발전한다고 생각합니다. 로버트 L…","fields":{"slug":"/오브젝트/01-객체,-설계/01-객체,-설계/"},"frontmatter":{"date":"11 <span> April </span>","title":"01 객체, 설계","category":"오브젝트","tags":["OOP","객체지향"],"draft":false}}},{"node":{"excerpt":"…","fields":{"slug":"/오브젝트/00-intro/"},"frontmatter":{"date":"10 <span> April </span>","title":"00 intro","category":"오브젝트","tags":["OOP","객체지향"],"draft":false}}}]}},"pageContext":{"tag":"OOP"}},"staticQueryHashes":["3128451518"]}