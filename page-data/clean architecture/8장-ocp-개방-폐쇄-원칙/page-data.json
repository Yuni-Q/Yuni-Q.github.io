{"componentChunkName":"component---src-templates-blog-post-js","path":"/clean architecture/8장-ocp-개방-폐쇄-원칙/","result":{"data":{"site":{"siteMetadata":{"title":"yuni-q 블로그","author":"yuni-q","siteUrl":"https://yuni-q.github.io","comment":{"disqusShortName":"yuni-q","utterances":"yuni-q"},"sponsor":{"buyMeACoffeeId":"yuniq"}}},"markdownRemark":{"id":"e2b6bb61-73a8-5571-b5d5-b1e4597be254","excerpt":"OCP: 개방-패쇄 원칙 (Open-Closed Principle) 소프트웨어 개체(artifact…","html":"<h2 id=\"ocp-개방-패쇄-원칙-open-closed-principle\" style=\"position:relative;\"><a href=\"#ocp-%EA%B0%9C%EB%B0%A9-%ED%8C%A8%EC%87%84-%EC%9B%90%EC%B9%99-open-closed-principle\" aria-label=\"ocp 개방 패쇄 원칙 open closed principle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OCP: 개방-패쇄 원칙 (Open-Closed Principle)</h2>\n<ul>\n<li>소프트웨어 개체(artifact)는 확장에는 열려 있어야 하고, 변경에는 닫혀있어야 합니다.</li>\n<li>소프트웨어 개체의 행위는 확장할 수 있어야 하지만, 이때 산출물을 변경해서는 안 됩니다.</li>\n<li>소프트웨어 아키텍처를 공부하는 가장 근본적인 이유가 바로 이 때문입니다. 만약 요구사항을 살짝 확장하는 데 수정사항이 많다면 설계한 아키텍트는 엄청난 실패에 맞닥뜨린 것입니다.</li>\n<li>소프트웨어 아키텍처가 훌륭하다면 변경되는 코드의 양이 가능한 한 최소화 될 것입니다. 이상적인 변경량은 0입니다.</li>\n<li>서로 다른 목적으로 변경되는 요소를 적절하게 분리하고(단일 책임 원칙, SRP), 이들 요소 사이의 의존성을 체계화함으로써(의존성 역전 원칙, DIP) 변경량을 최소화할 수 있습니다.</li>\n<li>아키텍트는 기능이 어떻게, 왜, 언제 발생하는 지에 따라서 기능을 분리하고, 분리한 기능을 컴포넌트의 계층구조로 조직화합니다. 컴포넌트 계층구조를 이와 같이 조직화하면 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있습니다.</li>\n<li>OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는 데 있습니다. 이러한 목표를 달성하려면 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생하는 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층 구조가 만들어 지도록 해야 합니다.</li>\n</ul>\n<h2 id=\"참고\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0\" aria-label=\"참고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고</h2>\n<ul>\n<li><a href=\"https://peter-cho.gitbook.io/book/11/clean-architecture/5\">8장 OCP 개방 폐쇄 원칙</a></li>\n</ul>","frontmatter":{"title":"8장 OCP 개방 폐쇄 원칙","date":"May 04, 2020"}}},"pageContext":{"slug":"/clean architecture/8장-ocp-개방-폐쇄-원칙/","previous":{"fields":{"slug":"/clean architecture/9장-lsp-리스코프-치환-원칙/"},"frontmatter":{"title":"9장 LSP 리스코프 치환 원칙","category":"clean architecture","draft":false}},"next":{"fields":{"slug":"/clean architecture/7장-srp-단일-책임-원칙/"},"frontmatter":{"title":"7장 SRP 단일 책임 원칙","category":"clean architecture","draft":false}}}}}