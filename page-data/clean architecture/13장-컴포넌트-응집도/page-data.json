{"componentChunkName":"component---src-templates-blog-post-js","path":"/clean architecture/13장-컴포넌트-응집도/","result":{"data":{"site":{"siteMetadata":{"title":"yuni-q 블로그","author":"yuni-q","siteUrl":"https://yuni-q.github.io","comment":{"disqusShortName":"yuni-q","utterances":"yuni_q"},"sponsor":{"buyMeACoffeeId":"yuniq"}}},"markdownRemark":{"id":"0eec4037-8a7a-5354-80c1-665c56930a58","excerpt":"REP: 재사용/릴리즈 등가 원칙(Reuse/Release Equivalence Principle…","html":"<h2 id=\"rep-재사용릴리즈-등가-원칙reuserelease-equivalence-principle\" style=\"position:relative;\"><a href=\"#rep-%EC%9E%AC%EC%82%AC%EC%9A%A9%EB%A6%B4%EB%A6%AC%EC%A6%88-%EB%93%B1%EA%B0%80-%EC%9B%90%EC%B9%99reuserelease-equivalence-principle\" aria-label=\"rep 재사용릴리즈 등가 원칙reuserelease equivalence principle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>REP: 재사용/릴리즈 등가 원칙(Reuse/Release Equivalence Principle)</h2>\n<ul>\n<li>재사용 단위는 릴리즈 단위와 같습니다.</li>\n<li>소프트웨어 컴포넌트가 릴리즈 절차를 통해 추적 관리되지 않거나 릴리즈 번호가 부여되지 않는다면 해당 컴포넌트를 재사용하고 싶어도 할 수도 없고 하지도 않을 것입니다. 릴리즈 번호가 없다면 재사용 컴포넌트들이 서로 호환되는지 보증할 방법이 전혀 없습니다.</li>\n<li>이 원칙을 소프트웨어 설계와 아키텍처 관점에서 보면 단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 함을 뜻합니다. 단순히 뒤죽박죽 임으로 선택된 클래스와 모듈로 구성되서는 안 됩니다. 컴포넌트를 구성하는 모든 모듈은 서로 공유하는 중요한 데이터나 목적이 있어야 합니다.</li>\n</ul>\n<h2 id=\"ccp-공통-폐쇄-원칙common-closure-principle\" style=\"position:relative;\"><a href=\"#ccp-%EA%B3%B5%ED%86%B5-%ED%8F%90%EC%87%84-%EC%9B%90%EC%B9%99common-closure-principle\" aria-label=\"ccp 공통 폐쇄 원칙common closure principle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CCP: 공통 폐쇄 원칙(Common Closure Principle)</h2>\n<ul>\n<li>동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶습니다. 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리합니다.</li>\n<li>이 원칙은 단일 책임 원칙(SRP)을 컴포넌트 관점에서 다시 쓴 것입니다. SRP에서 단일 클래스는 변경의 이유가 여러개 있어서는 안된다는 말하듯이, 공통 폐쇄 원칙(CCP)에서도 마찬가지로 단일 컴포넌트는 변경이 이유가 여러개 있어서는 안 됩니다.</li>\n<li>이 원칙은 개방 패쇄 원칙(OCP)과도 밀접하게 관련되어 있습니다. 실제도 CCP에서 말하는 패쇄 Closure는 OCP에서 말하는 패쇄 Closure와 그 뜻이 같습니다. CCP에서는 동일한 유형의 변경에 대해 닫혀 있는 클래스들을 하나의 컴포넌트로 묶음으로써 OCP에서 얻은 교훈을 확대 적용합니다.</li>\n<li>SRP와 CCP 두 원칙은 모두 ‘동일한 시점에 동일한 이유로 변경되는 것들은 한데 묶어습니다. 서로 다른 시점에 다른 이유로 변경되는 것들은 서로 분리합니다.‘는 교훈으로 요약할 수 있습니다.</li>\n</ul>\n<h2 id=\"crp-공통-재사용-원칙common-reuse-principle\" style=\"position:relative;\"><a href=\"#crp-%EA%B3%B5%ED%86%B5-%EC%9E%AC%EC%82%AC%EC%9A%A9-%EC%9B%90%EC%B9%99common-reuse-principle\" aria-label=\"crp 공통 재사용 원칙common reuse principle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CRP: 공통 재사용 원칙(Common Reuse Principle)</h2>\n<ul>\n<li>컴포넌트 사용자들은 필요하지 않는 것에 의존하게 강요하지 않습니다.</li>\n<li>공통 재사용 원칙도 클래스와 모듈은 어느 컴포넌트에 위치 시킬지 결정할 때 도움되는 원칙입니다. CRP에서는 같이 재사용되는 경향이 있는 클래스와 모듈들은 같은 컴포넌트에 포함해야 한다고 말합니다.</li>\n<li>CRP는 인터페이스 분리 원칙(ISP)의 포괄적인 버전입니다. ISP는 사용하지 않은 메서드가 있는 클래스에 의존하지 말라고 조언합니다. CRP에서는 사용하지 않는 클래스를 가진 컴포넌트에 의존하지 말라고 조언합니다.</li>\n<li>필요하지 않는 것에 의존하지 않습니다.</li>\n</ul>\n<h3 id=\"컴포넌트-응집도에-대한-균형\" style=\"position:relative;\"><a href=\"#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%9D%91%EC%A7%91%EB%8F%84%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B7%A0%ED%98%95\" aria-label=\"컴포넌트 응집도에 대한 균형 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>컴포넌트 응집도에 대한 균형</h3>\n<ul>\n<li>REP와 CCP는 포함 원칙입니다. 즉, 두 원칙은 컴포넌트를 더욱 크게 만듭니다. CRP는 배제 원칙이며, 컴포넌트를 더욱 작게 만듭니다. 뛰어난 아키텍트라면 이 원칙들이 균형을 이루는 방법을 찾아야 합니다.</li>\n<li>REP: 재사용성을 위한 그룹입니다. 고려하지 않으면 재사용이 어려워집니다.</li>\n<li>CCP: 유지보수성을 위한 그룹입니다. 고려하지 않으면 컴포넌트 변경이 너무 빈번해집니다.</li>\n<li>CRP: 불필요한 릴리즈를 피하기 위해 분리합니다. 고려하지 않으면 불필요한 릴리즈가 너무 빈번해 집니다.</li>\n</ul>\n<h2 id=\"참고\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0\" aria-label=\"참고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고</h2>\n<ul>\n<li><a href=\"https://peter-cho.gitbook.io/book/11/clean-architecture/13\">13장 컴포넌트 응집도</a></li>\n</ul>","frontmatter":{"title":"13장 컴포넌트 응집도","date":"May 04, 2020"}}},"pageContext":{"slug":"/clean architecture/13장-컴포넌트-응집도/","previous":{"fields":{"slug":"/clean architecture/10장-isp-인터페이스-분리-원칙/"},"frontmatter":{"title":"10장 ISP 인터페이스 분리 원칙","category":"clean architecture","draft":false}},"next":{"fields":{"slug":"/clean architecture/14장-컴포넌트-결합/"},"frontmatter":{"title":"14장 컴포넌트 결합","category":"clean architecture","draft":false}}}}}