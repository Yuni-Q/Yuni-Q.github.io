{"componentChunkName":"component---src-templates-blog-post-js","path":"/clean architecture/14장-컴포넌트-결합/","result":{"data":{"site":{"siteMetadata":{"title":"yuni-q 블로그","author":"yuni-q","siteUrl":"https://yuni-q.github.io","comment":{"disqusShortName":"yuni-q","utterances":"yuni_q"},"sponsor":{"buyMeACoffeeId":"yuniq"}}},"markdownRemark":{"id":"b2150970-dc0f-53d0-9921-218976f7a795","excerpt":"ADP: 의존성 비순환 원칙(Acyclic Dependencies Principle) 컴포넌트 의존성 그래프에 순환(cycle)이 있어서는 안 됩니다. 동일한 소스파일을 수정하는 환경에서 동작되던 기능이 다른 사람으로 인해 동작하지 않을 때는 숙취 증후군이라고 부릅니다. 숙취 증후군을 해결하기 위해서 ADP 원칙을 사용합니다. 이상적인 구조는 비순환 방향 그래프(Directed Acyclic Graph, DAG) 형태로 컴포넌트가 조립된 것입니다. 순환 의존성(Dependency Cycle…","html":"<h2 id=\"adp-의존성-비순환-원칙acyclic-dependencies-principle\" style=\"position:relative;\"><a href=\"#adp-%EC%9D%98%EC%A1%B4%EC%84%B1-%EB%B9%84%EC%88%9C%ED%99%98-%EC%9B%90%EC%B9%99acyclic-dependencies-principle\" aria-label=\"adp 의존성 비순환 원칙acyclic dependencies principle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ADP: 의존성 비순환 원칙(Acyclic Dependencies Principle)</h2>\n<ul>\n<li>컴포넌트 의존성 그래프에 순환(cycle)이 있어서는 안 됩니다.</li>\n<li>동일한 소스파일을 수정하는 환경에서 동작되던 기능이 다른 사람으로 인해 동작하지 않을 때는 숙취 증후군이라고 부릅니다. 숙취 증후군을 해결하기 위해서 ADP 원칙을 사용합니다.</li>\n<li>이상적인 구조는 비순환 방향 그래프(Directed Acyclic Graph, DAG) 형태로 컴포넌트가 조립된 것입니다. 순환 의존성(Dependency Cycle)이 발생하면 컴포넌트를 어떤 순서로 빌드해야 하는 지 알 수 없습니다.</li>\n<li>순환 의존성에서 DAG로 복구하기 위해서는 DIP를 적용합니다. DAG에서 순환 의존성이 발생하지 않도록 SRP와 CCP에 관심을 가져야 합니다.</li>\n</ul>\n<h2 id=\"sdp-안정된-의존성-원칙stable-dependencies-principle\" style=\"position:relative;\"><a href=\"#sdp-%EC%95%88%EC%A0%95%EB%90%9C-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%9B%90%EC%B9%99stable-dependencies-principle\" aria-label=\"sdp 안정된 의존성 원칙stable dependencies principle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SDP: 안정된 의존성 원칙(Stable Dependencies Principle)</h2>\n<ul>\n<li>안정성의 방향으로(더 안정된 쪽에) 의존합니다.</li>\n<li>안정성은 변경을 만들기 위해 필요한 작업량과 관련 됩니다. 소프트웨어 컴포넌트를 변경하기 어렵게 만드는 데는 많은 요인이 존재하며, 그 예로는 컴포넌트의 크기, 복잡도, 간결함 등을 들 수 있습니다.</li>\n</ul>\n<h3 id=\"안정성-지표\" style=\"position:relative;\"><a href=\"#%EC%95%88%EC%A0%95%EC%84%B1-%EC%A7%80%ED%91%9C\" aria-label=\"안정성 지표 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>안정성 지표</h3>\n<ul>\n<li>DIP를 통해 I를 낮출 수 있습니다.</li>\n<li>컴포넌트로 들어오고 나가는 의존성의 개수를 세어보는 방법으로 컴포넌트 안정성을 축정 할 수 있습니다. 이 숫자를 통해 컴포넌트가 위치상(Positional) 어느 정도의 안정성을 가지는 지 계산할 수 있습니다.</li>\n<li>Fan-in: 안으로 들어오는 의존성.</li>\n<li>Fan-out: 바깥으로 나가는 의존성.</li>\n<li>I(불안정성): I=Fan-out / (Fan-in + Fan-out). [0, 1] 범위값을 가집니다.</li>\n<li>I = 0이면 최고로 안정된 컴포넌트라는 뜻입니다.</li>\n<li>I = 1이면 최고로 불안정한 컴포넌트라는 뜻입니다.</li>\n</ul>\n<h2 id=\"sap-안정된-추상화-원칙stable-abstractions-principle\" style=\"position:relative;\"><a href=\"#sap-%EC%95%88%EC%A0%95%EB%90%9C-%EC%B6%94%EC%83%81%ED%99%94-%EC%9B%90%EC%B9%99stable-abstractions-principle\" aria-label=\"sap 안정된 추상화 원칙stable abstractions principle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SAP: 안정된 추상화 원칙(Stable Abstractions Principle)</h2>\n<ul>\n<li>컴포넌트는 안정된 정도 만큼만 추상화되어야 합니다.</li>\n<li>안정된 추상화 원칙은 안정성과 추상화 정도 사이의 관계를 정의합니다. 이 원칙은 한편으로는 안정된 컴포넌트는 추상 컴포넌트여야 하며, 이를 통해 안정성이 컴포넌트를 확장하는 일을 방해해서는 안된다고 말합니다. 따라서 안정적인 컴포넌트라면 반드시 인터페이스와 추상 클래스로 구성되어 쉽게 확장할 수 있어야 합니다. 안정된 컴포넌트가 확장이 가능해지면 유연성을 얻게 되고 아키텍처를 과도하게 제약하지 않게 됩니다.</li>\n<li>SAP와 SDP를 결합하면 컴포넌트에 대한 DIP나 마찬가지가 됩니다. 실제로 SDP에서는 의존성이 반드시 안정성의 방향으로 향해야 한다고 말하며, SAP에서는 안정성이 결국 추상화를 의미한다고 말하기 때문입니다. 따라서 의존성은 추상화의 방향으로 향하게 됩니다.</li>\n</ul>\n<h3 id=\"추상화-정도-측정하기\" style=\"position:relative;\"><a href=\"#%EC%B6%94%EC%83%81%ED%99%94-%EC%A0%95%EB%8F%84-%EC%B8%A1%EC%A0%95%ED%95%98%EA%B8%B0\" aria-label=\"추상화 정도 측정하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>추상화 정도 측정하기</h3>\n<ul>\n<li>Nc: 컴포넌트의 클래스 개수</li>\n<li>Na: 컴포넌트의 추상 클래스와 인터페이스 개수</li>\n<li>A: 추상화 정도. A=Na / Nc</li>\n<li>A 지표는 0과 1사이의 값을 가집니다. A가 0이면 컴포넌트에는 추상 클래스가 하나도 없다는 뜻입니다. A가 1이면 컴포넌트는 오로지 추상 클래스만을 포함한다는 뜻입니다.</li>\n</ul>\n<h2 id=\"참고\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0\" aria-label=\"참고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고</h2>\n<ul>\n<li><a href=\"https://peter-cho.gitbook.io/book/11/clean-architecture/14\">14장 컴포넌트 결합</a></li>\n</ul>","frontmatter":{"title":"14장 컴포넌트 결합","date":"May 04, 2020"}}},"pageContext":{"slug":"/clean architecture/14장-컴포넌트-결합/","previous":{"fields":{"slug":"/clean architecture/13장-컴포넌트-응집도/"},"frontmatter":{"title":"13장 컴포넌트 응집도","category":"clean architecture","draft":false}},"next":{"fields":{"slug":"/aws/data-transfer/"},"frontmatter":{"title":"data transfer","category":"aws","draft":false}}}}}