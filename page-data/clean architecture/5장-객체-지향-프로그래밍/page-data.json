{"componentChunkName":"component---src-templates-blog-post-js","path":"/clean architecture/5장-객체-지향-프로그래밍/","result":{"data":{"site":{"siteMetadata":{"title":"yuni-q 블로그","author":"yuni-q","siteUrl":"https://yuni-q.github.io","comment":{"disqusShortName":"yuni-q","utterances":"yuni_q"},"sponsor":{"buyMeACoffeeId":"yuniq"}}},"markdownRemark":{"id":"4b5bd319-807d-517e-8816-57320113d70a","excerpt":"플러그인 아키텍처 1950년대 후반에 프로그램은 장치 독립적이어야 함을 발견하게 되었습니다. 당시에 장치에 의존적인 수많은 프로그램을 만들었고, 다른 장치에 프로그램이 필요하면 기존 프로그램에서 상당한 많은 부분을 재작성헸습니다. 입출력 장치 독립성을 지원하기 위해 만들어 졌고, 등장 이후 거의 모든 운영체제에서 구현 되었습니다. 의존성 역전 일반적인 상황에서 프로그램은 Top-Down…","html":"<h2 id=\"플러그인-아키텍처\" style=\"position:relative;\"><a href=\"#%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98\" aria-label=\"플러그인 아키텍처 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>플러그인 아키텍처</h2>\n<ul>\n<li>1950년대 후반에 프로그램은 장치 독립적이어야 함을 발견하게 되었습니다. 당시에 장치에 의존적인 수많은 프로그램을 만들었고, 다른 장치에 프로그램이 필요하면 기존 프로그램에서 상당한 많은 부분을 재작성헸습니다.</li>\n<li>입출력 장치 독립성을 지원하기 위해 만들어 졌고, 등장 이후 거의 모든 운영체제에서 구현 되었습니다.</li>\n</ul>\n<h2 id=\"의존성-역전\" style=\"position:relative;\"><a href=\"#%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%97%AD%EC%A0%84\" aria-label=\"의존성 역전 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>의존성 역전</h2>\n<ul>\n<li>일반적인 상황에서 프로그램은 Top-Down으로 제어흐름이 흐릅니다.</li>\n<li>다형성이 끼어들면 의존성 역전 현상이 발생합니다.</li>\n<li>소스 코드 의존성이 제어흐름의 방향과 일치되도록 제한되지 않습니다.</li>\n</ul>\n<h2 id=\"결론\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론</h2>\n<ul>\n<li>소프트웨어 아키텍트 관점에서 OO란 다형성을 이용하여 전체시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력입니다.</li>\n<li>OO를 사용하면 아키텍트는 플러그인 아키텍처를 구성할 수 있고, 이를 통해 고수준의 정책을 포함하는 모든 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있습니다.</li>\n<li>저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 만들 수 있고, 고수준의 정책을 포함하는 모듈과는 독립적으로 개발하고 배포할 수 있습니다.</li>\n</ul>\n<h2 id=\"참고\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0\" aria-label=\"참고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고</h2>\n<ul>\n<li><a href=\"https://peter-cho.gitbook.io/book/11/clean-architecture/2\">5장 객체 지향 프로그래밍</a></li>\n</ul>","frontmatter":{"title":"5장 객체 지향 프로그래밍","date":"May 04, 2020"}}},"pageContext":{"slug":"/clean architecture/5장-객체-지향-프로그래밍/","previous":{"fields":{"slug":"/clean architecture/6장-함수형-프로그래밍/"},"frontmatter":{"title":"6장 함수형 프로그래밍","category":"clean architecture","draft":false}},"next":{"fields":{"slug":"/clean architecture/10장-isp-인터페이스-분리-원칙/"},"frontmatter":{"title":"10장 ISP 인터페이스 분리 원칙","category":"clean architecture","draft":false}}}}}