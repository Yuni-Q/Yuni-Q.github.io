{"version":3,"file":"component---src-pages-memo-canvas-tsx-b5d256769e7fbcf830f6.js","mappings":"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","sources":["webpack://yuni-q-blog/./src/pages/memo-canvas.tsx"],"sourcesContent":["import React, {\n  useEffect,\n  useRef,\n  useState,\n  MouseEvent,\n  ChangeEvent,\n  KeyboardEvent,\n} from 'react';\n\ninterface PostIt {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  text: string;\n}\n\nconst MemoCanvas: React.FC = () => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n\n  const [postIts, setPostIts] = useState<PostIt[]>([]);\n\n  const [selectedPostIt, setSelectedPostIt] = useState<number | null>(null);\n  const [isEditing, setIsEditing] = useState<number | null>(null);\n  const [isResizing, setIsResizing] = useState(false);\n  const [isRightClick, setIsRightClick] = useState(false);\n  const [isDarkMode, setIsDarkMode] = useState(false);\n\n  const [offset, setOffset] = useState<{ x: number; y: number }>({\n    x: 0,\n    y: 0,\n  });\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (canvas === null) return;\n\n    const context = canvas.getContext('2d');\n    if (context === null) return;\n\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    context.fillStyle = isDarkMode ? '#333' : '#fff';\n    context.fillRect(0, 0, canvas.width, canvas.height);\n\n    postIts.forEach((postIt) => {\n      context.fillStyle = isDarkMode ? '#555' : '#ffeb3b';\n      context.fillRect(postIt.x, postIt.y, postIt.width, postIt.height);\n      context.strokeStyle = isDarkMode ? '#fff' : '#000';\n      context.strokeRect(postIt.x, postIt.y, postIt.width, postIt.height);\n      context.fillStyle = isDarkMode ? '#fff' : '#000';\n      context.font = '16px Arial';\n      const words = postIt.text.split(' ');\n      let line = '';\n      const lineHeight = 20;\n      let y = postIt.y + 20;\n      words.forEach((word) => {\n        const testLine = line + word + ' ';\n        const metrics = context.measureText(testLine);\n        const testWidth = metrics.width;\n        if (testWidth > postIt.width - 20 && line !== '') {\n          context.fillText(line, postIt.x + 10, y);\n          line = word + ' ';\n          y += lineHeight;\n        } else {\n          line = testLine;\n        }\n      });\n      // 공백이 없는 경우에도 줄바꿈 처리\n      let testLine = line;\n      let metrics = context.measureText(testLine);\n      let testWidth = metrics.width;\n      while (testWidth > postIt.width - 20) {\n        let splitIndex = testLine.length - 1;\n        while (\n          context.measureText(testLine.substring(0, splitIndex)).width >\n          postIt.width - 20\n        ) {\n          splitIndex--;\n        }\n        context.fillText(testLine.substring(0, splitIndex), postIt.x + 10, y);\n        testLine = testLine.substring(splitIndex);\n        y += lineHeight;\n        metrics = context.measureText(testLine);\n        testWidth = metrics.width;\n      }\n      context.fillText(testLine, postIt.x + 10, y);\n    });\n  }, [postIts, isDarkMode]);\n\n  function handleMouseDown(event: MouseEvent<HTMLCanvasElement>) {\n    if (isEditing !== null) return;\n    event.preventDefault();\n\n    if (event.button === 2) {\n      setIsRightClick(true);\n    } else {\n      setIsRightClick(false);\n    }\n\n    const canvas = canvasRef.current;\n    if (canvas === null) return;\n\n    const rect = canvas.getBoundingClientRect();\n    const x = event.clientX - rect.left;\n    const y = event.clientY - rect.top;\n\n    const postItIndex = postIts.findIndex(\n      (postIt) =>\n        x >= postIt.x &&\n        x <= postIt.x + postIt.width &&\n        y >= postIt.y &&\n        y <= postIt.y + postIt.height,\n    );\n\n    if (postItIndex !== -1) {\n      setSelectedPostIt(postItIndex);\n      setOffset({\n        x: x - postIts[postItIndex].x,\n        y: y - postIts[postItIndex].y,\n      });\n      if (\n        x >= postIts[postItIndex].x + postIts[postItIndex].width - 10 &&\n        y >= postIts[postItIndex].y + postIts[postItIndex].height - 10\n      ) {\n        setIsResizing(true);\n      }\n    } else if (event.button === 2) {\n      // 우클릭 시에만 포스트잇 생성\n      const newPostIt: PostIt = {\n        x,\n        y,\n        width: 100,\n        height: 100,\n        text: 'New Post-It',\n      };\n      setPostIts([...postIts, newPostIt]);\n    }\n  }\n\n  function handleMouseMove(event: MouseEvent<HTMLCanvasElement>) {\n    if (selectedPostIt === null || isRightClick || isEditing !== null) return;\n\n    const canvas = canvasRef.current;\n    if (canvas === null) return;\n\n    const rect = canvas.getBoundingClientRect();\n    const x = event.clientX - rect.left;\n    const y = event.clientY - rect.top;\n\n    setPostIts((prevPostIts) =>\n      prevPostIts.map((postIt, index) =>\n        index === selectedPostIt\n          ? isResizing\n            ? {\n                ...postIt,\n                width: Math.max(x - postIt.x, 10),\n                height: Math.max(y - postIt.y, 10),\n              }\n            : { ...postIt, x: x - offset.x, y: y - offset.y }\n          : postIt,\n      ),\n    );\n  }\n\n  function handleMouseUp() {\n    setSelectedPostIt(null);\n    setIsResizing(false);\n    setIsRightClick(false);\n  }\n\n  function handleDoubleClick(event: MouseEvent<HTMLCanvasElement>) {\n    const canvas = canvasRef.current;\n    if (canvas === null) return;\n\n    const rect = canvas.getBoundingClientRect();\n    const x = event.clientX - rect.left;\n    const y = event.clientY - rect.top;\n\n    const postItIndex = postIts.findIndex(\n      (postIt) =>\n        x >= postIt.x &&\n        x <= postIt.x + postIt.width &&\n        y >= postIt.y &&\n        y <= postIt.y + postIt.height,\n    );\n\n    if (postItIndex !== -1) {\n      setIsEditing(postItIndex);\n    }\n  }\n\n  function handleTextChange(event: ChangeEvent<HTMLTextAreaElement>) {\n    if (isEditing === null) return;\n\n    const newText = event.target.value;\n    setPostIts((prevPostIts) =>\n      prevPostIts.map((postIt, index) =>\n        index === isEditing ? { ...postIt, text: newText } : postIt,\n      ),\n    );\n  }\n\n  function handleBlur() {\n    setIsEditing(null);\n  }\n\n  function handleKeyDown(event: KeyboardEvent<HTMLTextAreaElement>) {\n    if (event.key === 'Escape') {\n      setIsEditing(null);\n      setSelectedPostIt(null);\n    }\n  }\n\n  function handleCanvasClick(event: MouseEvent<HTMLDivElement>) {\n    if (isEditing !== null) {\n      event.stopPropagation();\n    }\n  }\n\n  function toggleDarkMode() {\n    setIsDarkMode((prevMode) => !prevMode);\n  }\n\n  // console.log({ selectedPostIt });\n\n  return (\n    <div onClick={handleCanvasClick}>\n      <nav\n        style={{ background: isDarkMode ? '#333' : '#fff', padding: '10px' }}\n      >\n        <button onClick={toggleDarkMode}>\n          {isDarkMode ? '라이트 모드' : '다크 모드'}\n        </button>\n      </nav>\n      <canvas\n        ref={canvasRef}\n        width=\"800\"\n        height=\"600\"\n        onMouseDown={handleMouseDown}\n        onMouseMove={handleMouseMove}\n        onMouseUp={handleMouseUp}\n        onDoubleClick={handleDoubleClick}\n        onContextMenu={(e) => e.preventDefault()}\n        style={{\n          border: '1px solid #000',\n          background: isDarkMode ? '#333' : '#fff',\n        }}\n      ></canvas>\n      {isEditing !== null && (\n        <textarea\n          value={postIts[isEditing].text}\n          onChange={handleTextChange}\n          onBlur={handleBlur}\n          onKeyDown={handleKeyDown}\n          style={{\n            position: 'absolute',\n            left: postIts[isEditing].x + canvasRef.current?.offsetLeft,\n            top: postIts[isEditing].y + canvasRef.current?.offsetTop,\n            width: postIts[isEditing].width,\n            height: postIts[isEditing].height,\n            background: isDarkMode ? '#555' : '#ffeb3b',\n            color: isDarkMode ? '#fff' : '#000',\n            border: 'none',\n            resize: 'none',\n            overflow: 'hidden',\n            boxSizing: 'border-box',\n            padding: '10px',\n            font: '16px Arial',\n            whiteSpace: 'pre-wrap', // 줄바꿈을 위해 추가\n          }}\n        />\n      )}\n    </div>\n  );\n};\n\nexport default MemoCanvas;\n"],"names":["MemoCanvas","_canvasRef$current","_canvasRef$current2","canvasRef","useRef","postIts","setPostIts","useState","selectedPostIt","setSelectedPostIt","isEditing","setIsEditing","isResizing","setIsResizing","isRightClick","setIsRightClick","isDarkMode","setIsDarkMode","offset","setOffset","x","y","useEffect","canvas","current","context","getContext","clearRect","width","height","fillStyle","fillRect","forEach","postIt","strokeStyle","strokeRect","font","words","text","split","line","word","testLine","measureText","fillText","metrics","testWidth","splitIndex","length","substring","React","onClick","event","stopPropagation","style","background","padding","prevMode","ref","onMouseDown","preventDefault","button","rect","getBoundingClientRect","clientX","left","clientY","top","postItIndex","findIndex","newPostIt","concat","_toConsumableArray","onMouseMove","prevPostIts","map","index","Math","max","onMouseUp","onDoubleClick","onContextMenu","e","border","value","onChange","newText","target","onBlur","onKeyDown","key","position","offsetLeft","offsetTop","color","resize","overflow","boxSizing","whiteSpace"],"sourceRoot":""}